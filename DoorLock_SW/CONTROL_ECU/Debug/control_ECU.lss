
control_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000032a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000042  00800060  000032a4  00003338  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000021  008000a2  008000a2  0000337a  2**0
                  ALLOC
  3 .stab         0000378c  00000000  00000000  0000337c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001863  00000000  00000000  00006b08  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000836b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  000084ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000861b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000a264  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000b14f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0000befc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0000c05c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000c2e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000cab7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 1b 15 	jmp	0x2a36	; 0x2a36 <__vector_3>
      10:	0c 94 e8 14 	jmp	0x29d0	; 0x29d0 <__vector_4>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 b5 14 	jmp	0x296a	; 0x296a <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 82 14 	jmp	0x2904	; 0x2904 <__vector_8>
      24:	0c 94 1c 14 	jmp	0x2838	; 0x2838 <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 4f 14 	jmp	0x289e	; 0x289e <__vector_19>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ea       	ldi	r30, 0xA4	; 164
      68:	f2 e3       	ldi	r31, 0x32	; 50
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3a       	cpi	r26, 0xA2	; 162
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	a2 ea       	ldi	r26, 0xA2	; 162
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3c       	cpi	r26, 0xC3	; 195
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <main>
      8a:	0c 94 50 19 	jmp	0x32a0	; 0x32a0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 d4 18 	jmp	0x31a8	; 0x31a8 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e8       	ldi	r26, 0x80	; 128
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 f0 18 	jmp	0x31e0	; 0x31e0 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 e0 18 	jmp	0x31c0	; 0x31c0 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 fc 18 	jmp	0x31f8	; 0x31f8 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 e0 18 	jmp	0x31c0	; 0x31c0 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 fc 18 	jmp	0x31f8	; 0x31f8 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 d4 18 	jmp	0x31a8	; 0x31a8 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__stack+0x3f>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__stack+0x55>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__stack+0x2d>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__stack+0x3f>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__stack+0x35>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__stack+0x3b>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__stack+0x55>
     494:	80 e8       	ldi	r24, 0x80	; 128
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__stack+0x1c7>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__stack+0x51>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__stack+0x1c7>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__stack+0x67>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__stack+0x1c7>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__stack+0xd3>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__stack+0xc7>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__stack+0xef>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__stack+0x109>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__stack+0x8f>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__stack+0x14d>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__stack+0x141>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__stack+0x11f>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__stack+0x16b>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__stack+0x153>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__stack+0x1ad>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__stack+0x1ad>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__stack+0x1ad>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__stack+0x1b7>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 f0 18 	jmp	0x31e0	; 0x31e0 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 e0 18 	jmp	0x31c0	; 0x31c0 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 fc 18 	jmp	0x31f8	; 0x31f8 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 e0 18 	jmp	0x31c0	; 0x31c0 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 fc 18 	jmp	0x31f8	; 0x31f8 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 e0 18 	jmp	0x31c0	; 0x31c0 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 fc 18 	jmp	0x31f8	; 0x31f8 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 e4 18 	jmp	0x31c8	; 0x31c8 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 00 19 	jmp	0x3200	; 0x3200 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__pack_f+0x178>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__pack_f+0x172>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__pack_f+0x17c>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__pack_f+0x114>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__pack_f+0x76>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__pack_f+0xca>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__pack_f+0x86>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__pack_f+0x7e>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__pack_f+0x9c>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__pack_f+0x94>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__pack_f+0xbe>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__pack_f+0xee>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__pack_f+0xf6>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__pack_f+0xf6>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__pack_f+0x10e>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__pack_f+0x162>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__pack_f+0x172>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__pack_f+0x144>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__pack_f+0x154>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__pack_f+0x14c>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__pack_f+0x162>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__pack_f+0x164>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__pack_f+0x17c>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
	/* Configure the direction for RS, RW and E pins as output pins */
	GPIO_setupPinDirection(LCD_RS_PORT_ID,LCD_RS_PIN_ID,PIN_OUTPUT);
     b4e:	80 e0       	ldi	r24, 0x00	; 0
     b50:	64 e0       	ldi	r22, 0x04	; 4
     b52:	41 e0       	ldi	r20, 0x01	; 1
     b54:	0e 94 83 10 	call	0x2106	; 0x2106 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_RW_PORT_ID,LCD_RW_PIN_ID,PIN_OUTPUT);
     b58:	80 e0       	ldi	r24, 0x00	; 0
     b5a:	65 e0       	ldi	r22, 0x05	; 5
     b5c:	41 e0       	ldi	r20, 0x01	; 1
     b5e:	0e 94 83 10 	call	0x2106	; 0x2106 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_E_PORT_ID,LCD_E_PIN_ID,PIN_OUTPUT);
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	66 e0       	ldi	r22, 0x06	; 6
     b66:	41 e0       	ldi	r20, 0x01	; 1
     b68:	0e 94 83 10 	call	0x2106	; 0x2106 <GPIO_setupPinDirection>
	LCD_sendCommand(LCD_GO_TO_HOME);
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */

#elif (LCD_DATA_BITS_MODE == 8)
	/* Configure the data port as output port */
	GPIO_setupPortDirection(LCD_DATA_PORT_ID,PORT_OUTPUT);
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	6f ef       	ldi	r22, 0xFF	; 255
     b70:	0e 94 f4 12 	call	0x25e8	; 0x25e8 <GPIO_setupPortDirection>
	LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
     b74:	88 e3       	ldi	r24, 0x38	; 56
     b76:	0e 94 c6 05 	call	0xb8c	; 0xb8c <LCD_sendCommand>
#endif

	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
     b7a:	8c e0       	ldi	r24, 0x0C	; 12
     b7c:	0e 94 c6 05 	call	0xb8c	; 0xb8c <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
     b80:	81 e0       	ldi	r24, 0x01	; 1
     b82:	0e 94 c6 05 	call	0xb8c	; 0xb8c <LCD_sendCommand>
}
     b86:	cf 91       	pop	r28
     b88:	df 91       	pop	r29
     b8a:	08 95       	ret

00000b8c <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(uint8 command)
{
     b8c:	df 93       	push	r29
     b8e:	cf 93       	push	r28
     b90:	cd b7       	in	r28, 0x3d	; 61
     b92:	de b7       	in	r29, 0x3e	; 62
     b94:	ea 97       	sbiw	r28, 0x3a	; 58
     b96:	0f b6       	in	r0, 0x3f	; 63
     b98:	f8 94       	cli
     b9a:	de bf       	out	0x3e, r29	; 62
     b9c:	0f be       	out	0x3f, r0	; 63
     b9e:	cd bf       	out	0x3d, r28	; 61
     ba0:	8a af       	std	Y+58, r24	; 0x3a
	uint8 lcd_port_value = 0;
     ba2:	19 ae       	std	Y+57, r1	; 0x39
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_LOW); /* Instruction Mode RS=0 */
     ba4:	80 e0       	ldi	r24, 0x00	; 0
     ba6:	64 e0       	ldi	r22, 0x04	; 4
     ba8:	40 e0       	ldi	r20, 0x00	; 0
     baa:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
	GPIO_writePin(LCD_RW_PORT_ID,LCD_RW_PIN_ID,LOGIC_LOW); /* write data to LCD so RW=0 */
     bae:	80 e0       	ldi	r24, 0x00	; 0
     bb0:	65 e0       	ldi	r22, 0x05	; 5
     bb2:	40 e0       	ldi	r20, 0x00	; 0
     bb4:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
     bb8:	80 e0       	ldi	r24, 0x00	; 0
     bba:	90 e0       	ldi	r25, 0x00	; 0
     bbc:	a0 e8       	ldi	r26, 0x80	; 128
     bbe:	bf e3       	ldi	r27, 0x3F	; 63
     bc0:	8d ab       	std	Y+53, r24	; 0x35
     bc2:	9e ab       	std	Y+54, r25	; 0x36
     bc4:	af ab       	std	Y+55, r26	; 0x37
     bc6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     bc8:	6d a9       	ldd	r22, Y+53	; 0x35
     bca:	7e a9       	ldd	r23, Y+54	; 0x36
     bcc:	8f a9       	ldd	r24, Y+55	; 0x37
     bce:	98 ad       	ldd	r25, Y+56	; 0x38
     bd0:	20 e0       	ldi	r18, 0x00	; 0
     bd2:	30 e0       	ldi	r19, 0x00	; 0
     bd4:	4a e7       	ldi	r20, 0x7A	; 122
     bd6:	53 e4       	ldi	r21, 0x43	; 67
     bd8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     bdc:	dc 01       	movw	r26, r24
     bde:	cb 01       	movw	r24, r22
     be0:	89 ab       	std	Y+49, r24	; 0x31
     be2:	9a ab       	std	Y+50, r25	; 0x32
     be4:	ab ab       	std	Y+51, r26	; 0x33
     be6:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
     be8:	69 a9       	ldd	r22, Y+49	; 0x31
     bea:	7a a9       	ldd	r23, Y+50	; 0x32
     bec:	8b a9       	ldd	r24, Y+51	; 0x33
     bee:	9c a9       	ldd	r25, Y+52	; 0x34
     bf0:	20 e0       	ldi	r18, 0x00	; 0
     bf2:	30 e0       	ldi	r19, 0x00	; 0
     bf4:	40 e8       	ldi	r20, 0x80	; 128
     bf6:	5f e3       	ldi	r21, 0x3F	; 63
     bf8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     bfc:	88 23       	and	r24, r24
     bfe:	2c f4       	brge	.+10     	; 0xc0a <LCD_sendCommand+0x7e>
		__ticks = 1;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	90 e0       	ldi	r25, 0x00	; 0
     c04:	98 ab       	std	Y+48, r25	; 0x30
     c06:	8f a7       	std	Y+47, r24	; 0x2f
     c08:	3f c0       	rjmp	.+126    	; 0xc88 <LCD_sendCommand+0xfc>
	else if (__tmp > 65535)
     c0a:	69 a9       	ldd	r22, Y+49	; 0x31
     c0c:	7a a9       	ldd	r23, Y+50	; 0x32
     c0e:	8b a9       	ldd	r24, Y+51	; 0x33
     c10:	9c a9       	ldd	r25, Y+52	; 0x34
     c12:	20 e0       	ldi	r18, 0x00	; 0
     c14:	3f ef       	ldi	r19, 0xFF	; 255
     c16:	4f e7       	ldi	r20, 0x7F	; 127
     c18:	57 e4       	ldi	r21, 0x47	; 71
     c1a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     c1e:	18 16       	cp	r1, r24
     c20:	4c f5       	brge	.+82     	; 0xc74 <LCD_sendCommand+0xe8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c22:	6d a9       	ldd	r22, Y+53	; 0x35
     c24:	7e a9       	ldd	r23, Y+54	; 0x36
     c26:	8f a9       	ldd	r24, Y+55	; 0x37
     c28:	98 ad       	ldd	r25, Y+56	; 0x38
     c2a:	20 e0       	ldi	r18, 0x00	; 0
     c2c:	30 e0       	ldi	r19, 0x00	; 0
     c2e:	40 e2       	ldi	r20, 0x20	; 32
     c30:	51 e4       	ldi	r21, 0x41	; 65
     c32:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c36:	dc 01       	movw	r26, r24
     c38:	cb 01       	movw	r24, r22
     c3a:	bc 01       	movw	r22, r24
     c3c:	cd 01       	movw	r24, r26
     c3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c42:	dc 01       	movw	r26, r24
     c44:	cb 01       	movw	r24, r22
     c46:	98 ab       	std	Y+48, r25	; 0x30
     c48:	8f a7       	std	Y+47, r24	; 0x2f
     c4a:	0f c0       	rjmp	.+30     	; 0xc6a <LCD_sendCommand+0xde>
     c4c:	89 e1       	ldi	r24, 0x19	; 25
     c4e:	90 e0       	ldi	r25, 0x00	; 0
     c50:	9e a7       	std	Y+46, r25	; 0x2e
     c52:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c54:	8d a5       	ldd	r24, Y+45	; 0x2d
     c56:	9e a5       	ldd	r25, Y+46	; 0x2e
     c58:	01 97       	sbiw	r24, 0x01	; 1
     c5a:	f1 f7       	brne	.-4      	; 0xc58 <LCD_sendCommand+0xcc>
     c5c:	9e a7       	std	Y+46, r25	; 0x2e
     c5e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     c60:	8f a5       	ldd	r24, Y+47	; 0x2f
     c62:	98 a9       	ldd	r25, Y+48	; 0x30
     c64:	01 97       	sbiw	r24, 0x01	; 1
     c66:	98 ab       	std	Y+48, r25	; 0x30
     c68:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     c6a:	8f a5       	ldd	r24, Y+47	; 0x2f
     c6c:	98 a9       	ldd	r25, Y+48	; 0x30
     c6e:	00 97       	sbiw	r24, 0x00	; 0
     c70:	69 f7       	brne	.-38     	; 0xc4c <LCD_sendCommand+0xc0>
     c72:	14 c0       	rjmp	.+40     	; 0xc9c <LCD_sendCommand+0x110>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     c74:	69 a9       	ldd	r22, Y+49	; 0x31
     c76:	7a a9       	ldd	r23, Y+50	; 0x32
     c78:	8b a9       	ldd	r24, Y+51	; 0x33
     c7a:	9c a9       	ldd	r25, Y+52	; 0x34
     c7c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c80:	dc 01       	movw	r26, r24
     c82:	cb 01       	movw	r24, r22
     c84:	98 ab       	std	Y+48, r25	; 0x30
     c86:	8f a7       	std	Y+47, r24	; 0x2f
     c88:	8f a5       	ldd	r24, Y+47	; 0x2f
     c8a:	98 a9       	ldd	r25, Y+48	; 0x30
     c8c:	9c a7       	std	Y+44, r25	; 0x2c
     c8e:	8b a7       	std	Y+43, r24	; 0x2b
     c90:	8b a5       	ldd	r24, Y+43	; 0x2b
     c92:	9c a5       	ldd	r25, Y+44	; 0x2c
     c94:	01 97       	sbiw	r24, 0x01	; 1
     c96:	f1 f7       	brne	.-4      	; 0xc94 <LCD_sendCommand+0x108>
     c98:	9c a7       	std	Y+44, r25	; 0x2c
     c9a:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
     c9c:	80 e0       	ldi	r24, 0x00	; 0
     c9e:	66 e0       	ldi	r22, 0x06	; 6
     ca0:	41 e0       	ldi	r20, 0x01	; 1
     ca2:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
     ca6:	80 e0       	ldi	r24, 0x00	; 0
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	a0 e8       	ldi	r26, 0x80	; 128
     cac:	bf e3       	ldi	r27, 0x3F	; 63
     cae:	8f a3       	std	Y+39, r24	; 0x27
     cb0:	98 a7       	std	Y+40, r25	; 0x28
     cb2:	a9 a7       	std	Y+41, r26	; 0x29
     cb4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     cb6:	6f a1       	ldd	r22, Y+39	; 0x27
     cb8:	78 a5       	ldd	r23, Y+40	; 0x28
     cba:	89 a5       	ldd	r24, Y+41	; 0x29
     cbc:	9a a5       	ldd	r25, Y+42	; 0x2a
     cbe:	20 e0       	ldi	r18, 0x00	; 0
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	4a e7       	ldi	r20, 0x7A	; 122
     cc4:	53 e4       	ldi	r21, 0x43	; 67
     cc6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     cca:	dc 01       	movw	r26, r24
     ccc:	cb 01       	movw	r24, r22
     cce:	8b a3       	std	Y+35, r24	; 0x23
     cd0:	9c a3       	std	Y+36, r25	; 0x24
     cd2:	ad a3       	std	Y+37, r26	; 0x25
     cd4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
     cd6:	6b a1       	ldd	r22, Y+35	; 0x23
     cd8:	7c a1       	ldd	r23, Y+36	; 0x24
     cda:	8d a1       	ldd	r24, Y+37	; 0x25
     cdc:	9e a1       	ldd	r25, Y+38	; 0x26
     cde:	20 e0       	ldi	r18, 0x00	; 0
     ce0:	30 e0       	ldi	r19, 0x00	; 0
     ce2:	40 e8       	ldi	r20, 0x80	; 128
     ce4:	5f e3       	ldi	r21, 0x3F	; 63
     ce6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     cea:	88 23       	and	r24, r24
     cec:	2c f4       	brge	.+10     	; 0xcf8 <LCD_sendCommand+0x16c>
		__ticks = 1;
     cee:	81 e0       	ldi	r24, 0x01	; 1
     cf0:	90 e0       	ldi	r25, 0x00	; 0
     cf2:	9a a3       	std	Y+34, r25	; 0x22
     cf4:	89 a3       	std	Y+33, r24	; 0x21
     cf6:	3f c0       	rjmp	.+126    	; 0xd76 <LCD_sendCommand+0x1ea>
	else if (__tmp > 65535)
     cf8:	6b a1       	ldd	r22, Y+35	; 0x23
     cfa:	7c a1       	ldd	r23, Y+36	; 0x24
     cfc:	8d a1       	ldd	r24, Y+37	; 0x25
     cfe:	9e a1       	ldd	r25, Y+38	; 0x26
     d00:	20 e0       	ldi	r18, 0x00	; 0
     d02:	3f ef       	ldi	r19, 0xFF	; 255
     d04:	4f e7       	ldi	r20, 0x7F	; 127
     d06:	57 e4       	ldi	r21, 0x47	; 71
     d08:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     d0c:	18 16       	cp	r1, r24
     d0e:	4c f5       	brge	.+82     	; 0xd62 <LCD_sendCommand+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d10:	6f a1       	ldd	r22, Y+39	; 0x27
     d12:	78 a5       	ldd	r23, Y+40	; 0x28
     d14:	89 a5       	ldd	r24, Y+41	; 0x29
     d16:	9a a5       	ldd	r25, Y+42	; 0x2a
     d18:	20 e0       	ldi	r18, 0x00	; 0
     d1a:	30 e0       	ldi	r19, 0x00	; 0
     d1c:	40 e2       	ldi	r20, 0x20	; 32
     d1e:	51 e4       	ldi	r21, 0x41	; 65
     d20:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d24:	dc 01       	movw	r26, r24
     d26:	cb 01       	movw	r24, r22
     d28:	bc 01       	movw	r22, r24
     d2a:	cd 01       	movw	r24, r26
     d2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d30:	dc 01       	movw	r26, r24
     d32:	cb 01       	movw	r24, r22
     d34:	9a a3       	std	Y+34, r25	; 0x22
     d36:	89 a3       	std	Y+33, r24	; 0x21
     d38:	0f c0       	rjmp	.+30     	; 0xd58 <LCD_sendCommand+0x1cc>
     d3a:	89 e1       	ldi	r24, 0x19	; 25
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	98 a3       	std	Y+32, r25	; 0x20
     d40:	8f 8f       	std	Y+31, r24	; 0x1f
     d42:	8f 8d       	ldd	r24, Y+31	; 0x1f
     d44:	98 a1       	ldd	r25, Y+32	; 0x20
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	f1 f7       	brne	.-4      	; 0xd46 <LCD_sendCommand+0x1ba>
     d4a:	98 a3       	std	Y+32, r25	; 0x20
     d4c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d4e:	89 a1       	ldd	r24, Y+33	; 0x21
     d50:	9a a1       	ldd	r25, Y+34	; 0x22
     d52:	01 97       	sbiw	r24, 0x01	; 1
     d54:	9a a3       	std	Y+34, r25	; 0x22
     d56:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d58:	89 a1       	ldd	r24, Y+33	; 0x21
     d5a:	9a a1       	ldd	r25, Y+34	; 0x22
     d5c:	00 97       	sbiw	r24, 0x00	; 0
     d5e:	69 f7       	brne	.-38     	; 0xd3a <LCD_sendCommand+0x1ae>
     d60:	14 c0       	rjmp	.+40     	; 0xd8a <LCD_sendCommand+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d62:	6b a1       	ldd	r22, Y+35	; 0x23
     d64:	7c a1       	ldd	r23, Y+36	; 0x24
     d66:	8d a1       	ldd	r24, Y+37	; 0x25
     d68:	9e a1       	ldd	r25, Y+38	; 0x26
     d6a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d6e:	dc 01       	movw	r26, r24
     d70:	cb 01       	movw	r24, r22
     d72:	9a a3       	std	Y+34, r25	; 0x22
     d74:	89 a3       	std	Y+33, r24	; 0x21
     d76:	89 a1       	ldd	r24, Y+33	; 0x21
     d78:	9a a1       	ldd	r25, Y+34	; 0x22
     d7a:	9e 8f       	std	Y+30, r25	; 0x1e
     d7c:	8d 8f       	std	Y+29, r24	; 0x1d
     d7e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d80:	9e 8d       	ldd	r25, Y+30	; 0x1e
     d82:	01 97       	sbiw	r24, 0x01	; 1
     d84:	f1 f7       	brne	.-4      	; 0xd82 <LCD_sendCommand+0x1f6>
     d86:	9e 8f       	std	Y+30, r25	; 0x1e
     d88:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */

#elif (LCD_DATA_BITS_MODE == 8)
	GPIO_writePort(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
     d8a:	81 e0       	ldi	r24, 0x01	; 1
     d8c:	6a ad       	ldd	r22, Y+58	; 0x3a
     d8e:	0e 94 38 13 	call	0x2670	; 0x2670 <GPIO_writePort>
     d92:	80 e0       	ldi	r24, 0x00	; 0
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	a0 e8       	ldi	r26, 0x80	; 128
     d98:	bf e3       	ldi	r27, 0x3F	; 63
     d9a:	89 8f       	std	Y+25, r24	; 0x19
     d9c:	9a 8f       	std	Y+26, r25	; 0x1a
     d9e:	ab 8f       	std	Y+27, r26	; 0x1b
     da0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     da2:	69 8d       	ldd	r22, Y+25	; 0x19
     da4:	7a 8d       	ldd	r23, Y+26	; 0x1a
     da6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     da8:	9c 8d       	ldd	r25, Y+28	; 0x1c
     daa:	20 e0       	ldi	r18, 0x00	; 0
     dac:	30 e0       	ldi	r19, 0x00	; 0
     dae:	4a e7       	ldi	r20, 0x7A	; 122
     db0:	53 e4       	ldi	r21, 0x43	; 67
     db2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     db6:	dc 01       	movw	r26, r24
     db8:	cb 01       	movw	r24, r22
     dba:	8d 8b       	std	Y+21, r24	; 0x15
     dbc:	9e 8b       	std	Y+22, r25	; 0x16
     dbe:	af 8b       	std	Y+23, r26	; 0x17
     dc0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     dc2:	6d 89       	ldd	r22, Y+21	; 0x15
     dc4:	7e 89       	ldd	r23, Y+22	; 0x16
     dc6:	8f 89       	ldd	r24, Y+23	; 0x17
     dc8:	98 8d       	ldd	r25, Y+24	; 0x18
     dca:	20 e0       	ldi	r18, 0x00	; 0
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	40 e8       	ldi	r20, 0x80	; 128
     dd0:	5f e3       	ldi	r21, 0x3F	; 63
     dd2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     dd6:	88 23       	and	r24, r24
     dd8:	2c f4       	brge	.+10     	; 0xde4 <LCD_sendCommand+0x258>
		__ticks = 1;
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	9c 8b       	std	Y+20, r25	; 0x14
     de0:	8b 8b       	std	Y+19, r24	; 0x13
     de2:	3f c0       	rjmp	.+126    	; 0xe62 <LCD_sendCommand+0x2d6>
	else if (__tmp > 65535)
     de4:	6d 89       	ldd	r22, Y+21	; 0x15
     de6:	7e 89       	ldd	r23, Y+22	; 0x16
     de8:	8f 89       	ldd	r24, Y+23	; 0x17
     dea:	98 8d       	ldd	r25, Y+24	; 0x18
     dec:	20 e0       	ldi	r18, 0x00	; 0
     dee:	3f ef       	ldi	r19, 0xFF	; 255
     df0:	4f e7       	ldi	r20, 0x7F	; 127
     df2:	57 e4       	ldi	r21, 0x47	; 71
     df4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     df8:	18 16       	cp	r1, r24
     dfa:	4c f5       	brge	.+82     	; 0xe4e <LCD_sendCommand+0x2c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     dfc:	69 8d       	ldd	r22, Y+25	; 0x19
     dfe:	7a 8d       	ldd	r23, Y+26	; 0x1a
     e00:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e02:	9c 8d       	ldd	r25, Y+28	; 0x1c
     e04:	20 e0       	ldi	r18, 0x00	; 0
     e06:	30 e0       	ldi	r19, 0x00	; 0
     e08:	40 e2       	ldi	r20, 0x20	; 32
     e0a:	51 e4       	ldi	r21, 0x41	; 65
     e0c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e10:	dc 01       	movw	r26, r24
     e12:	cb 01       	movw	r24, r22
     e14:	bc 01       	movw	r22, r24
     e16:	cd 01       	movw	r24, r26
     e18:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e1c:	dc 01       	movw	r26, r24
     e1e:	cb 01       	movw	r24, r22
     e20:	9c 8b       	std	Y+20, r25	; 0x14
     e22:	8b 8b       	std	Y+19, r24	; 0x13
     e24:	0f c0       	rjmp	.+30     	; 0xe44 <LCD_sendCommand+0x2b8>
     e26:	89 e1       	ldi	r24, 0x19	; 25
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	9a 8b       	std	Y+18, r25	; 0x12
     e2c:	89 8b       	std	Y+17, r24	; 0x11
     e2e:	89 89       	ldd	r24, Y+17	; 0x11
     e30:	9a 89       	ldd	r25, Y+18	; 0x12
     e32:	01 97       	sbiw	r24, 0x01	; 1
     e34:	f1 f7       	brne	.-4      	; 0xe32 <LCD_sendCommand+0x2a6>
     e36:	9a 8b       	std	Y+18, r25	; 0x12
     e38:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e3a:	8b 89       	ldd	r24, Y+19	; 0x13
     e3c:	9c 89       	ldd	r25, Y+20	; 0x14
     e3e:	01 97       	sbiw	r24, 0x01	; 1
     e40:	9c 8b       	std	Y+20, r25	; 0x14
     e42:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     e44:	8b 89       	ldd	r24, Y+19	; 0x13
     e46:	9c 89       	ldd	r25, Y+20	; 0x14
     e48:	00 97       	sbiw	r24, 0x00	; 0
     e4a:	69 f7       	brne	.-38     	; 0xe26 <LCD_sendCommand+0x29a>
     e4c:	14 c0       	rjmp	.+40     	; 0xe76 <LCD_sendCommand+0x2ea>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     e4e:	6d 89       	ldd	r22, Y+21	; 0x15
     e50:	7e 89       	ldd	r23, Y+22	; 0x16
     e52:	8f 89       	ldd	r24, Y+23	; 0x17
     e54:	98 8d       	ldd	r25, Y+24	; 0x18
     e56:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e5a:	dc 01       	movw	r26, r24
     e5c:	cb 01       	movw	r24, r22
     e5e:	9c 8b       	std	Y+20, r25	; 0x14
     e60:	8b 8b       	std	Y+19, r24	; 0x13
     e62:	8b 89       	ldd	r24, Y+19	; 0x13
     e64:	9c 89       	ldd	r25, Y+20	; 0x14
     e66:	98 8b       	std	Y+16, r25	; 0x10
     e68:	8f 87       	std	Y+15, r24	; 0x0f
     e6a:	8f 85       	ldd	r24, Y+15	; 0x0f
     e6c:	98 89       	ldd	r25, Y+16	; 0x10
     e6e:	01 97       	sbiw	r24, 0x01	; 1
     e70:	f1 f7       	brne	.-4      	; 0xe6e <LCD_sendCommand+0x2e2>
     e72:	98 8b       	std	Y+16, r25	; 0x10
     e74:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
     e76:	80 e0       	ldi	r24, 0x00	; 0
     e78:	66 e0       	ldi	r22, 0x06	; 6
     e7a:	40 e0       	ldi	r20, 0x00	; 0
     e7c:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
     e80:	80 e0       	ldi	r24, 0x00	; 0
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	a0 e8       	ldi	r26, 0x80	; 128
     e86:	bf e3       	ldi	r27, 0x3F	; 63
     e88:	8b 87       	std	Y+11, r24	; 0x0b
     e8a:	9c 87       	std	Y+12, r25	; 0x0c
     e8c:	ad 87       	std	Y+13, r26	; 0x0d
     e8e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     e90:	6b 85       	ldd	r22, Y+11	; 0x0b
     e92:	7c 85       	ldd	r23, Y+12	; 0x0c
     e94:	8d 85       	ldd	r24, Y+13	; 0x0d
     e96:	9e 85       	ldd	r25, Y+14	; 0x0e
     e98:	20 e0       	ldi	r18, 0x00	; 0
     e9a:	30 e0       	ldi	r19, 0x00	; 0
     e9c:	4a e7       	ldi	r20, 0x7A	; 122
     e9e:	53 e4       	ldi	r21, 0x43	; 67
     ea0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ea4:	dc 01       	movw	r26, r24
     ea6:	cb 01       	movw	r24, r22
     ea8:	8f 83       	std	Y+7, r24	; 0x07
     eaa:	98 87       	std	Y+8, r25	; 0x08
     eac:	a9 87       	std	Y+9, r26	; 0x09
     eae:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     eb0:	6f 81       	ldd	r22, Y+7	; 0x07
     eb2:	78 85       	ldd	r23, Y+8	; 0x08
     eb4:	89 85       	ldd	r24, Y+9	; 0x09
     eb6:	9a 85       	ldd	r25, Y+10	; 0x0a
     eb8:	20 e0       	ldi	r18, 0x00	; 0
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	40 e8       	ldi	r20, 0x80	; 128
     ebe:	5f e3       	ldi	r21, 0x3F	; 63
     ec0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     ec4:	88 23       	and	r24, r24
     ec6:	2c f4       	brge	.+10     	; 0xed2 <LCD_sendCommand+0x346>
		__ticks = 1;
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	9e 83       	std	Y+6, r25	; 0x06
     ece:	8d 83       	std	Y+5, r24	; 0x05
     ed0:	3f c0       	rjmp	.+126    	; 0xf50 <LCD_sendCommand+0x3c4>
	else if (__tmp > 65535)
     ed2:	6f 81       	ldd	r22, Y+7	; 0x07
     ed4:	78 85       	ldd	r23, Y+8	; 0x08
     ed6:	89 85       	ldd	r24, Y+9	; 0x09
     ed8:	9a 85       	ldd	r25, Y+10	; 0x0a
     eda:	20 e0       	ldi	r18, 0x00	; 0
     edc:	3f ef       	ldi	r19, 0xFF	; 255
     ede:	4f e7       	ldi	r20, 0x7F	; 127
     ee0:	57 e4       	ldi	r21, 0x47	; 71
     ee2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     ee6:	18 16       	cp	r1, r24
     ee8:	4c f5       	brge	.+82     	; 0xf3c <LCD_sendCommand+0x3b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     eea:	6b 85       	ldd	r22, Y+11	; 0x0b
     eec:	7c 85       	ldd	r23, Y+12	; 0x0c
     eee:	8d 85       	ldd	r24, Y+13	; 0x0d
     ef0:	9e 85       	ldd	r25, Y+14	; 0x0e
     ef2:	20 e0       	ldi	r18, 0x00	; 0
     ef4:	30 e0       	ldi	r19, 0x00	; 0
     ef6:	40 e2       	ldi	r20, 0x20	; 32
     ef8:	51 e4       	ldi	r21, 0x41	; 65
     efa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     efe:	dc 01       	movw	r26, r24
     f00:	cb 01       	movw	r24, r22
     f02:	bc 01       	movw	r22, r24
     f04:	cd 01       	movw	r24, r26
     f06:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f0a:	dc 01       	movw	r26, r24
     f0c:	cb 01       	movw	r24, r22
     f0e:	9e 83       	std	Y+6, r25	; 0x06
     f10:	8d 83       	std	Y+5, r24	; 0x05
     f12:	0f c0       	rjmp	.+30     	; 0xf32 <LCD_sendCommand+0x3a6>
     f14:	89 e1       	ldi	r24, 0x19	; 25
     f16:	90 e0       	ldi	r25, 0x00	; 0
     f18:	9c 83       	std	Y+4, r25	; 0x04
     f1a:	8b 83       	std	Y+3, r24	; 0x03
     f1c:	8b 81       	ldd	r24, Y+3	; 0x03
     f1e:	9c 81       	ldd	r25, Y+4	; 0x04
     f20:	01 97       	sbiw	r24, 0x01	; 1
     f22:	f1 f7       	brne	.-4      	; 0xf20 <LCD_sendCommand+0x394>
     f24:	9c 83       	std	Y+4, r25	; 0x04
     f26:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f28:	8d 81       	ldd	r24, Y+5	; 0x05
     f2a:	9e 81       	ldd	r25, Y+6	; 0x06
     f2c:	01 97       	sbiw	r24, 0x01	; 1
     f2e:	9e 83       	std	Y+6, r25	; 0x06
     f30:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f32:	8d 81       	ldd	r24, Y+5	; 0x05
     f34:	9e 81       	ldd	r25, Y+6	; 0x06
     f36:	00 97       	sbiw	r24, 0x00	; 0
     f38:	69 f7       	brne	.-38     	; 0xf14 <LCD_sendCommand+0x388>
     f3a:	14 c0       	rjmp	.+40     	; 0xf64 <LCD_sendCommand+0x3d8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f3c:	6f 81       	ldd	r22, Y+7	; 0x07
     f3e:	78 85       	ldd	r23, Y+8	; 0x08
     f40:	89 85       	ldd	r24, Y+9	; 0x09
     f42:	9a 85       	ldd	r25, Y+10	; 0x0a
     f44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f48:	dc 01       	movw	r26, r24
     f4a:	cb 01       	movw	r24, r22
     f4c:	9e 83       	std	Y+6, r25	; 0x06
     f4e:	8d 83       	std	Y+5, r24	; 0x05
     f50:	8d 81       	ldd	r24, Y+5	; 0x05
     f52:	9e 81       	ldd	r25, Y+6	; 0x06
     f54:	9a 83       	std	Y+2, r25	; 0x02
     f56:	89 83       	std	Y+1, r24	; 0x01
     f58:	89 81       	ldd	r24, Y+1	; 0x01
     f5a:	9a 81       	ldd	r25, Y+2	; 0x02
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	f1 f7       	brne	.-4      	; 0xf5c <LCD_sendCommand+0x3d0>
     f60:	9a 83       	std	Y+2, r25	; 0x02
     f62:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
     f64:	ea 96       	adiw	r28, 0x3a	; 58
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	f8 94       	cli
     f6a:	de bf       	out	0x3e, r29	; 62
     f6c:	0f be       	out	0x3f, r0	; 63
     f6e:	cd bf       	out	0x3d, r28	; 61
     f70:	cf 91       	pop	r28
     f72:	df 91       	pop	r29
     f74:	08 95       	ret

00000f76 <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
     f76:	df 93       	push	r29
     f78:	cf 93       	push	r28
     f7a:	cd b7       	in	r28, 0x3d	; 61
     f7c:	de b7       	in	r29, 0x3e	; 62
     f7e:	ea 97       	sbiw	r28, 0x3a	; 58
     f80:	0f b6       	in	r0, 0x3f	; 63
     f82:	f8 94       	cli
     f84:	de bf       	out	0x3e, r29	; 62
     f86:	0f be       	out	0x3f, r0	; 63
     f88:	cd bf       	out	0x3d, r28	; 61
     f8a:	8a af       	std	Y+58, r24	; 0x3a
	uint8 lcd_port_value = 0;
     f8c:	19 ae       	std	Y+57, r1	; 0x39
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_HIGH); /* Data Mode RS=1 */
     f8e:	80 e0       	ldi	r24, 0x00	; 0
     f90:	64 e0       	ldi	r22, 0x04	; 4
     f92:	41 e0       	ldi	r20, 0x01	; 1
     f94:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
	GPIO_writePin(LCD_RW_PORT_ID,LCD_RW_PIN_ID,LOGIC_LOW); /* write data to LCD so RW=0 */
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	65 e0       	ldi	r22, 0x05	; 5
     f9c:	40 e0       	ldi	r20, 0x00	; 0
     f9e:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
     fa2:	80 e0       	ldi	r24, 0x00	; 0
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	a0 e8       	ldi	r26, 0x80	; 128
     fa8:	bf e3       	ldi	r27, 0x3F	; 63
     faa:	8d ab       	std	Y+53, r24	; 0x35
     fac:	9e ab       	std	Y+54, r25	; 0x36
     fae:	af ab       	std	Y+55, r26	; 0x37
     fb0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     fb2:	6d a9       	ldd	r22, Y+53	; 0x35
     fb4:	7e a9       	ldd	r23, Y+54	; 0x36
     fb6:	8f a9       	ldd	r24, Y+55	; 0x37
     fb8:	98 ad       	ldd	r25, Y+56	; 0x38
     fba:	20 e0       	ldi	r18, 0x00	; 0
     fbc:	30 e0       	ldi	r19, 0x00	; 0
     fbe:	4a e7       	ldi	r20, 0x7A	; 122
     fc0:	53 e4       	ldi	r21, 0x43	; 67
     fc2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fc6:	dc 01       	movw	r26, r24
     fc8:	cb 01       	movw	r24, r22
     fca:	89 ab       	std	Y+49, r24	; 0x31
     fcc:	9a ab       	std	Y+50, r25	; 0x32
     fce:	ab ab       	std	Y+51, r26	; 0x33
     fd0:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
     fd2:	69 a9       	ldd	r22, Y+49	; 0x31
     fd4:	7a a9       	ldd	r23, Y+50	; 0x32
     fd6:	8b a9       	ldd	r24, Y+51	; 0x33
     fd8:	9c a9       	ldd	r25, Y+52	; 0x34
     fda:	20 e0       	ldi	r18, 0x00	; 0
     fdc:	30 e0       	ldi	r19, 0x00	; 0
     fde:	40 e8       	ldi	r20, 0x80	; 128
     fe0:	5f e3       	ldi	r21, 0x3F	; 63
     fe2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     fe6:	88 23       	and	r24, r24
     fe8:	2c f4       	brge	.+10     	; 0xff4 <LCD_displayCharacter+0x7e>
		__ticks = 1;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	98 ab       	std	Y+48, r25	; 0x30
     ff0:	8f a7       	std	Y+47, r24	; 0x2f
     ff2:	3f c0       	rjmp	.+126    	; 0x1072 <LCD_displayCharacter+0xfc>
	else if (__tmp > 65535)
     ff4:	69 a9       	ldd	r22, Y+49	; 0x31
     ff6:	7a a9       	ldd	r23, Y+50	; 0x32
     ff8:	8b a9       	ldd	r24, Y+51	; 0x33
     ffa:	9c a9       	ldd	r25, Y+52	; 0x34
     ffc:	20 e0       	ldi	r18, 0x00	; 0
     ffe:	3f ef       	ldi	r19, 0xFF	; 255
    1000:	4f e7       	ldi	r20, 0x7F	; 127
    1002:	57 e4       	ldi	r21, 0x47	; 71
    1004:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1008:	18 16       	cp	r1, r24
    100a:	4c f5       	brge	.+82     	; 0x105e <LCD_displayCharacter+0xe8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    100c:	6d a9       	ldd	r22, Y+53	; 0x35
    100e:	7e a9       	ldd	r23, Y+54	; 0x36
    1010:	8f a9       	ldd	r24, Y+55	; 0x37
    1012:	98 ad       	ldd	r25, Y+56	; 0x38
    1014:	20 e0       	ldi	r18, 0x00	; 0
    1016:	30 e0       	ldi	r19, 0x00	; 0
    1018:	40 e2       	ldi	r20, 0x20	; 32
    101a:	51 e4       	ldi	r21, 0x41	; 65
    101c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1020:	dc 01       	movw	r26, r24
    1022:	cb 01       	movw	r24, r22
    1024:	bc 01       	movw	r22, r24
    1026:	cd 01       	movw	r24, r26
    1028:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    102c:	dc 01       	movw	r26, r24
    102e:	cb 01       	movw	r24, r22
    1030:	98 ab       	std	Y+48, r25	; 0x30
    1032:	8f a7       	std	Y+47, r24	; 0x2f
    1034:	0f c0       	rjmp	.+30     	; 0x1054 <LCD_displayCharacter+0xde>
    1036:	89 e1       	ldi	r24, 0x19	; 25
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	9e a7       	std	Y+46, r25	; 0x2e
    103c:	8d a7       	std	Y+45, r24	; 0x2d
    103e:	8d a5       	ldd	r24, Y+45	; 0x2d
    1040:	9e a5       	ldd	r25, Y+46	; 0x2e
    1042:	01 97       	sbiw	r24, 0x01	; 1
    1044:	f1 f7       	brne	.-4      	; 0x1042 <LCD_displayCharacter+0xcc>
    1046:	9e a7       	std	Y+46, r25	; 0x2e
    1048:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    104a:	8f a5       	ldd	r24, Y+47	; 0x2f
    104c:	98 a9       	ldd	r25, Y+48	; 0x30
    104e:	01 97       	sbiw	r24, 0x01	; 1
    1050:	98 ab       	std	Y+48, r25	; 0x30
    1052:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1054:	8f a5       	ldd	r24, Y+47	; 0x2f
    1056:	98 a9       	ldd	r25, Y+48	; 0x30
    1058:	00 97       	sbiw	r24, 0x00	; 0
    105a:	69 f7       	brne	.-38     	; 0x1036 <LCD_displayCharacter+0xc0>
    105c:	14 c0       	rjmp	.+40     	; 0x1086 <LCD_displayCharacter+0x110>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    105e:	69 a9       	ldd	r22, Y+49	; 0x31
    1060:	7a a9       	ldd	r23, Y+50	; 0x32
    1062:	8b a9       	ldd	r24, Y+51	; 0x33
    1064:	9c a9       	ldd	r25, Y+52	; 0x34
    1066:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    106a:	dc 01       	movw	r26, r24
    106c:	cb 01       	movw	r24, r22
    106e:	98 ab       	std	Y+48, r25	; 0x30
    1070:	8f a7       	std	Y+47, r24	; 0x2f
    1072:	8f a5       	ldd	r24, Y+47	; 0x2f
    1074:	98 a9       	ldd	r25, Y+48	; 0x30
    1076:	9c a7       	std	Y+44, r25	; 0x2c
    1078:	8b a7       	std	Y+43, r24	; 0x2b
    107a:	8b a5       	ldd	r24, Y+43	; 0x2b
    107c:	9c a5       	ldd	r25, Y+44	; 0x2c
    107e:	01 97       	sbiw	r24, 0x01	; 1
    1080:	f1 f7       	brne	.-4      	; 0x107e <LCD_displayCharacter+0x108>
    1082:	9c a7       	std	Y+44, r25	; 0x2c
    1084:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    1086:	80 e0       	ldi	r24, 0x00	; 0
    1088:	66 e0       	ldi	r22, 0x06	; 6
    108a:	41 e0       	ldi	r20, 0x01	; 1
    108c:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
    1090:	80 e0       	ldi	r24, 0x00	; 0
    1092:	90 e0       	ldi	r25, 0x00	; 0
    1094:	a0 e8       	ldi	r26, 0x80	; 128
    1096:	bf e3       	ldi	r27, 0x3F	; 63
    1098:	8f a3       	std	Y+39, r24	; 0x27
    109a:	98 a7       	std	Y+40, r25	; 0x28
    109c:	a9 a7       	std	Y+41, r26	; 0x29
    109e:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    10a0:	6f a1       	ldd	r22, Y+39	; 0x27
    10a2:	78 a5       	ldd	r23, Y+40	; 0x28
    10a4:	89 a5       	ldd	r24, Y+41	; 0x29
    10a6:	9a a5       	ldd	r25, Y+42	; 0x2a
    10a8:	20 e0       	ldi	r18, 0x00	; 0
    10aa:	30 e0       	ldi	r19, 0x00	; 0
    10ac:	4a e7       	ldi	r20, 0x7A	; 122
    10ae:	53 e4       	ldi	r21, 0x43	; 67
    10b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10b4:	dc 01       	movw	r26, r24
    10b6:	cb 01       	movw	r24, r22
    10b8:	8b a3       	std	Y+35, r24	; 0x23
    10ba:	9c a3       	std	Y+36, r25	; 0x24
    10bc:	ad a3       	std	Y+37, r26	; 0x25
    10be:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    10c0:	6b a1       	ldd	r22, Y+35	; 0x23
    10c2:	7c a1       	ldd	r23, Y+36	; 0x24
    10c4:	8d a1       	ldd	r24, Y+37	; 0x25
    10c6:	9e a1       	ldd	r25, Y+38	; 0x26
    10c8:	20 e0       	ldi	r18, 0x00	; 0
    10ca:	30 e0       	ldi	r19, 0x00	; 0
    10cc:	40 e8       	ldi	r20, 0x80	; 128
    10ce:	5f e3       	ldi	r21, 0x3F	; 63
    10d0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    10d4:	88 23       	and	r24, r24
    10d6:	2c f4       	brge	.+10     	; 0x10e2 <LCD_displayCharacter+0x16c>
		__ticks = 1;
    10d8:	81 e0       	ldi	r24, 0x01	; 1
    10da:	90 e0       	ldi	r25, 0x00	; 0
    10dc:	9a a3       	std	Y+34, r25	; 0x22
    10de:	89 a3       	std	Y+33, r24	; 0x21
    10e0:	3f c0       	rjmp	.+126    	; 0x1160 <LCD_displayCharacter+0x1ea>
	else if (__tmp > 65535)
    10e2:	6b a1       	ldd	r22, Y+35	; 0x23
    10e4:	7c a1       	ldd	r23, Y+36	; 0x24
    10e6:	8d a1       	ldd	r24, Y+37	; 0x25
    10e8:	9e a1       	ldd	r25, Y+38	; 0x26
    10ea:	20 e0       	ldi	r18, 0x00	; 0
    10ec:	3f ef       	ldi	r19, 0xFF	; 255
    10ee:	4f e7       	ldi	r20, 0x7F	; 127
    10f0:	57 e4       	ldi	r21, 0x47	; 71
    10f2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    10f6:	18 16       	cp	r1, r24
    10f8:	4c f5       	brge	.+82     	; 0x114c <LCD_displayCharacter+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10fa:	6f a1       	ldd	r22, Y+39	; 0x27
    10fc:	78 a5       	ldd	r23, Y+40	; 0x28
    10fe:	89 a5       	ldd	r24, Y+41	; 0x29
    1100:	9a a5       	ldd	r25, Y+42	; 0x2a
    1102:	20 e0       	ldi	r18, 0x00	; 0
    1104:	30 e0       	ldi	r19, 0x00	; 0
    1106:	40 e2       	ldi	r20, 0x20	; 32
    1108:	51 e4       	ldi	r21, 0x41	; 65
    110a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    110e:	dc 01       	movw	r26, r24
    1110:	cb 01       	movw	r24, r22
    1112:	bc 01       	movw	r22, r24
    1114:	cd 01       	movw	r24, r26
    1116:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    111a:	dc 01       	movw	r26, r24
    111c:	cb 01       	movw	r24, r22
    111e:	9a a3       	std	Y+34, r25	; 0x22
    1120:	89 a3       	std	Y+33, r24	; 0x21
    1122:	0f c0       	rjmp	.+30     	; 0x1142 <LCD_displayCharacter+0x1cc>
    1124:	89 e1       	ldi	r24, 0x19	; 25
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	98 a3       	std	Y+32, r25	; 0x20
    112a:	8f 8f       	std	Y+31, r24	; 0x1f
    112c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    112e:	98 a1       	ldd	r25, Y+32	; 0x20
    1130:	01 97       	sbiw	r24, 0x01	; 1
    1132:	f1 f7       	brne	.-4      	; 0x1130 <LCD_displayCharacter+0x1ba>
    1134:	98 a3       	std	Y+32, r25	; 0x20
    1136:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1138:	89 a1       	ldd	r24, Y+33	; 0x21
    113a:	9a a1       	ldd	r25, Y+34	; 0x22
    113c:	01 97       	sbiw	r24, 0x01	; 1
    113e:	9a a3       	std	Y+34, r25	; 0x22
    1140:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1142:	89 a1       	ldd	r24, Y+33	; 0x21
    1144:	9a a1       	ldd	r25, Y+34	; 0x22
    1146:	00 97       	sbiw	r24, 0x00	; 0
    1148:	69 f7       	brne	.-38     	; 0x1124 <LCD_displayCharacter+0x1ae>
    114a:	14 c0       	rjmp	.+40     	; 0x1174 <LCD_displayCharacter+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    114c:	6b a1       	ldd	r22, Y+35	; 0x23
    114e:	7c a1       	ldd	r23, Y+36	; 0x24
    1150:	8d a1       	ldd	r24, Y+37	; 0x25
    1152:	9e a1       	ldd	r25, Y+38	; 0x26
    1154:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1158:	dc 01       	movw	r26, r24
    115a:	cb 01       	movw	r24, r22
    115c:	9a a3       	std	Y+34, r25	; 0x22
    115e:	89 a3       	std	Y+33, r24	; 0x21
    1160:	89 a1       	ldd	r24, Y+33	; 0x21
    1162:	9a a1       	ldd	r25, Y+34	; 0x22
    1164:	9e 8f       	std	Y+30, r25	; 0x1e
    1166:	8d 8f       	std	Y+29, r24	; 0x1d
    1168:	8d 8d       	ldd	r24, Y+29	; 0x1d
    116a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    116c:	01 97       	sbiw	r24, 0x01	; 1
    116e:	f1 f7       	brne	.-4      	; 0x116c <LCD_displayCharacter+0x1f6>
    1170:	9e 8f       	std	Y+30, r25	; 0x1e
    1172:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */

#elif (LCD_DATA_BITS_MODE == 8)
	GPIO_writePort(LCD_DATA_PORT_ID,data); /* out the required data to the data bus D0 --> D7 */
    1174:	81 e0       	ldi	r24, 0x01	; 1
    1176:	6a ad       	ldd	r22, Y+58	; 0x3a
    1178:	0e 94 38 13 	call	0x2670	; 0x2670 <GPIO_writePort>
    117c:	80 e0       	ldi	r24, 0x00	; 0
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	a0 e8       	ldi	r26, 0x80	; 128
    1182:	bf e3       	ldi	r27, 0x3F	; 63
    1184:	89 8f       	std	Y+25, r24	; 0x19
    1186:	9a 8f       	std	Y+26, r25	; 0x1a
    1188:	ab 8f       	std	Y+27, r26	; 0x1b
    118a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    118c:	69 8d       	ldd	r22, Y+25	; 0x19
    118e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1190:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1192:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1194:	20 e0       	ldi	r18, 0x00	; 0
    1196:	30 e0       	ldi	r19, 0x00	; 0
    1198:	4a e7       	ldi	r20, 0x7A	; 122
    119a:	53 e4       	ldi	r21, 0x43	; 67
    119c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    11a0:	dc 01       	movw	r26, r24
    11a2:	cb 01       	movw	r24, r22
    11a4:	8d 8b       	std	Y+21, r24	; 0x15
    11a6:	9e 8b       	std	Y+22, r25	; 0x16
    11a8:	af 8b       	std	Y+23, r26	; 0x17
    11aa:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    11ac:	6d 89       	ldd	r22, Y+21	; 0x15
    11ae:	7e 89       	ldd	r23, Y+22	; 0x16
    11b0:	8f 89       	ldd	r24, Y+23	; 0x17
    11b2:	98 8d       	ldd	r25, Y+24	; 0x18
    11b4:	20 e0       	ldi	r18, 0x00	; 0
    11b6:	30 e0       	ldi	r19, 0x00	; 0
    11b8:	40 e8       	ldi	r20, 0x80	; 128
    11ba:	5f e3       	ldi	r21, 0x3F	; 63
    11bc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    11c0:	88 23       	and	r24, r24
    11c2:	2c f4       	brge	.+10     	; 0x11ce <LCD_displayCharacter+0x258>
		__ticks = 1;
    11c4:	81 e0       	ldi	r24, 0x01	; 1
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	9c 8b       	std	Y+20, r25	; 0x14
    11ca:	8b 8b       	std	Y+19, r24	; 0x13
    11cc:	3f c0       	rjmp	.+126    	; 0x124c <LCD_displayCharacter+0x2d6>
	else if (__tmp > 65535)
    11ce:	6d 89       	ldd	r22, Y+21	; 0x15
    11d0:	7e 89       	ldd	r23, Y+22	; 0x16
    11d2:	8f 89       	ldd	r24, Y+23	; 0x17
    11d4:	98 8d       	ldd	r25, Y+24	; 0x18
    11d6:	20 e0       	ldi	r18, 0x00	; 0
    11d8:	3f ef       	ldi	r19, 0xFF	; 255
    11da:	4f e7       	ldi	r20, 0x7F	; 127
    11dc:	57 e4       	ldi	r21, 0x47	; 71
    11de:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    11e2:	18 16       	cp	r1, r24
    11e4:	4c f5       	brge	.+82     	; 0x1238 <LCD_displayCharacter+0x2c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    11e6:	69 8d       	ldd	r22, Y+25	; 0x19
    11e8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    11ea:	8b 8d       	ldd	r24, Y+27	; 0x1b
    11ec:	9c 8d       	ldd	r25, Y+28	; 0x1c
    11ee:	20 e0       	ldi	r18, 0x00	; 0
    11f0:	30 e0       	ldi	r19, 0x00	; 0
    11f2:	40 e2       	ldi	r20, 0x20	; 32
    11f4:	51 e4       	ldi	r21, 0x41	; 65
    11f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    11fa:	dc 01       	movw	r26, r24
    11fc:	cb 01       	movw	r24, r22
    11fe:	bc 01       	movw	r22, r24
    1200:	cd 01       	movw	r24, r26
    1202:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1206:	dc 01       	movw	r26, r24
    1208:	cb 01       	movw	r24, r22
    120a:	9c 8b       	std	Y+20, r25	; 0x14
    120c:	8b 8b       	std	Y+19, r24	; 0x13
    120e:	0f c0       	rjmp	.+30     	; 0x122e <LCD_displayCharacter+0x2b8>
    1210:	89 e1       	ldi	r24, 0x19	; 25
    1212:	90 e0       	ldi	r25, 0x00	; 0
    1214:	9a 8b       	std	Y+18, r25	; 0x12
    1216:	89 8b       	std	Y+17, r24	; 0x11
    1218:	89 89       	ldd	r24, Y+17	; 0x11
    121a:	9a 89       	ldd	r25, Y+18	; 0x12
    121c:	01 97       	sbiw	r24, 0x01	; 1
    121e:	f1 f7       	brne	.-4      	; 0x121c <LCD_displayCharacter+0x2a6>
    1220:	9a 8b       	std	Y+18, r25	; 0x12
    1222:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1224:	8b 89       	ldd	r24, Y+19	; 0x13
    1226:	9c 89       	ldd	r25, Y+20	; 0x14
    1228:	01 97       	sbiw	r24, 0x01	; 1
    122a:	9c 8b       	std	Y+20, r25	; 0x14
    122c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    122e:	8b 89       	ldd	r24, Y+19	; 0x13
    1230:	9c 89       	ldd	r25, Y+20	; 0x14
    1232:	00 97       	sbiw	r24, 0x00	; 0
    1234:	69 f7       	brne	.-38     	; 0x1210 <LCD_displayCharacter+0x29a>
    1236:	14 c0       	rjmp	.+40     	; 0x1260 <LCD_displayCharacter+0x2ea>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1238:	6d 89       	ldd	r22, Y+21	; 0x15
    123a:	7e 89       	ldd	r23, Y+22	; 0x16
    123c:	8f 89       	ldd	r24, Y+23	; 0x17
    123e:	98 8d       	ldd	r25, Y+24	; 0x18
    1240:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1244:	dc 01       	movw	r26, r24
    1246:	cb 01       	movw	r24, r22
    1248:	9c 8b       	std	Y+20, r25	; 0x14
    124a:	8b 8b       	std	Y+19, r24	; 0x13
    124c:	8b 89       	ldd	r24, Y+19	; 0x13
    124e:	9c 89       	ldd	r25, Y+20	; 0x14
    1250:	98 8b       	std	Y+16, r25	; 0x10
    1252:	8f 87       	std	Y+15, r24	; 0x0f
    1254:	8f 85       	ldd	r24, Y+15	; 0x0f
    1256:	98 89       	ldd	r25, Y+16	; 0x10
    1258:	01 97       	sbiw	r24, 0x01	; 1
    125a:	f1 f7       	brne	.-4      	; 0x1258 <LCD_displayCharacter+0x2e2>
    125c:	98 8b       	std	Y+16, r25	; 0x10
    125e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    1260:	80 e0       	ldi	r24, 0x00	; 0
    1262:	66 e0       	ldi	r22, 0x06	; 6
    1264:	40 e0       	ldi	r20, 0x00	; 0
    1266:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
    126a:	80 e0       	ldi	r24, 0x00	; 0
    126c:	90 e0       	ldi	r25, 0x00	; 0
    126e:	a0 e8       	ldi	r26, 0x80	; 128
    1270:	bf e3       	ldi	r27, 0x3F	; 63
    1272:	8b 87       	std	Y+11, r24	; 0x0b
    1274:	9c 87       	std	Y+12, r25	; 0x0c
    1276:	ad 87       	std	Y+13, r26	; 0x0d
    1278:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    127a:	6b 85       	ldd	r22, Y+11	; 0x0b
    127c:	7c 85       	ldd	r23, Y+12	; 0x0c
    127e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1280:	9e 85       	ldd	r25, Y+14	; 0x0e
    1282:	20 e0       	ldi	r18, 0x00	; 0
    1284:	30 e0       	ldi	r19, 0x00	; 0
    1286:	4a e7       	ldi	r20, 0x7A	; 122
    1288:	53 e4       	ldi	r21, 0x43	; 67
    128a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    128e:	dc 01       	movw	r26, r24
    1290:	cb 01       	movw	r24, r22
    1292:	8f 83       	std	Y+7, r24	; 0x07
    1294:	98 87       	std	Y+8, r25	; 0x08
    1296:	a9 87       	std	Y+9, r26	; 0x09
    1298:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    129a:	6f 81       	ldd	r22, Y+7	; 0x07
    129c:	78 85       	ldd	r23, Y+8	; 0x08
    129e:	89 85       	ldd	r24, Y+9	; 0x09
    12a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    12a2:	20 e0       	ldi	r18, 0x00	; 0
    12a4:	30 e0       	ldi	r19, 0x00	; 0
    12a6:	40 e8       	ldi	r20, 0x80	; 128
    12a8:	5f e3       	ldi	r21, 0x3F	; 63
    12aa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    12ae:	88 23       	and	r24, r24
    12b0:	2c f4       	brge	.+10     	; 0x12bc <LCD_displayCharacter+0x346>
		__ticks = 1;
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	9e 83       	std	Y+6, r25	; 0x06
    12b8:	8d 83       	std	Y+5, r24	; 0x05
    12ba:	3f c0       	rjmp	.+126    	; 0x133a <LCD_displayCharacter+0x3c4>
	else if (__tmp > 65535)
    12bc:	6f 81       	ldd	r22, Y+7	; 0x07
    12be:	78 85       	ldd	r23, Y+8	; 0x08
    12c0:	89 85       	ldd	r24, Y+9	; 0x09
    12c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    12c4:	20 e0       	ldi	r18, 0x00	; 0
    12c6:	3f ef       	ldi	r19, 0xFF	; 255
    12c8:	4f e7       	ldi	r20, 0x7F	; 127
    12ca:	57 e4       	ldi	r21, 0x47	; 71
    12cc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    12d0:	18 16       	cp	r1, r24
    12d2:	4c f5       	brge	.+82     	; 0x1326 <LCD_displayCharacter+0x3b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    12d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    12d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    12d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    12da:	9e 85       	ldd	r25, Y+14	; 0x0e
    12dc:	20 e0       	ldi	r18, 0x00	; 0
    12de:	30 e0       	ldi	r19, 0x00	; 0
    12e0:	40 e2       	ldi	r20, 0x20	; 32
    12e2:	51 e4       	ldi	r21, 0x41	; 65
    12e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    12e8:	dc 01       	movw	r26, r24
    12ea:	cb 01       	movw	r24, r22
    12ec:	bc 01       	movw	r22, r24
    12ee:	cd 01       	movw	r24, r26
    12f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    12f4:	dc 01       	movw	r26, r24
    12f6:	cb 01       	movw	r24, r22
    12f8:	9e 83       	std	Y+6, r25	; 0x06
    12fa:	8d 83       	std	Y+5, r24	; 0x05
    12fc:	0f c0       	rjmp	.+30     	; 0x131c <LCD_displayCharacter+0x3a6>
    12fe:	89 e1       	ldi	r24, 0x19	; 25
    1300:	90 e0       	ldi	r25, 0x00	; 0
    1302:	9c 83       	std	Y+4, r25	; 0x04
    1304:	8b 83       	std	Y+3, r24	; 0x03
    1306:	8b 81       	ldd	r24, Y+3	; 0x03
    1308:	9c 81       	ldd	r25, Y+4	; 0x04
    130a:	01 97       	sbiw	r24, 0x01	; 1
    130c:	f1 f7       	brne	.-4      	; 0x130a <LCD_displayCharacter+0x394>
    130e:	9c 83       	std	Y+4, r25	; 0x04
    1310:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1312:	8d 81       	ldd	r24, Y+5	; 0x05
    1314:	9e 81       	ldd	r25, Y+6	; 0x06
    1316:	01 97       	sbiw	r24, 0x01	; 1
    1318:	9e 83       	std	Y+6, r25	; 0x06
    131a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    131c:	8d 81       	ldd	r24, Y+5	; 0x05
    131e:	9e 81       	ldd	r25, Y+6	; 0x06
    1320:	00 97       	sbiw	r24, 0x00	; 0
    1322:	69 f7       	brne	.-38     	; 0x12fe <LCD_displayCharacter+0x388>
    1324:	14 c0       	rjmp	.+40     	; 0x134e <LCD_displayCharacter+0x3d8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1326:	6f 81       	ldd	r22, Y+7	; 0x07
    1328:	78 85       	ldd	r23, Y+8	; 0x08
    132a:	89 85       	ldd	r24, Y+9	; 0x09
    132c:	9a 85       	ldd	r25, Y+10	; 0x0a
    132e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1332:	dc 01       	movw	r26, r24
    1334:	cb 01       	movw	r24, r22
    1336:	9e 83       	std	Y+6, r25	; 0x06
    1338:	8d 83       	std	Y+5, r24	; 0x05
    133a:	8d 81       	ldd	r24, Y+5	; 0x05
    133c:	9e 81       	ldd	r25, Y+6	; 0x06
    133e:	9a 83       	std	Y+2, r25	; 0x02
    1340:	89 83       	std	Y+1, r24	; 0x01
    1342:	89 81       	ldd	r24, Y+1	; 0x01
    1344:	9a 81       	ldd	r25, Y+2	; 0x02
    1346:	01 97       	sbiw	r24, 0x01	; 1
    1348:	f1 f7       	brne	.-4      	; 0x1346 <LCD_displayCharacter+0x3d0>
    134a:	9a 83       	std	Y+2, r25	; 0x02
    134c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    134e:	ea 96       	adiw	r28, 0x3a	; 58
    1350:	0f b6       	in	r0, 0x3f	; 63
    1352:	f8 94       	cli
    1354:	de bf       	out	0x3e, r29	; 62
    1356:	0f be       	out	0x3f, r0	; 63
    1358:	cd bf       	out	0x3d, r28	; 61
    135a:	cf 91       	pop	r28
    135c:	df 91       	pop	r29
    135e:	08 95       	ret

00001360 <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
    1360:	df 93       	push	r29
    1362:	cf 93       	push	r28
    1364:	00 d0       	rcall	.+0      	; 0x1366 <LCD_displayString+0x6>
    1366:	0f 92       	push	r0
    1368:	cd b7       	in	r28, 0x3d	; 61
    136a:	de b7       	in	r29, 0x3e	; 62
    136c:	9b 83       	std	Y+3, r25	; 0x03
    136e:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1370:	19 82       	std	Y+1, r1	; 0x01
    1372:	0e c0       	rjmp	.+28     	; 0x1390 <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    1374:	89 81       	ldd	r24, Y+1	; 0x01
    1376:	28 2f       	mov	r18, r24
    1378:	30 e0       	ldi	r19, 0x00	; 0
    137a:	8a 81       	ldd	r24, Y+2	; 0x02
    137c:	9b 81       	ldd	r25, Y+3	; 0x03
    137e:	fc 01       	movw	r30, r24
    1380:	e2 0f       	add	r30, r18
    1382:	f3 1f       	adc	r31, r19
    1384:	80 81       	ld	r24, Z
    1386:	0e 94 bb 07 	call	0xf76	; 0xf76 <LCD_displayCharacter>
		i++;
    138a:	89 81       	ldd	r24, Y+1	; 0x01
    138c:	8f 5f       	subi	r24, 0xFF	; 255
    138e:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    1390:	89 81       	ldd	r24, Y+1	; 0x01
    1392:	28 2f       	mov	r18, r24
    1394:	30 e0       	ldi	r19, 0x00	; 0
    1396:	8a 81       	ldd	r24, Y+2	; 0x02
    1398:	9b 81       	ldd	r25, Y+3	; 0x03
    139a:	fc 01       	movw	r30, r24
    139c:	e2 0f       	add	r30, r18
    139e:	f3 1f       	adc	r31, r19
    13a0:	80 81       	ld	r24, Z
    13a2:	88 23       	and	r24, r24
    13a4:	39 f7       	brne	.-50     	; 0x1374 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}
	*********************************************************/
}
    13a6:	0f 90       	pop	r0
    13a8:	0f 90       	pop	r0
    13aa:	0f 90       	pop	r0
    13ac:	cf 91       	pop	r28
    13ae:	df 91       	pop	r29
    13b0:	08 95       	ret

000013b2 <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(uint8 row,uint8 col)
{
    13b2:	df 93       	push	r29
    13b4:	cf 93       	push	r28
    13b6:	00 d0       	rcall	.+0      	; 0x13b8 <LCD_moveCursor+0x6>
    13b8:	00 d0       	rcall	.+0      	; 0x13ba <LCD_moveCursor+0x8>
    13ba:	0f 92       	push	r0
    13bc:	cd b7       	in	r28, 0x3d	; 61
    13be:	de b7       	in	r29, 0x3e	; 62
    13c0:	8a 83       	std	Y+2, r24	; 0x02
    13c2:	6b 83       	std	Y+3, r22	; 0x03
	uint8 lcd_memory_address;

	/* Calculate the required address in the LCD DDRAM */
	switch(row)
    13c4:	8a 81       	ldd	r24, Y+2	; 0x02
    13c6:	28 2f       	mov	r18, r24
    13c8:	30 e0       	ldi	r19, 0x00	; 0
    13ca:	3d 83       	std	Y+5, r19	; 0x05
    13cc:	2c 83       	std	Y+4, r18	; 0x04
    13ce:	8c 81       	ldd	r24, Y+4	; 0x04
    13d0:	9d 81       	ldd	r25, Y+5	; 0x05
    13d2:	81 30       	cpi	r24, 0x01	; 1
    13d4:	91 05       	cpc	r25, r1
    13d6:	c1 f0       	breq	.+48     	; 0x1408 <LCD_moveCursor+0x56>
    13d8:	2c 81       	ldd	r18, Y+4	; 0x04
    13da:	3d 81       	ldd	r19, Y+5	; 0x05
    13dc:	22 30       	cpi	r18, 0x02	; 2
    13de:	31 05       	cpc	r19, r1
    13e0:	2c f4       	brge	.+10     	; 0x13ec <LCD_moveCursor+0x3a>
    13e2:	8c 81       	ldd	r24, Y+4	; 0x04
    13e4:	9d 81       	ldd	r25, Y+5	; 0x05
    13e6:	00 97       	sbiw	r24, 0x00	; 0
    13e8:	61 f0       	breq	.+24     	; 0x1402 <LCD_moveCursor+0x50>
    13ea:	19 c0       	rjmp	.+50     	; 0x141e <LCD_moveCursor+0x6c>
    13ec:	2c 81       	ldd	r18, Y+4	; 0x04
    13ee:	3d 81       	ldd	r19, Y+5	; 0x05
    13f0:	22 30       	cpi	r18, 0x02	; 2
    13f2:	31 05       	cpc	r19, r1
    13f4:	69 f0       	breq	.+26     	; 0x1410 <LCD_moveCursor+0x5e>
    13f6:	8c 81       	ldd	r24, Y+4	; 0x04
    13f8:	9d 81       	ldd	r25, Y+5	; 0x05
    13fa:	83 30       	cpi	r24, 0x03	; 3
    13fc:	91 05       	cpc	r25, r1
    13fe:	61 f0       	breq	.+24     	; 0x1418 <LCD_moveCursor+0x66>
    1400:	0e c0       	rjmp	.+28     	; 0x141e <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
    1402:	8b 81       	ldd	r24, Y+3	; 0x03
    1404:	89 83       	std	Y+1, r24	; 0x01
    1406:	0b c0       	rjmp	.+22     	; 0x141e <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
    1408:	8b 81       	ldd	r24, Y+3	; 0x03
    140a:	80 5c       	subi	r24, 0xC0	; 192
    140c:	89 83       	std	Y+1, r24	; 0x01
    140e:	07 c0       	rjmp	.+14     	; 0x141e <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
    1410:	8b 81       	ldd	r24, Y+3	; 0x03
    1412:	80 5f       	subi	r24, 0xF0	; 240
    1414:	89 83       	std	Y+1, r24	; 0x01
    1416:	03 c0       	rjmp	.+6      	; 0x141e <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
    1418:	8b 81       	ldd	r24, Y+3	; 0x03
    141a:	80 5b       	subi	r24, 0xB0	; 176
    141c:	89 83       	std	Y+1, r24	; 0x01
				break;
	}
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    141e:	89 81       	ldd	r24, Y+1	; 0x01
    1420:	80 68       	ori	r24, 0x80	; 128
    1422:	0e 94 c6 05 	call	0xb8c	; 0xb8c <LCD_sendCommand>
}
    1426:	0f 90       	pop	r0
    1428:	0f 90       	pop	r0
    142a:	0f 90       	pop	r0
    142c:	0f 90       	pop	r0
    142e:	0f 90       	pop	r0
    1430:	cf 91       	pop	r28
    1432:	df 91       	pop	r29
    1434:	08 95       	ret

00001436 <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    1436:	df 93       	push	r29
    1438:	cf 93       	push	r28
    143a:	00 d0       	rcall	.+0      	; 0x143c <LCD_displayStringRowColumn+0x6>
    143c:	00 d0       	rcall	.+0      	; 0x143e <LCD_displayStringRowColumn+0x8>
    143e:	cd b7       	in	r28, 0x3d	; 61
    1440:	de b7       	in	r29, 0x3e	; 62
    1442:	89 83       	std	Y+1, r24	; 0x01
    1444:	6a 83       	std	Y+2, r22	; 0x02
    1446:	5c 83       	std	Y+4, r21	; 0x04
    1448:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
    144a:	89 81       	ldd	r24, Y+1	; 0x01
    144c:	6a 81       	ldd	r22, Y+2	; 0x02
    144e:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
    1452:	8b 81       	ldd	r24, Y+3	; 0x03
    1454:	9c 81       	ldd	r25, Y+4	; 0x04
    1456:	0e 94 b0 09 	call	0x1360	; 0x1360 <LCD_displayString>
}
    145a:	0f 90       	pop	r0
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	cf 91       	pop	r28
    1464:	df 91       	pop	r29
    1466:	08 95       	ret

00001468 <LCD_intgerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_intgerToString(int data)
{
    1468:	df 93       	push	r29
    146a:	cf 93       	push	r28
    146c:	cd b7       	in	r28, 0x3d	; 61
    146e:	de b7       	in	r29, 0x3e	; 62
    1470:	62 97       	sbiw	r28, 0x12	; 18
    1472:	0f b6       	in	r0, 0x3f	; 63
    1474:	f8 94       	cli
    1476:	de bf       	out	0x3e, r29	; 62
    1478:	0f be       	out	0x3f, r0	; 63
    147a:	cd bf       	out	0x3d, r28	; 61
    147c:	9a 8b       	std	Y+18, r25	; 0x12
    147e:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    1480:	89 89       	ldd	r24, Y+17	; 0x11
    1482:	9a 89       	ldd	r25, Y+18	; 0x12
    1484:	9e 01       	movw	r18, r28
    1486:	2f 5f       	subi	r18, 0xFF	; 255
    1488:	3f 4f       	sbci	r19, 0xFF	; 255
    148a:	b9 01       	movw	r22, r18
    148c:	4a e0       	ldi	r20, 0x0A	; 10
    148e:	50 e0       	ldi	r21, 0x00	; 0
    1490:	0e 94 0b 19 	call	0x3216	; 0x3216 <itoa>
   LCD_displayString(buff); /* Display the string */
    1494:	ce 01       	movw	r24, r28
    1496:	01 96       	adiw	r24, 0x01	; 1
    1498:	0e 94 b0 09 	call	0x1360	; 0x1360 <LCD_displayString>
}
    149c:	62 96       	adiw	r28, 0x12	; 18
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	f8 94       	cli
    14a2:	de bf       	out	0x3e, r29	; 62
    14a4:	0f be       	out	0x3f, r0	; 63
    14a6:	cd bf       	out	0x3d, r28	; 61
    14a8:	cf 91       	pop	r28
    14aa:	df 91       	pop	r29
    14ac:	08 95       	ret

000014ae <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    14ae:	df 93       	push	r29
    14b0:	cf 93       	push	r28
    14b2:	cd b7       	in	r28, 0x3d	; 61
    14b4:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	0e 94 c6 05 	call	0xb8c	; 0xb8c <LCD_sendCommand>
}
    14bc:	cf 91       	pop	r28
    14be:	df 91       	pop	r29
    14c0:	08 95       	ret

000014c2 <buzzer_Init>:
 * 					   direction for the buzzer pin through the GPIO driver.
 *                    Disable the buzzer at the beginning through the GPIO driver.
 *
 * [Args]          : NONE
 *******************************************************************************/
void buzzer_Init(void){
    14c2:	df 93       	push	r29
    14c4:	cf 93       	push	r28
    14c6:	cd b7       	in	r28, 0x3d	; 61
    14c8:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(BUZZER_PORT_ID, BUZZER_PIN_ID, PIN_OUTPUT);
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	62 e0       	ldi	r22, 0x02	; 2
    14ce:	41 e0       	ldi	r20, 0x01	; 1
    14d0:	0e 94 83 10 	call	0x2106	; 0x2106 <GPIO_setupPinDirection>
	GPIO_writePin(BUZZER_PORT_ID, BUZZER_PIN_ID, LOGIC_LOW);
    14d4:	80 e0       	ldi	r24, 0x00	; 0
    14d6:	62 e0       	ldi	r22, 0x02	; 2
    14d8:	40 e0       	ldi	r20, 0x00	; 0
    14da:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
}
    14de:	cf 91       	pop	r28
    14e0:	df 91       	pop	r29
    14e2:	08 95       	ret

000014e4 <buzzer_ON>:
 *
 * [Description]   : Enable the buzzer through the GPIO driver.
 *
 * [Args]          : NONE
 *******************************************************************************/
void buzzer_ON(void){
    14e4:	df 93       	push	r29
    14e6:	cf 93       	push	r28
    14e8:	cd b7       	in	r28, 0x3d	; 61
    14ea:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT_ID, BUZZER_PIN_ID, LOGIC_HIGH);
    14ec:	80 e0       	ldi	r24, 0x00	; 0
    14ee:	62 e0       	ldi	r22, 0x02	; 2
    14f0:	41 e0       	ldi	r20, 0x01	; 1
    14f2:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
}
    14f6:	cf 91       	pop	r28
    14f8:	df 91       	pop	r29
    14fa:	08 95       	ret

000014fc <buzzer_OFF>:
 *
 * [Description]   : Disable the buzzer through the GPIO driver.
 *
 * [Args]          : NONE
 *******************************************************************************/
void buzzer_OFF(void){
    14fc:	df 93       	push	r29
    14fe:	cf 93       	push	r28
    1500:	cd b7       	in	r28, 0x3d	; 61
    1502:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT_ID, BUZZER_PIN_ID, LOGIC_LOW);
    1504:	80 e0       	ldi	r24, 0x00	; 0
    1506:	62 e0       	ldi	r22, 0x02	; 2
    1508:	40 e0       	ldi	r20, 0x00	; 0
    150a:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
}
    150e:	cf 91       	pop	r28
    1510:	df 91       	pop	r29
    1512:	08 95       	ret

00001514 <SendToHMI>:
 *
 * [Args in]       : uint8 g_sentData
 * [Args out]      : NONE
 *******************************************************************************/
void SendToHMI(uint8 g_sentData)
{
    1514:	df 93       	push	r29
    1516:	cf 93       	push	r28
    1518:	0f 92       	push	r0
    151a:	cd b7       	in	r28, 0x3d	; 61
    151c:	de b7       	in	r29, 0x3e	; 62
    151e:	89 83       	std	Y+1, r24	; 0x01
	/*NOTE: the same code for sendToControl in the HMI driver */
	UART_sendByte(START_SENDING); /* notation that HMI is ready is ready to send */
    1520:	80 e5       	ldi	r24, 0x50	; 80
    1522:	0e 94 05 18 	call	0x300a	; 0x300a <UART_sendByte>
	while(UART_recieveByte()!= START_RECEIVEING); /*wait until the control ecu is ready to receive*/
    1526:	0e 94 1c 18 	call	0x3038	; 0x3038 <UART_recieveByte>
    152a:	81 35       	cpi	r24, 0x51	; 81
    152c:	e1 f7       	brne	.-8      	; 0x1526 <SendToHMI+0x12>
	UART_sendByte(g_sentData);                     /*data(byte)to send to HMI*/
    152e:	89 81       	ldd	r24, Y+1	; 0x01
    1530:	0e 94 05 18 	call	0x300a	; 0x300a <UART_sendByte>
	while(UART_recieveByte()!= COMPLETE_RECEIVEING); /*wait until the control ecu received the whole data*/
    1534:	0e 94 1c 18 	call	0x3038	; 0x3038 <UART_recieveByte>
    1538:	82 35       	cpi	r24, 0x52	; 82
    153a:	e1 f7       	brne	.-8      	; 0x1534 <SendToHMI+0x20>

}
    153c:	0f 90       	pop	r0
    153e:	cf 91       	pop	r28
    1540:	df 91       	pop	r29
    1542:	08 95       	ret

00001544 <ReceiveFromHMI>:
 *
 * [Args in]       : NONE
 * [Args out]      : uint8 receivedDataFrom_HMI
 *******************************************************************************/
uint8 ReceiveFromHMI(void)
{
    1544:	df 93       	push	r29
    1546:	cf 93       	push	r28
    1548:	cd b7       	in	r28, 0x3d	; 61
    154a:	de b7       	in	r29, 0x3e	; 62
	while(UART_recieveByte()!=START_SENDING); /*wait until the HMI ecu ready to send */
    154c:	0e 94 1c 18 	call	0x3038	; 0x3038 <UART_recieveByte>
    1550:	80 35       	cpi	r24, 0x50	; 80
    1552:	e1 f7       	brne	.-8      	; 0x154c <ReceiveFromHMI+0x8>
	UART_sendByte(START_RECEIVEING); /*CONTROL is sending its notation to start receiving*/
    1554:	81 e5       	ldi	r24, 0x51	; 81
    1556:	0e 94 05 18 	call	0x300a	; 0x300a <UART_sendByte>
	receivedDataFrom_HMI=UART_recieveByte();  /*Receive the data*/
    155a:	0e 94 1c 18 	call	0x3038	; 0x3038 <UART_recieveByte>
    155e:	80 93 b3 00 	sts	0x00B3, r24
	UART_sendByte(COMPLETE_RECEIVEING); /*CONTROL is ensuring that the whole data has been received*/
    1562:	82 e5       	ldi	r24, 0x52	; 82
    1564:	0e 94 05 18 	call	0x300a	; 0x300a <UART_sendByte>
	return receivedDataFrom_HMI;
    1568:	80 91 b3 00 	lds	r24, 0x00B3
}
    156c:	cf 91       	pop	r28
    156e:	df 91       	pop	r29
    1570:	08 95       	ret

00001572 <get_pass_from_HMI>:
 * [Description]   : A function to get password sent by HMI ECU
 *
 * [Args in]       : uint8 *received_pass
 * [Args out]      : NONE
 *******************************************************************************/
void get_pass_from_HMI(uint8 *received_pass){
    1572:	0f 93       	push	r16
    1574:	1f 93       	push	r17
    1576:	df 93       	push	r29
    1578:	cf 93       	push	r28
    157a:	00 d0       	rcall	.+0      	; 0x157c <get_pass_from_HMI+0xa>
    157c:	0f 92       	push	r0
    157e:	cd b7       	in	r28, 0x3d	; 61
    1580:	de b7       	in	r29, 0x3e	; 62
    1582:	9b 83       	std	Y+3, r25	; 0x03
    1584:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i;
	for(i=0;i<5;i++){
    1586:	19 82       	std	Y+1, r1	; 0x01
    1588:	0f c0       	rjmp	.+30     	; 0x15a8 <get_pass_from_HMI+0x36>
		received_pass[i]=UART_recieveByte(); /*receive the 5 char password from HMI*/
    158a:	89 81       	ldd	r24, Y+1	; 0x01
    158c:	28 2f       	mov	r18, r24
    158e:	30 e0       	ldi	r19, 0x00	; 0
    1590:	8a 81       	ldd	r24, Y+2	; 0x02
    1592:	9b 81       	ldd	r25, Y+3	; 0x03
    1594:	8c 01       	movw	r16, r24
    1596:	02 0f       	add	r16, r18
    1598:	13 1f       	adc	r17, r19
    159a:	0e 94 1c 18 	call	0x3038	; 0x3038 <UART_recieveByte>
    159e:	f8 01       	movw	r30, r16
    15a0:	80 83       	st	Z, r24
 * [Args in]       : uint8 *received_pass
 * [Args out]      : NONE
 *******************************************************************************/
void get_pass_from_HMI(uint8 *received_pass){
	uint8 i;
	for(i=0;i<5;i++){
    15a2:	89 81       	ldd	r24, Y+1	; 0x01
    15a4:	8f 5f       	subi	r24, 0xFF	; 255
    15a6:	89 83       	std	Y+1, r24	; 0x01
    15a8:	89 81       	ldd	r24, Y+1	; 0x01
    15aa:	85 30       	cpi	r24, 0x05	; 5
    15ac:	70 f3       	brcs	.-36     	; 0x158a <get_pass_from_HMI+0x18>
		received_pass[i]=UART_recieveByte(); /*receive the 5 char password from HMI*/
	}
}
    15ae:	0f 90       	pop	r0
    15b0:	0f 90       	pop	r0
    15b2:	0f 90       	pop	r0
    15b4:	cf 91       	pop	r28
    15b6:	df 91       	pop	r29
    15b8:	1f 91       	pop	r17
    15ba:	0f 91       	pop	r16
    15bc:	08 95       	ret

000015be <new_pasword>:
 * [Description]   : A function to create new password
 *
 * [Args in]       : NONE
 * [Args out]      : NONE
 *******************************************************************************/
void new_pasword(void){
    15be:	df 93       	push	r29
    15c0:	cf 93       	push	r28
    15c2:	0f 92       	push	r0
    15c4:	cd b7       	in	r28, 0x3d	; 61
    15c6:	de b7       	in	r29, 0x3e	; 62
	matched_flag=0;   /*make the system ready(Reset system) to receive a new password*/
    15c8:	10 92 a2 00 	sts	0x00A2, r1
    15cc:	42 c0       	rjmp	.+132    	; 0x1652 <new_pasword+0x94>

	while(0==matched_flag){      /*never make any progress until password matching*/
		get_pass_from_HMI(first_pass);  /*get first password from HMI*/
    15ce:	88 e8       	ldi	r24, 0x88	; 136
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	0e 94 b9 0a 	call	0x1572	; 0x1572 <get_pass_from_HMI>
		get_pass_from_HMI(second_pass);  /*get second password from HMI*/
    15d6:	85 eb       	ldi	r24, 0xB5	; 181
    15d8:	90 e0       	ldi	r25, 0x00	; 0
    15da:	0e 94 b9 0a 	call	0x1572	; 0x1572 <get_pass_from_HMI>
		matched_flag = compare_pass(first_pass,second_pass);    /*compare between the 2 passwords*/
    15de:	88 e8       	ldi	r24, 0x88	; 136
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	25 eb       	ldi	r18, 0xB5	; 181
    15e4:	30 e0       	ldi	r19, 0x00	; 0
    15e6:	b9 01       	movw	r22, r18
    15e8:	0e 94 76 0c 	call	0x18ec	; 0x18ec <compare_pass>
    15ec:	80 93 a2 00 	sts	0x00A2, r24
		if(1==matched_flag){
    15f0:	80 91 a2 00 	lds	r24, 0x00A2
    15f4:	81 30       	cpi	r24, 0x01	; 1
    15f6:	51 f5       	brne	.+84     	; 0x164c <new_pasword+0x8e>
			SendToHMI(SUCCESS);                 /*if matched, tell HMI that password matches so you can progress*/
    15f8:	81 e0       	ldi	r24, 0x01	; 1
    15fa:	0e 94 8a 0a 	call	0x1514	; 0x1514 <SendToHMI>
			save_to_EEPROM(second_pass);        /*save the matched password to the EEPROM*/
    15fe:	85 eb       	ldi	r24, 0xB5	; 181
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	0e 94 32 0b 	call	0x1664	; 0x1664 <save_to_EEPROM>

			/*the added peripheral for code debugging to reassure that password is saved
			 * successfully in EEPROM or not by displaying it on an LCD*/
			read_from_EEPROM(saved_pass); /*read password from EEPROM and save it in an array*/
    1606:	8e eb       	ldi	r24, 0xBE	; 190
    1608:	90 e0       	ldi	r25, 0x00	; 0
    160a:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <read_from_EEPROM>

			LCD_displayStringRowColumn(0,0,"Pass in EEPROM:");
    160e:	20 e6       	ldi	r18, 0x60	; 96
    1610:	30 e0       	ldi	r19, 0x00	; 0
    1612:	80 e0       	ldi	r24, 0x00	; 0
    1614:	60 e0       	ldi	r22, 0x00	; 0
    1616:	a9 01       	movw	r20, r18
    1618:	0e 94 1b 0a 	call	0x1436	; 0x1436 <LCD_displayStringRowColumn>
			uint8 i;
			for(i=0;i<5;i++){
    161c:	19 82       	std	Y+1, r1	; 0x01
    161e:	12 c0       	rjmp	.+36     	; 0x1644 <new_pasword+0x86>
				LCD_moveCursor(1,i);
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	69 81       	ldd	r22, Y+1	; 0x01
    1624:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <LCD_moveCursor>
				LCD_intgerToString(saved_pass[i]);    /*this function is used as password can't be anything but integers*/
    1628:	89 81       	ldd	r24, Y+1	; 0x01
    162a:	88 2f       	mov	r24, r24
    162c:	90 e0       	ldi	r25, 0x00	; 0
    162e:	fc 01       	movw	r30, r24
    1630:	e2 54       	subi	r30, 0x42	; 66
    1632:	ff 4f       	sbci	r31, 0xFF	; 255
    1634:	80 81       	ld	r24, Z
    1636:	88 2f       	mov	r24, r24
    1638:	90 e0       	ldi	r25, 0x00	; 0
    163a:	0e 94 34 0a 	call	0x1468	; 0x1468 <LCD_intgerToString>
			 * successfully in EEPROM or not by displaying it on an LCD*/
			read_from_EEPROM(saved_pass); /*read password from EEPROM and save it in an array*/

			LCD_displayStringRowColumn(0,0,"Pass in EEPROM:");
			uint8 i;
			for(i=0;i<5;i++){
    163e:	89 81       	ldd	r24, Y+1	; 0x01
    1640:	8f 5f       	subi	r24, 0xFF	; 255
    1642:	89 83       	std	Y+1, r24	; 0x01
    1644:	89 81       	ldd	r24, Y+1	; 0x01
    1646:	85 30       	cpi	r24, 0x05	; 5
    1648:	58 f3       	brcs	.-42     	; 0x1620 <new_pasword+0x62>
    164a:	03 c0       	rjmp	.+6      	; 0x1652 <new_pasword+0x94>
				LCD_moveCursor(1,i);
				LCD_intgerToString(saved_pass[i]);    /*this function is used as password can't be anything but integers*/
			}
		}
		else{
			SendToHMI(FAILURE);       /*if not matched, tell HMI that password mis-matches so try again(you can try again forever)*/
    164c:	80 e0       	ldi	r24, 0x00	; 0
    164e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <SendToHMI>
 * [Args out]      : NONE
 *******************************************************************************/
void new_pasword(void){
	matched_flag=0;   /*make the system ready(Reset system) to receive a new password*/

	while(0==matched_flag){      /*never make any progress until password matching*/
    1652:	80 91 a2 00 	lds	r24, 0x00A2
    1656:	88 23       	and	r24, r24
    1658:	09 f4       	brne	.+2      	; 0x165c <new_pasword+0x9e>
    165a:	b9 cf       	rjmp	.-142    	; 0x15ce <new_pasword+0x10>
		}
		else{
			SendToHMI(FAILURE);       /*if not matched, tell HMI that password mis-matches so try again(you can try again forever)*/
		}
	}
}
    165c:	0f 90       	pop	r0
    165e:	cf 91       	pop	r28
    1660:	df 91       	pop	r29
    1662:	08 95       	ret

00001664 <save_to_EEPROM>:
 * [Description]   : A function to save password sent by HMI in EEPROM
 *
 * [Args in]       : uint8 password_to_be_saved[]
 * [Args out]      : NONE
 *******************************************************************************/
void save_to_EEPROM(uint8 password_to_be_saved[]){
    1664:	df 93       	push	r29
    1666:	cf 93       	push	r28
    1668:	cd b7       	in	r28, 0x3d	; 61
    166a:	de b7       	in	r29, 0x3e	; 62
    166c:	61 97       	sbiw	r28, 0x11	; 17
    166e:	0f b6       	in	r0, 0x3f	; 63
    1670:	f8 94       	cli
    1672:	de bf       	out	0x3e, r29	; 62
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	cd bf       	out	0x3d, r28	; 61
    1678:	99 8b       	std	Y+17, r25	; 0x11
    167a:	88 8b       	std	Y+16, r24	; 0x10
	uint8 i;
	for(i=0;i<5;i++){
    167c:	1f 86       	std	Y+15, r1	; 0x0f
    167e:	88 c0       	rjmp	.+272    	; 0x1790 <save_to_EEPROM+0x12c>
		EEPROM_writeByte(EEPROM_ADDRESS+i,password_to_be_saved[i]);  /*save the password in the passed array in a given address in the EEPROM*/
    1680:	8f 85       	ldd	r24, Y+15	; 0x0f
    1682:	88 2f       	mov	r24, r24
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	8d 5d       	subi	r24, 0xDD	; 221
    1688:	9e 4f       	sbci	r25, 0xFE	; 254
    168a:	ac 01       	movw	r20, r24
    168c:	8f 85       	ldd	r24, Y+15	; 0x0f
    168e:	28 2f       	mov	r18, r24
    1690:	30 e0       	ldi	r19, 0x00	; 0
    1692:	88 89       	ldd	r24, Y+16	; 0x10
    1694:	99 89       	ldd	r25, Y+17	; 0x11
    1696:	fc 01       	movw	r30, r24
    1698:	e2 0f       	add	r30, r18
    169a:	f3 1f       	adc	r31, r19
    169c:	20 81       	ld	r18, Z
    169e:	ca 01       	movw	r24, r20
    16a0:	62 2f       	mov	r22, r18
    16a2:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <EEPROM_writeByte>
    16a6:	80 e0       	ldi	r24, 0x00	; 0
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	a0 e2       	ldi	r26, 0x20	; 32
    16ac:	b1 e4       	ldi	r27, 0x41	; 65
    16ae:	8b 87       	std	Y+11, r24	; 0x0b
    16b0:	9c 87       	std	Y+12, r25	; 0x0c
    16b2:	ad 87       	std	Y+13, r26	; 0x0d
    16b4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    16b6:	6b 85       	ldd	r22, Y+11	; 0x0b
    16b8:	7c 85       	ldd	r23, Y+12	; 0x0c
    16ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    16bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    16be:	20 e0       	ldi	r18, 0x00	; 0
    16c0:	30 e0       	ldi	r19, 0x00	; 0
    16c2:	4a e7       	ldi	r20, 0x7A	; 122
    16c4:	53 e4       	ldi	r21, 0x43	; 67
    16c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16ca:	dc 01       	movw	r26, r24
    16cc:	cb 01       	movw	r24, r22
    16ce:	8f 83       	std	Y+7, r24	; 0x07
    16d0:	98 87       	std	Y+8, r25	; 0x08
    16d2:	a9 87       	std	Y+9, r26	; 0x09
    16d4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    16d6:	6f 81       	ldd	r22, Y+7	; 0x07
    16d8:	78 85       	ldd	r23, Y+8	; 0x08
    16da:	89 85       	ldd	r24, Y+9	; 0x09
    16dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    16de:	20 e0       	ldi	r18, 0x00	; 0
    16e0:	30 e0       	ldi	r19, 0x00	; 0
    16e2:	40 e8       	ldi	r20, 0x80	; 128
    16e4:	5f e3       	ldi	r21, 0x3F	; 63
    16e6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    16ea:	88 23       	and	r24, r24
    16ec:	2c f4       	brge	.+10     	; 0x16f8 <save_to_EEPROM+0x94>
		__ticks = 1;
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	90 e0       	ldi	r25, 0x00	; 0
    16f2:	9e 83       	std	Y+6, r25	; 0x06
    16f4:	8d 83       	std	Y+5, r24	; 0x05
    16f6:	3f c0       	rjmp	.+126    	; 0x1776 <save_to_EEPROM+0x112>
	else if (__tmp > 65535)
    16f8:	6f 81       	ldd	r22, Y+7	; 0x07
    16fa:	78 85       	ldd	r23, Y+8	; 0x08
    16fc:	89 85       	ldd	r24, Y+9	; 0x09
    16fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1700:	20 e0       	ldi	r18, 0x00	; 0
    1702:	3f ef       	ldi	r19, 0xFF	; 255
    1704:	4f e7       	ldi	r20, 0x7F	; 127
    1706:	57 e4       	ldi	r21, 0x47	; 71
    1708:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    170c:	18 16       	cp	r1, r24
    170e:	4c f5       	brge	.+82     	; 0x1762 <save_to_EEPROM+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1710:	6b 85       	ldd	r22, Y+11	; 0x0b
    1712:	7c 85       	ldd	r23, Y+12	; 0x0c
    1714:	8d 85       	ldd	r24, Y+13	; 0x0d
    1716:	9e 85       	ldd	r25, Y+14	; 0x0e
    1718:	20 e0       	ldi	r18, 0x00	; 0
    171a:	30 e0       	ldi	r19, 0x00	; 0
    171c:	40 e2       	ldi	r20, 0x20	; 32
    171e:	51 e4       	ldi	r21, 0x41	; 65
    1720:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1724:	dc 01       	movw	r26, r24
    1726:	cb 01       	movw	r24, r22
    1728:	bc 01       	movw	r22, r24
    172a:	cd 01       	movw	r24, r26
    172c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1730:	dc 01       	movw	r26, r24
    1732:	cb 01       	movw	r24, r22
    1734:	9e 83       	std	Y+6, r25	; 0x06
    1736:	8d 83       	std	Y+5, r24	; 0x05
    1738:	0f c0       	rjmp	.+30     	; 0x1758 <save_to_EEPROM+0xf4>
    173a:	89 e1       	ldi	r24, 0x19	; 25
    173c:	90 e0       	ldi	r25, 0x00	; 0
    173e:	9c 83       	std	Y+4, r25	; 0x04
    1740:	8b 83       	std	Y+3, r24	; 0x03
    1742:	8b 81       	ldd	r24, Y+3	; 0x03
    1744:	9c 81       	ldd	r25, Y+4	; 0x04
    1746:	01 97       	sbiw	r24, 0x01	; 1
    1748:	f1 f7       	brne	.-4      	; 0x1746 <save_to_EEPROM+0xe2>
    174a:	9c 83       	std	Y+4, r25	; 0x04
    174c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    174e:	8d 81       	ldd	r24, Y+5	; 0x05
    1750:	9e 81       	ldd	r25, Y+6	; 0x06
    1752:	01 97       	sbiw	r24, 0x01	; 1
    1754:	9e 83       	std	Y+6, r25	; 0x06
    1756:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1758:	8d 81       	ldd	r24, Y+5	; 0x05
    175a:	9e 81       	ldd	r25, Y+6	; 0x06
    175c:	00 97       	sbiw	r24, 0x00	; 0
    175e:	69 f7       	brne	.-38     	; 0x173a <save_to_EEPROM+0xd6>
    1760:	14 c0       	rjmp	.+40     	; 0x178a <save_to_EEPROM+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1762:	6f 81       	ldd	r22, Y+7	; 0x07
    1764:	78 85       	ldd	r23, Y+8	; 0x08
    1766:	89 85       	ldd	r24, Y+9	; 0x09
    1768:	9a 85       	ldd	r25, Y+10	; 0x0a
    176a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    176e:	dc 01       	movw	r26, r24
    1770:	cb 01       	movw	r24, r22
    1772:	9e 83       	std	Y+6, r25	; 0x06
    1774:	8d 83       	std	Y+5, r24	; 0x05
    1776:	8d 81       	ldd	r24, Y+5	; 0x05
    1778:	9e 81       	ldd	r25, Y+6	; 0x06
    177a:	9a 83       	std	Y+2, r25	; 0x02
    177c:	89 83       	std	Y+1, r24	; 0x01
    177e:	89 81       	ldd	r24, Y+1	; 0x01
    1780:	9a 81       	ldd	r25, Y+2	; 0x02
    1782:	01 97       	sbiw	r24, 0x01	; 1
    1784:	f1 f7       	brne	.-4      	; 0x1782 <save_to_EEPROM+0x11e>
    1786:	9a 83       	std	Y+2, r25	; 0x02
    1788:	89 83       	std	Y+1, r24	; 0x01
 * [Args in]       : uint8 password_to_be_saved[]
 * [Args out]      : NONE
 *******************************************************************************/
void save_to_EEPROM(uint8 password_to_be_saved[]){
	uint8 i;
	for(i=0;i<5;i++){
    178a:	8f 85       	ldd	r24, Y+15	; 0x0f
    178c:	8f 5f       	subi	r24, 0xFF	; 255
    178e:	8f 87       	std	Y+15, r24	; 0x0f
    1790:	8f 85       	ldd	r24, Y+15	; 0x0f
    1792:	85 30       	cpi	r24, 0x05	; 5
    1794:	08 f4       	brcc	.+2      	; 0x1798 <save_to_EEPROM+0x134>
    1796:	74 cf       	rjmp	.-280    	; 0x1680 <save_to_EEPROM+0x1c>
		EEPROM_writeByte(EEPROM_ADDRESS+i,password_to_be_saved[i]);  /*save the password in the passed array in a given address in the EEPROM*/
		_delay_ms(10);                     /*small delay to confirm saving*/
	}
}
    1798:	61 96       	adiw	r28, 0x11	; 17
    179a:	0f b6       	in	r0, 0x3f	; 63
    179c:	f8 94       	cli
    179e:	de bf       	out	0x3e, r29	; 62
    17a0:	0f be       	out	0x3f, r0	; 63
    17a2:	cd bf       	out	0x3d, r28	; 61
    17a4:	cf 91       	pop	r28
    17a6:	df 91       	pop	r29
    17a8:	08 95       	ret

000017aa <read_from_EEPROM>:
 * 					 to save it in a given array
 *
 * [Args in]       : uint8 saved_password[]
 * [Args out]      : NONE
 *******************************************************************************/
void read_from_EEPROM(uint8 saved_password[]){
    17aa:	df 93       	push	r29
    17ac:	cf 93       	push	r28
    17ae:	cd b7       	in	r28, 0x3d	; 61
    17b0:	de b7       	in	r29, 0x3e	; 62
    17b2:	61 97       	sbiw	r28, 0x11	; 17
    17b4:	0f b6       	in	r0, 0x3f	; 63
    17b6:	f8 94       	cli
    17b8:	de bf       	out	0x3e, r29	; 62
    17ba:	0f be       	out	0x3f, r0	; 63
    17bc:	cd bf       	out	0x3d, r28	; 61
    17be:	99 8b       	std	Y+17, r25	; 0x11
    17c0:	88 8b       	std	Y+16, r24	; 0x10
	uint8 i;
	for(i=0;i<5;i++){
    17c2:	1f 86       	std	Y+15, r1	; 0x0f
    17c4:	86 c0       	rjmp	.+268    	; 0x18d2 <read_from_EEPROM+0x128>
		EEPROM_readByte(EEPROM_ADDRESS+i,&saved_password[i]); /*Read the password saved in a given address in the EEPROM in an array (pass thae array address only)*/
    17c6:	8f 85       	ldd	r24, Y+15	; 0x0f
    17c8:	88 2f       	mov	r24, r24
    17ca:	90 e0       	ldi	r25, 0x00	; 0
    17cc:	8d 5d       	subi	r24, 0xDD	; 221
    17ce:	9e 4f       	sbci	r25, 0xFE	; 254
    17d0:	ac 01       	movw	r20, r24
    17d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    17d4:	28 2f       	mov	r18, r24
    17d6:	30 e0       	ldi	r19, 0x00	; 0
    17d8:	88 89       	ldd	r24, Y+16	; 0x10
    17da:	99 89       	ldd	r25, Y+17	; 0x11
    17dc:	28 0f       	add	r18, r24
    17de:	39 1f       	adc	r19, r25
    17e0:	ca 01       	movw	r24, r20
    17e2:	b9 01       	movw	r22, r18
    17e4:	0e 94 23 10 	call	0x2046	; 0x2046 <EEPROM_readByte>
    17e8:	80 e0       	ldi	r24, 0x00	; 0
    17ea:	90 e0       	ldi	r25, 0x00	; 0
    17ec:	a0 e2       	ldi	r26, 0x20	; 32
    17ee:	b1 e4       	ldi	r27, 0x41	; 65
    17f0:	8b 87       	std	Y+11, r24	; 0x0b
    17f2:	9c 87       	std	Y+12, r25	; 0x0c
    17f4:	ad 87       	std	Y+13, r26	; 0x0d
    17f6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17f8:	6b 85       	ldd	r22, Y+11	; 0x0b
    17fa:	7c 85       	ldd	r23, Y+12	; 0x0c
    17fc:	8d 85       	ldd	r24, Y+13	; 0x0d
    17fe:	9e 85       	ldd	r25, Y+14	; 0x0e
    1800:	20 e0       	ldi	r18, 0x00	; 0
    1802:	30 e0       	ldi	r19, 0x00	; 0
    1804:	4a e7       	ldi	r20, 0x7A	; 122
    1806:	53 e4       	ldi	r21, 0x43	; 67
    1808:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    180c:	dc 01       	movw	r26, r24
    180e:	cb 01       	movw	r24, r22
    1810:	8f 83       	std	Y+7, r24	; 0x07
    1812:	98 87       	std	Y+8, r25	; 0x08
    1814:	a9 87       	std	Y+9, r26	; 0x09
    1816:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1818:	6f 81       	ldd	r22, Y+7	; 0x07
    181a:	78 85       	ldd	r23, Y+8	; 0x08
    181c:	89 85       	ldd	r24, Y+9	; 0x09
    181e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1820:	20 e0       	ldi	r18, 0x00	; 0
    1822:	30 e0       	ldi	r19, 0x00	; 0
    1824:	40 e8       	ldi	r20, 0x80	; 128
    1826:	5f e3       	ldi	r21, 0x3F	; 63
    1828:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    182c:	88 23       	and	r24, r24
    182e:	2c f4       	brge	.+10     	; 0x183a <read_from_EEPROM+0x90>
		__ticks = 1;
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	90 e0       	ldi	r25, 0x00	; 0
    1834:	9e 83       	std	Y+6, r25	; 0x06
    1836:	8d 83       	std	Y+5, r24	; 0x05
    1838:	3f c0       	rjmp	.+126    	; 0x18b8 <read_from_EEPROM+0x10e>
	else if (__tmp > 65535)
    183a:	6f 81       	ldd	r22, Y+7	; 0x07
    183c:	78 85       	ldd	r23, Y+8	; 0x08
    183e:	89 85       	ldd	r24, Y+9	; 0x09
    1840:	9a 85       	ldd	r25, Y+10	; 0x0a
    1842:	20 e0       	ldi	r18, 0x00	; 0
    1844:	3f ef       	ldi	r19, 0xFF	; 255
    1846:	4f e7       	ldi	r20, 0x7F	; 127
    1848:	57 e4       	ldi	r21, 0x47	; 71
    184a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    184e:	18 16       	cp	r1, r24
    1850:	4c f5       	brge	.+82     	; 0x18a4 <read_from_EEPROM+0xfa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1852:	6b 85       	ldd	r22, Y+11	; 0x0b
    1854:	7c 85       	ldd	r23, Y+12	; 0x0c
    1856:	8d 85       	ldd	r24, Y+13	; 0x0d
    1858:	9e 85       	ldd	r25, Y+14	; 0x0e
    185a:	20 e0       	ldi	r18, 0x00	; 0
    185c:	30 e0       	ldi	r19, 0x00	; 0
    185e:	40 e2       	ldi	r20, 0x20	; 32
    1860:	51 e4       	ldi	r21, 0x41	; 65
    1862:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1866:	dc 01       	movw	r26, r24
    1868:	cb 01       	movw	r24, r22
    186a:	bc 01       	movw	r22, r24
    186c:	cd 01       	movw	r24, r26
    186e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1872:	dc 01       	movw	r26, r24
    1874:	cb 01       	movw	r24, r22
    1876:	9e 83       	std	Y+6, r25	; 0x06
    1878:	8d 83       	std	Y+5, r24	; 0x05
    187a:	0f c0       	rjmp	.+30     	; 0x189a <read_from_EEPROM+0xf0>
    187c:	89 e1       	ldi	r24, 0x19	; 25
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	9c 83       	std	Y+4, r25	; 0x04
    1882:	8b 83       	std	Y+3, r24	; 0x03
    1884:	8b 81       	ldd	r24, Y+3	; 0x03
    1886:	9c 81       	ldd	r25, Y+4	; 0x04
    1888:	01 97       	sbiw	r24, 0x01	; 1
    188a:	f1 f7       	brne	.-4      	; 0x1888 <read_from_EEPROM+0xde>
    188c:	9c 83       	std	Y+4, r25	; 0x04
    188e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1890:	8d 81       	ldd	r24, Y+5	; 0x05
    1892:	9e 81       	ldd	r25, Y+6	; 0x06
    1894:	01 97       	sbiw	r24, 0x01	; 1
    1896:	9e 83       	std	Y+6, r25	; 0x06
    1898:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    189a:	8d 81       	ldd	r24, Y+5	; 0x05
    189c:	9e 81       	ldd	r25, Y+6	; 0x06
    189e:	00 97       	sbiw	r24, 0x00	; 0
    18a0:	69 f7       	brne	.-38     	; 0x187c <read_from_EEPROM+0xd2>
    18a2:	14 c0       	rjmp	.+40     	; 0x18cc <read_from_EEPROM+0x122>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18a4:	6f 81       	ldd	r22, Y+7	; 0x07
    18a6:	78 85       	ldd	r23, Y+8	; 0x08
    18a8:	89 85       	ldd	r24, Y+9	; 0x09
    18aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    18ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18b0:	dc 01       	movw	r26, r24
    18b2:	cb 01       	movw	r24, r22
    18b4:	9e 83       	std	Y+6, r25	; 0x06
    18b6:	8d 83       	std	Y+5, r24	; 0x05
    18b8:	8d 81       	ldd	r24, Y+5	; 0x05
    18ba:	9e 81       	ldd	r25, Y+6	; 0x06
    18bc:	9a 83       	std	Y+2, r25	; 0x02
    18be:	89 83       	std	Y+1, r24	; 0x01
    18c0:	89 81       	ldd	r24, Y+1	; 0x01
    18c2:	9a 81       	ldd	r25, Y+2	; 0x02
    18c4:	01 97       	sbiw	r24, 0x01	; 1
    18c6:	f1 f7       	brne	.-4      	; 0x18c4 <read_from_EEPROM+0x11a>
    18c8:	9a 83       	std	Y+2, r25	; 0x02
    18ca:	89 83       	std	Y+1, r24	; 0x01
 * [Args in]       : uint8 saved_password[]
 * [Args out]      : NONE
 *******************************************************************************/
void read_from_EEPROM(uint8 saved_password[]){
	uint8 i;
	for(i=0;i<5;i++){
    18cc:	8f 85       	ldd	r24, Y+15	; 0x0f
    18ce:	8f 5f       	subi	r24, 0xFF	; 255
    18d0:	8f 87       	std	Y+15, r24	; 0x0f
    18d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    18d4:	85 30       	cpi	r24, 0x05	; 5
    18d6:	08 f4       	brcc	.+2      	; 0x18da <read_from_EEPROM+0x130>
    18d8:	76 cf       	rjmp	.-276    	; 0x17c6 <read_from_EEPROM+0x1c>
		EEPROM_readByte(EEPROM_ADDRESS+i,&saved_password[i]); /*Read the password saved in a given address in the EEPROM in an array (pass thae array address only)*/
		_delay_ms(10);                     /*small delay to confirm reading*/
	}
}
    18da:	61 96       	adiw	r28, 0x11	; 17
    18dc:	0f b6       	in	r0, 0x3f	; 63
    18de:	f8 94       	cli
    18e0:	de bf       	out	0x3e, r29	; 62
    18e2:	0f be       	out	0x3f, r0	; 63
    18e4:	cd bf       	out	0x3d, r28	; 61
    18e6:	cf 91       	pop	r28
    18e8:	df 91       	pop	r29
    18ea:	08 95       	ret

000018ec <compare_pass>:
 * [Description]   : A function to compare between two given arrays
 *
 * [Args in]       : uint8 *saved_password , uint8 *entered_password
 * [Args out]      : 1 or 0
 *******************************************************************************/
uint8 compare_pass(uint8 *saved_password , uint8 *entered_password){
    18ec:	df 93       	push	r29
    18ee:	cf 93       	push	r28
    18f0:	00 d0       	rcall	.+0      	; 0x18f2 <compare_pass+0x6>
    18f2:	00 d0       	rcall	.+0      	; 0x18f4 <compare_pass+0x8>
    18f4:	00 d0       	rcall	.+0      	; 0x18f6 <compare_pass+0xa>
    18f6:	cd b7       	in	r28, 0x3d	; 61
    18f8:	de b7       	in	r29, 0x3e	; 62
    18fa:	9b 83       	std	Y+3, r25	; 0x03
    18fc:	8a 83       	std	Y+2, r24	; 0x02
    18fe:	7d 83       	std	Y+5, r23	; 0x05
    1900:	6c 83       	std	Y+4, r22	; 0x04
	matched_flag = 0;
    1902:	10 92 a2 00 	sts	0x00A2, r1
	uint8 i=0;
    1906:	19 82       	std	Y+1, r1	; 0x01
	for(i=0;i<5;i++)
    1908:	19 82       	std	Y+1, r1	; 0x01
    190a:	19 c0       	rjmp	.+50     	; 0x193e <compare_pass+0x52>
	{
		if(saved_password[i] == entered_password[i]) /*compare between the 2 arrays char by char, if matches then continue*/
    190c:	89 81       	ldd	r24, Y+1	; 0x01
    190e:	28 2f       	mov	r18, r24
    1910:	30 e0       	ldi	r19, 0x00	; 0
    1912:	8a 81       	ldd	r24, Y+2	; 0x02
    1914:	9b 81       	ldd	r25, Y+3	; 0x03
    1916:	fc 01       	movw	r30, r24
    1918:	e2 0f       	add	r30, r18
    191a:	f3 1f       	adc	r31, r19
    191c:	40 81       	ld	r20, Z
    191e:	89 81       	ldd	r24, Y+1	; 0x01
    1920:	28 2f       	mov	r18, r24
    1922:	30 e0       	ldi	r19, 0x00	; 0
    1924:	8c 81       	ldd	r24, Y+4	; 0x04
    1926:	9d 81       	ldd	r25, Y+5	; 0x05
    1928:	fc 01       	movw	r30, r24
    192a:	e2 0f       	add	r30, r18
    192c:	f3 1f       	adc	r31, r19
    192e:	80 81       	ld	r24, Z
    1930:	48 17       	cp	r20, r24
    1932:	11 f0       	breq	.+4      	; 0x1938 <compare_pass+0x4c>
		{
			continue;
		}
		else
		{
			return 0;                          /*else return 0 that they miss-match*/
    1934:	1e 82       	std	Y+6, r1	; 0x06
    1936:	08 c0       	rjmp	.+16     	; 0x1948 <compare_pass+0x5c>
 * [Args out]      : 1 or 0
 *******************************************************************************/
uint8 compare_pass(uint8 *saved_password , uint8 *entered_password){
	matched_flag = 0;
	uint8 i=0;
	for(i=0;i<5;i++)
    1938:	89 81       	ldd	r24, Y+1	; 0x01
    193a:	8f 5f       	subi	r24, 0xFF	; 255
    193c:	89 83       	std	Y+1, r24	; 0x01
    193e:	89 81       	ldd	r24, Y+1	; 0x01
    1940:	85 30       	cpi	r24, 0x05	; 5
    1942:	20 f3       	brcs	.-56     	; 0x190c <compare_pass+0x20>
		else
		{
			return 0;                          /*else return 0 that they miss-match*/
		}
	}
	return 1;
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	8e 83       	std	Y+6, r24	; 0x06
    1948:	8e 81       	ldd	r24, Y+6	; 0x06
}
    194a:	26 96       	adiw	r28, 0x06	; 6
    194c:	0f b6       	in	r0, 0x3f	; 63
    194e:	f8 94       	cli
    1950:	de bf       	out	0x3e, r29	; 62
    1952:	0f be       	out	0x3f, r0	; 63
    1954:	cd bf       	out	0x3d, r28	; 61
    1956:	cf 91       	pop	r28
    1958:	df 91       	pop	r29
    195a:	08 95       	ret

0000195c <g_tick_Incrementor>:
 *  				 to control time duration
 *
 * [Args in]       : NONE
 * [Args out]      : NONE
 *******************************************************************************/
void g_tick_Incrementor(void){
    195c:	df 93       	push	r29
    195e:	cf 93       	push	r28
    1960:	cd b7       	in	r28, 0x3d	; 61
    1962:	de b7       	in	r29, 0x3e	; 62
	g_tick++;                      /*increment g_tick for time handling*/
    1964:	80 91 ba 00 	lds	r24, 0x00BA
    1968:	90 91 bb 00 	lds	r25, 0x00BB
    196c:	a0 91 bc 00 	lds	r26, 0x00BC
    1970:	b0 91 bd 00 	lds	r27, 0x00BD
    1974:	01 96       	adiw	r24, 0x01	; 1
    1976:	a1 1d       	adc	r26, r1
    1978:	b1 1d       	adc	r27, r1
    197a:	80 93 ba 00 	sts	0x00BA, r24
    197e:	90 93 bb 00 	sts	0x00BB, r25
    1982:	a0 93 bc 00 	sts	0x00BC, r26
    1986:	b0 93 bd 00 	sts	0x00BD, r27
}
    198a:	cf 91       	pop	r28
    198c:	df 91       	pop	r29
    198e:	08 95       	ret

00001990 <set_UP_control_Timer>:
 * [Description]   : A function to configure and initialize the timer
 *
 * [Args in]       : NONE
 * [Args out]      : NONE
 *******************************************************************************/
void set_UP_control_Timer(void){
    1990:	df 93       	push	r29
    1992:	cf 93       	push	r28
    1994:	cd b7       	in	r28, 0x3d	; 61
    1996:	de b7       	in	r29, 0x3e	; 62
    1998:	2c 97       	sbiw	r28, 0x0c	; 12
    199a:	0f b6       	in	r0, 0x3f	; 63
    199c:	f8 94       	cli
    199e:	de bf       	out	0x3e, r29	; 62
    19a0:	0f be       	out	0x3f, r0	; 63
    19a2:	cd bf       	out	0x3d, r28	; 61
	Timer_ConfigType Config_Ptr = {Timer0,compare,0,250,F_CPU_1024};   /*configurations of Timer*/
    19a4:	ce 01       	movw	r24, r28
    19a6:	01 96       	adiw	r24, 0x01	; 1
    19a8:	99 87       	std	Y+9, r25	; 0x09
    19aa:	88 87       	std	Y+8, r24	; 0x08
    19ac:	ed e8       	ldi	r30, 0x8D	; 141
    19ae:	f0 e0       	ldi	r31, 0x00	; 0
    19b0:	fb 87       	std	Y+11, r31	; 0x0b
    19b2:	ea 87       	std	Y+10, r30	; 0x0a
    19b4:	f7 e0       	ldi	r31, 0x07	; 7
    19b6:	fc 87       	std	Y+12, r31	; 0x0c
    19b8:	ea 85       	ldd	r30, Y+10	; 0x0a
    19ba:	fb 85       	ldd	r31, Y+11	; 0x0b
    19bc:	00 80       	ld	r0, Z
    19be:	8a 85       	ldd	r24, Y+10	; 0x0a
    19c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    19c2:	01 96       	adiw	r24, 0x01	; 1
    19c4:	9b 87       	std	Y+11, r25	; 0x0b
    19c6:	8a 87       	std	Y+10, r24	; 0x0a
    19c8:	e8 85       	ldd	r30, Y+8	; 0x08
    19ca:	f9 85       	ldd	r31, Y+9	; 0x09
    19cc:	00 82       	st	Z, r0
    19ce:	88 85       	ldd	r24, Y+8	; 0x08
    19d0:	99 85       	ldd	r25, Y+9	; 0x09
    19d2:	01 96       	adiw	r24, 0x01	; 1
    19d4:	99 87       	std	Y+9, r25	; 0x09
    19d6:	88 87       	std	Y+8, r24	; 0x08
    19d8:	9c 85       	ldd	r25, Y+12	; 0x0c
    19da:	91 50       	subi	r25, 0x01	; 1
    19dc:	9c 87       	std	Y+12, r25	; 0x0c
    19de:	ec 85       	ldd	r30, Y+12	; 0x0c
    19e0:	ee 23       	and	r30, r30
    19e2:	51 f7       	brne	.-44     	; 0x19b8 <set_UP_control_Timer+0x28>
	Timer_Init(&Config_Ptr);            /*initializing Timer*/
    19e4:	ce 01       	movw	r24, r28
    19e6:	01 96       	adiw	r24, 0x01	; 1
    19e8:	0e 94 4e 15 	call	0x2a9c	; 0x2a9c <Timer_Init>
	Timer0_SetCallBack(g_tick_Incrementor);   /*passing the callBack Function to timer to set it*/
    19ec:	8e ea       	ldi	r24, 0xAE	; 174
    19ee:	9c e0       	ldi	r25, 0x0C	; 12
    19f0:	0e 94 a8 16 	call	0x2d50	; 0x2d50 <Timer0_SetCallBack>
}
    19f4:	2c 96       	adiw	r28, 0x0c	; 12
    19f6:	0f b6       	in	r0, 0x3f	; 63
    19f8:	f8 94       	cli
    19fa:	de bf       	out	0x3e, r29	; 62
    19fc:	0f be       	out	0x3f, r0	; 63
    19fe:	cd bf       	out	0x3d, r28	; 61
    1a00:	cf 91       	pop	r28
    1a02:	df 91       	pop	r29
    1a04:	08 95       	ret

00001a06 <DoorMovement>:
 * [Description]   : A function to control door movement after unlocking the door lock
 *
 * [Args in]       : NONE
 * [Args out]      : NONE
 *******************************************************************************/
void DoorMovement(void){
    1a06:	df 93       	push	r29
    1a08:	cf 93       	push	r28
    1a0a:	cd b7       	in	r28, 0x3d	; 61
    1a0c:	de b7       	in	r29, 0x3e	; 62
	/*timer tick = (1/(1000000/1024))*250 = 0.256 */
	set_UP_control_Timer();/*Timer is on to calculate how much time for each door state(movement)*/
    1a0e:	0e 94 c8 0c 	call	0x1990	; 0x1990 <set_UP_control_Timer>
	DcMotor_Rotate(A_CW);
    1a12:	82 e0       	ldi	r24, 0x02	; 2
    1a14:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <DcMotor_Rotate>
	while(g_tick<59);      /*The door will be closing for 15 seconds (15/0.256=59)*/
    1a18:	80 91 ba 00 	lds	r24, 0x00BA
    1a1c:	90 91 bb 00 	lds	r25, 0x00BB
    1a20:	a0 91 bc 00 	lds	r26, 0x00BC
    1a24:	b0 91 bd 00 	lds	r27, 0x00BD
    1a28:	8b 33       	cpi	r24, 0x3B	; 59
    1a2a:	91 05       	cpc	r25, r1
    1a2c:	a1 05       	cpc	r26, r1
    1a2e:	b1 05       	cpc	r27, r1
    1a30:	98 f3       	brcs	.-26     	; 0x1a18 <DoorMovement+0x12>
	g_tick=0;              /*reset to start a new duration*/
    1a32:	10 92 ba 00 	sts	0x00BA, r1
    1a36:	10 92 bb 00 	sts	0x00BB, r1
    1a3a:	10 92 bc 00 	sts	0x00BC, r1
    1a3e:	10 92 bd 00 	sts	0x00BD, r1
	DcMotor_Rotate(stop);
    1a42:	80 e0       	ldi	r24, 0x00	; 0
    1a44:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <DcMotor_Rotate>
	while(g_tick<12); 	   /*The door will be holding for 3 seconds (3/0.256=12)*/
    1a48:	80 91 ba 00 	lds	r24, 0x00BA
    1a4c:	90 91 bb 00 	lds	r25, 0x00BB
    1a50:	a0 91 bc 00 	lds	r26, 0x00BC
    1a54:	b0 91 bd 00 	lds	r27, 0x00BD
    1a58:	8c 30       	cpi	r24, 0x0C	; 12
    1a5a:	91 05       	cpc	r25, r1
    1a5c:	a1 05       	cpc	r26, r1
    1a5e:	b1 05       	cpc	r27, r1
    1a60:	98 f3       	brcs	.-26     	; 0x1a48 <DoorMovement+0x42>
	g_tick=0;         	   /*reset to start a new duration*/
    1a62:	10 92 ba 00 	sts	0x00BA, r1
    1a66:	10 92 bb 00 	sts	0x00BB, r1
    1a6a:	10 92 bc 00 	sts	0x00BC, r1
    1a6e:	10 92 bd 00 	sts	0x00BD, r1
	DcMotor_Rotate(CW);
    1a72:	81 e0       	ldi	r24, 0x01	; 1
    1a74:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <DcMotor_Rotate>
	while(g_tick<59);      /*The door will be closing for 15 seconds (15/0.256=59)*/
    1a78:	80 91 ba 00 	lds	r24, 0x00BA
    1a7c:	90 91 bb 00 	lds	r25, 0x00BB
    1a80:	a0 91 bc 00 	lds	r26, 0x00BC
    1a84:	b0 91 bd 00 	lds	r27, 0x00BD
    1a88:	8b 33       	cpi	r24, 0x3B	; 59
    1a8a:	91 05       	cpc	r25, r1
    1a8c:	a1 05       	cpc	r26, r1
    1a8e:	b1 05       	cpc	r27, r1
    1a90:	98 f3       	brcs	.-26     	; 0x1a78 <DoorMovement+0x72>
	g_tick=0;              /*reset to start a new duration*/
    1a92:	10 92 ba 00 	sts	0x00BA, r1
    1a96:	10 92 bb 00 	sts	0x00BB, r1
    1a9a:	10 92 bc 00 	sts	0x00BC, r1
    1a9e:	10 92 bd 00 	sts	0x00BD, r1
	DcMotor_Rotate(stop);
    1aa2:	80 e0       	ldi	r24, 0x00	; 0
    1aa4:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <DcMotor_Rotate>
	while(g_tick<8);       /*The door will be holding for 2 seconds (2/0.256=8)*/
    1aa8:	80 91 ba 00 	lds	r24, 0x00BA
    1aac:	90 91 bb 00 	lds	r25, 0x00BB
    1ab0:	a0 91 bc 00 	lds	r26, 0x00BC
    1ab4:	b0 91 bd 00 	lds	r27, 0x00BD
    1ab8:	88 30       	cpi	r24, 0x08	; 8
    1aba:	91 05       	cpc	r25, r1
    1abc:	a1 05       	cpc	r26, r1
    1abe:	b1 05       	cpc	r27, r1
    1ac0:	98 f3       	brcs	.-26     	; 0x1aa8 <DoorMovement+0xa2>
	g_tick=0;              /*reset to start a new duration*/
    1ac2:	10 92 ba 00 	sts	0x00BA, r1
    1ac6:	10 92 bb 00 	sts	0x00BB, r1
    1aca:	10 92 bc 00 	sts	0x00BC, r1
    1ace:	10 92 bd 00 	sts	0x00BD, r1

	Timer_DeInit();        /*disable timer*/
    1ad2:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <Timer_DeInit>
}
    1ad6:	cf 91       	pop	r28
    1ad8:	df 91       	pop	r29
    1ada:	08 95       	ret

00001adc <Wrong_Pass>:
 * 					 a warning buzzer when more than 2 wrong entry
 *
 * [Args in]       : NONE
 * [Args out]      : NONE
 *******************************************************************************/
void Wrong_Pass(void){
    1adc:	df 93       	push	r29
    1ade:	cf 93       	push	r28
    1ae0:	cd b7       	in	r28, 0x3d	; 61
    1ae2:	de b7       	in	r29, 0x3e	; 62
    1ae4:	6c 97       	sbiw	r28, 0x1c	; 28
    1ae6:	0f b6       	in	r0, 0x3f	; 63
    1ae8:	f8 94       	cli
    1aea:	de bf       	out	0x3e, r29	; 62
    1aec:	0f be       	out	0x3f, r0	; 63
    1aee:	cd bf       	out	0x3d, r28	; 61
	wrongPass++; /*increment wrongPass value each time the user miss-matches the saved password*/
    1af0:	80 91 b4 00 	lds	r24, 0x00B4
    1af4:	8f 5f       	subi	r24, 0xFF	; 255
    1af6:	80 93 b4 00 	sts	0x00B4, r24

	if(wrongPass==3)  /*when reaching 3 connected wrong entries enable a warning buzzer for 1min*/
    1afa:	80 91 b4 00 	lds	r24, 0x00B4
    1afe:	83 30       	cpi	r24, 0x03	; 3
    1b00:	09 f0       	breq	.+2      	; 0x1b04 <Wrong_Pass+0x28>
    1b02:	15 c1       	rjmp	.+554    	; 0x1d2e <Wrong_Pass+0x252>
	{
		set_UP_control_Timer(); /*Timer is on to calculate how much time to enable the buzzer*/
    1b04:	0e 94 c8 0c 	call	0x1990	; 0x1990 <set_UP_control_Timer>
		buzzer_ON();            /*enable buzzer*/
    1b08:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <buzzer_ON>
    1b0c:	e8 c0       	rjmp	.+464    	; 0x1cde <Wrong_Pass+0x202>
		while(g_tick<235){      /*same as door movement time calculation we calculate here a 1min warning message (60/0.256=235)*/
    1b0e:	80 e0       	ldi	r24, 0x00	; 0
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	a6 e9       	ldi	r26, 0x96	; 150
    1b14:	b3 e4       	ldi	r27, 0x43	; 67
    1b16:	89 8f       	std	Y+25, r24	; 0x19
    1b18:	9a 8f       	std	Y+26, r25	; 0x1a
    1b1a:	ab 8f       	std	Y+27, r26	; 0x1b
    1b1c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b1e:	69 8d       	ldd	r22, Y+25	; 0x19
    1b20:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1b22:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b24:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1b26:	20 e0       	ldi	r18, 0x00	; 0
    1b28:	30 e0       	ldi	r19, 0x00	; 0
    1b2a:	4a e7       	ldi	r20, 0x7A	; 122
    1b2c:	53 e4       	ldi	r21, 0x43	; 67
    1b2e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b32:	dc 01       	movw	r26, r24
    1b34:	cb 01       	movw	r24, r22
    1b36:	8d 8b       	std	Y+21, r24	; 0x15
    1b38:	9e 8b       	std	Y+22, r25	; 0x16
    1b3a:	af 8b       	std	Y+23, r26	; 0x17
    1b3c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1b3e:	6d 89       	ldd	r22, Y+21	; 0x15
    1b40:	7e 89       	ldd	r23, Y+22	; 0x16
    1b42:	8f 89       	ldd	r24, Y+23	; 0x17
    1b44:	98 8d       	ldd	r25, Y+24	; 0x18
    1b46:	20 e0       	ldi	r18, 0x00	; 0
    1b48:	30 e0       	ldi	r19, 0x00	; 0
    1b4a:	40 e8       	ldi	r20, 0x80	; 128
    1b4c:	5f e3       	ldi	r21, 0x3F	; 63
    1b4e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b52:	88 23       	and	r24, r24
    1b54:	2c f4       	brge	.+10     	; 0x1b60 <Wrong_Pass+0x84>
		__ticks = 1;
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	90 e0       	ldi	r25, 0x00	; 0
    1b5a:	9c 8b       	std	Y+20, r25	; 0x14
    1b5c:	8b 8b       	std	Y+19, r24	; 0x13
    1b5e:	3f c0       	rjmp	.+126    	; 0x1bde <Wrong_Pass+0x102>
	else if (__tmp > 65535)
    1b60:	6d 89       	ldd	r22, Y+21	; 0x15
    1b62:	7e 89       	ldd	r23, Y+22	; 0x16
    1b64:	8f 89       	ldd	r24, Y+23	; 0x17
    1b66:	98 8d       	ldd	r25, Y+24	; 0x18
    1b68:	20 e0       	ldi	r18, 0x00	; 0
    1b6a:	3f ef       	ldi	r19, 0xFF	; 255
    1b6c:	4f e7       	ldi	r20, 0x7F	; 127
    1b6e:	57 e4       	ldi	r21, 0x47	; 71
    1b70:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b74:	18 16       	cp	r1, r24
    1b76:	4c f5       	brge	.+82     	; 0x1bca <Wrong_Pass+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b78:	69 8d       	ldd	r22, Y+25	; 0x19
    1b7a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1b7c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b7e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1b80:	20 e0       	ldi	r18, 0x00	; 0
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	40 e2       	ldi	r20, 0x20	; 32
    1b86:	51 e4       	ldi	r21, 0x41	; 65
    1b88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b8c:	dc 01       	movw	r26, r24
    1b8e:	cb 01       	movw	r24, r22
    1b90:	bc 01       	movw	r22, r24
    1b92:	cd 01       	movw	r24, r26
    1b94:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b98:	dc 01       	movw	r26, r24
    1b9a:	cb 01       	movw	r24, r22
    1b9c:	9c 8b       	std	Y+20, r25	; 0x14
    1b9e:	8b 8b       	std	Y+19, r24	; 0x13
    1ba0:	0f c0       	rjmp	.+30     	; 0x1bc0 <Wrong_Pass+0xe4>
    1ba2:	89 e1       	ldi	r24, 0x19	; 25
    1ba4:	90 e0       	ldi	r25, 0x00	; 0
    1ba6:	9a 8b       	std	Y+18, r25	; 0x12
    1ba8:	89 8b       	std	Y+17, r24	; 0x11
    1baa:	89 89       	ldd	r24, Y+17	; 0x11
    1bac:	9a 89       	ldd	r25, Y+18	; 0x12
    1bae:	01 97       	sbiw	r24, 0x01	; 1
    1bb0:	f1 f7       	brne	.-4      	; 0x1bae <Wrong_Pass+0xd2>
    1bb2:	9a 8b       	std	Y+18, r25	; 0x12
    1bb4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1bb6:	8b 89       	ldd	r24, Y+19	; 0x13
    1bb8:	9c 89       	ldd	r25, Y+20	; 0x14
    1bba:	01 97       	sbiw	r24, 0x01	; 1
    1bbc:	9c 8b       	std	Y+20, r25	; 0x14
    1bbe:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1bc0:	8b 89       	ldd	r24, Y+19	; 0x13
    1bc2:	9c 89       	ldd	r25, Y+20	; 0x14
    1bc4:	00 97       	sbiw	r24, 0x00	; 0
    1bc6:	69 f7       	brne	.-38     	; 0x1ba2 <Wrong_Pass+0xc6>
    1bc8:	14 c0       	rjmp	.+40     	; 0x1bf2 <Wrong_Pass+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1bca:	6d 89       	ldd	r22, Y+21	; 0x15
    1bcc:	7e 89       	ldd	r23, Y+22	; 0x16
    1bce:	8f 89       	ldd	r24, Y+23	; 0x17
    1bd0:	98 8d       	ldd	r25, Y+24	; 0x18
    1bd2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bd6:	dc 01       	movw	r26, r24
    1bd8:	cb 01       	movw	r24, r22
    1bda:	9c 8b       	std	Y+20, r25	; 0x14
    1bdc:	8b 8b       	std	Y+19, r24	; 0x13
    1bde:	8b 89       	ldd	r24, Y+19	; 0x13
    1be0:	9c 89       	ldd	r25, Y+20	; 0x14
    1be2:	98 8b       	std	Y+16, r25	; 0x10
    1be4:	8f 87       	std	Y+15, r24	; 0x0f
    1be6:	8f 85       	ldd	r24, Y+15	; 0x0f
    1be8:	98 89       	ldd	r25, Y+16	; 0x10
    1bea:	01 97       	sbiw	r24, 0x01	; 1
    1bec:	f1 f7       	brne	.-4      	; 0x1bea <Wrong_Pass+0x10e>
    1bee:	98 8b       	std	Y+16, r25	; 0x10
    1bf0:	8f 87       	std	Y+15, r24	; 0x0f
			_delay_ms(300);
			buzzer_OFF();       /*disable buzzer*/
    1bf2:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <buzzer_OFF>
    1bf6:	80 e0       	ldi	r24, 0x00	; 0
    1bf8:	90 e0       	ldi	r25, 0x00	; 0
    1bfa:	a8 e4       	ldi	r26, 0x48	; 72
    1bfc:	b3 e4       	ldi	r27, 0x43	; 67
    1bfe:	8b 87       	std	Y+11, r24	; 0x0b
    1c00:	9c 87       	std	Y+12, r25	; 0x0c
    1c02:	ad 87       	std	Y+13, r26	; 0x0d
    1c04:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c06:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c08:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c0a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c0c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c0e:	20 e0       	ldi	r18, 0x00	; 0
    1c10:	30 e0       	ldi	r19, 0x00	; 0
    1c12:	4a e7       	ldi	r20, 0x7A	; 122
    1c14:	53 e4       	ldi	r21, 0x43	; 67
    1c16:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c1a:	dc 01       	movw	r26, r24
    1c1c:	cb 01       	movw	r24, r22
    1c1e:	8f 83       	std	Y+7, r24	; 0x07
    1c20:	98 87       	std	Y+8, r25	; 0x08
    1c22:	a9 87       	std	Y+9, r26	; 0x09
    1c24:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1c26:	6f 81       	ldd	r22, Y+7	; 0x07
    1c28:	78 85       	ldd	r23, Y+8	; 0x08
    1c2a:	89 85       	ldd	r24, Y+9	; 0x09
    1c2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c2e:	20 e0       	ldi	r18, 0x00	; 0
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	40 e8       	ldi	r20, 0x80	; 128
    1c34:	5f e3       	ldi	r21, 0x3F	; 63
    1c36:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c3a:	88 23       	and	r24, r24
    1c3c:	2c f4       	brge	.+10     	; 0x1c48 <Wrong_Pass+0x16c>
		__ticks = 1;
    1c3e:	81 e0       	ldi	r24, 0x01	; 1
    1c40:	90 e0       	ldi	r25, 0x00	; 0
    1c42:	9e 83       	std	Y+6, r25	; 0x06
    1c44:	8d 83       	std	Y+5, r24	; 0x05
    1c46:	3f c0       	rjmp	.+126    	; 0x1cc6 <Wrong_Pass+0x1ea>
	else if (__tmp > 65535)
    1c48:	6f 81       	ldd	r22, Y+7	; 0x07
    1c4a:	78 85       	ldd	r23, Y+8	; 0x08
    1c4c:	89 85       	ldd	r24, Y+9	; 0x09
    1c4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c50:	20 e0       	ldi	r18, 0x00	; 0
    1c52:	3f ef       	ldi	r19, 0xFF	; 255
    1c54:	4f e7       	ldi	r20, 0x7F	; 127
    1c56:	57 e4       	ldi	r21, 0x47	; 71
    1c58:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1c5c:	18 16       	cp	r1, r24
    1c5e:	4c f5       	brge	.+82     	; 0x1cb2 <Wrong_Pass+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c60:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c62:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c64:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c66:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c68:	20 e0       	ldi	r18, 0x00	; 0
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	40 e2       	ldi	r20, 0x20	; 32
    1c6e:	51 e4       	ldi	r21, 0x41	; 65
    1c70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c74:	dc 01       	movw	r26, r24
    1c76:	cb 01       	movw	r24, r22
    1c78:	bc 01       	movw	r22, r24
    1c7a:	cd 01       	movw	r24, r26
    1c7c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c80:	dc 01       	movw	r26, r24
    1c82:	cb 01       	movw	r24, r22
    1c84:	9e 83       	std	Y+6, r25	; 0x06
    1c86:	8d 83       	std	Y+5, r24	; 0x05
    1c88:	0f c0       	rjmp	.+30     	; 0x1ca8 <Wrong_Pass+0x1cc>
    1c8a:	89 e1       	ldi	r24, 0x19	; 25
    1c8c:	90 e0       	ldi	r25, 0x00	; 0
    1c8e:	9c 83       	std	Y+4, r25	; 0x04
    1c90:	8b 83       	std	Y+3, r24	; 0x03
    1c92:	8b 81       	ldd	r24, Y+3	; 0x03
    1c94:	9c 81       	ldd	r25, Y+4	; 0x04
    1c96:	01 97       	sbiw	r24, 0x01	; 1
    1c98:	f1 f7       	brne	.-4      	; 0x1c96 <Wrong_Pass+0x1ba>
    1c9a:	9c 83       	std	Y+4, r25	; 0x04
    1c9c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c9e:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ca2:	01 97       	sbiw	r24, 0x01	; 1
    1ca4:	9e 83       	std	Y+6, r25	; 0x06
    1ca6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ca8:	8d 81       	ldd	r24, Y+5	; 0x05
    1caa:	9e 81       	ldd	r25, Y+6	; 0x06
    1cac:	00 97       	sbiw	r24, 0x00	; 0
    1cae:	69 f7       	brne	.-38     	; 0x1c8a <Wrong_Pass+0x1ae>
    1cb0:	14 c0       	rjmp	.+40     	; 0x1cda <Wrong_Pass+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1cb2:	6f 81       	ldd	r22, Y+7	; 0x07
    1cb4:	78 85       	ldd	r23, Y+8	; 0x08
    1cb6:	89 85       	ldd	r24, Y+9	; 0x09
    1cb8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cbe:	dc 01       	movw	r26, r24
    1cc0:	cb 01       	movw	r24, r22
    1cc2:	9e 83       	std	Y+6, r25	; 0x06
    1cc4:	8d 83       	std	Y+5, r24	; 0x05
    1cc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1cc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cca:	9a 83       	std	Y+2, r25	; 0x02
    1ccc:	89 83       	std	Y+1, r24	; 0x01
    1cce:	89 81       	ldd	r24, Y+1	; 0x01
    1cd0:	9a 81       	ldd	r25, Y+2	; 0x02
    1cd2:	01 97       	sbiw	r24, 0x01	; 1
    1cd4:	f1 f7       	brne	.-4      	; 0x1cd2 <Wrong_Pass+0x1f6>
    1cd6:	9a 83       	std	Y+2, r25	; 0x02
    1cd8:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(200);
			buzzer_ON();        /*enable buzzer*/
    1cda:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <buzzer_ON>

	if(wrongPass==3)  /*when reaching 3 connected wrong entries enable a warning buzzer for 1min*/
	{
		set_UP_control_Timer(); /*Timer is on to calculate how much time to enable the buzzer*/
		buzzer_ON();            /*enable buzzer*/
		while(g_tick<235){      /*same as door movement time calculation we calculate here a 1min warning message (60/0.256=235)*/
    1cde:	80 91 ba 00 	lds	r24, 0x00BA
    1ce2:	90 91 bb 00 	lds	r25, 0x00BB
    1ce6:	a0 91 bc 00 	lds	r26, 0x00BC
    1cea:	b0 91 bd 00 	lds	r27, 0x00BD
    1cee:	8b 3e       	cpi	r24, 0xEB	; 235
    1cf0:	91 05       	cpc	r25, r1
    1cf2:	a1 05       	cpc	r26, r1
    1cf4:	b1 05       	cpc	r27, r1
    1cf6:	08 f4       	brcc	.+2      	; 0x1cfa <Wrong_Pass+0x21e>
    1cf8:	0a cf       	rjmp	.-492    	; 0x1b0e <Wrong_Pass+0x32>
			_delay_ms(300);
			buzzer_OFF();       /*disable buzzer*/
			_delay_ms(200);
			buzzer_ON();        /*enable buzzer*/
		}
		buzzer_OFF();           /*disable buzzer*/
    1cfa:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <buzzer_OFF>
		g_tick=0;               /*reset to start a new duration*/
    1cfe:	10 92 ba 00 	sts	0x00BA, r1
    1d02:	10 92 bb 00 	sts	0x00BB, r1
    1d06:	10 92 bc 00 	sts	0x00BC, r1
    1d0a:	10 92 bd 00 	sts	0x00BD, r1
		wrongPass=0;            /*reset the wrong password counter*/
    1d0e:	10 92 b4 00 	sts	0x00B4, r1
		backToMain=1;
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	a0 e0       	ldi	r26, 0x00	; 0
    1d18:	b0 e0       	ldi	r27, 0x00	; 0
    1d1a:	80 93 a3 00 	sts	0x00A3, r24
    1d1e:	90 93 a4 00 	sts	0x00A4, r25
    1d22:	a0 93 a5 00 	sts	0x00A5, r26
    1d26:	b0 93 a6 00 	sts	0x00A6, r27

		Timer_DeInit();         /*disable timer*/
    1d2a:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <Timer_DeInit>
	}
}
    1d2e:	6c 96       	adiw	r28, 0x1c	; 28
    1d30:	0f b6       	in	r0, 0x3f	; 63
    1d32:	f8 94       	cli
    1d34:	de bf       	out	0x3e, r29	; 62
    1d36:	0f be       	out	0x3f, r0	; 63
    1d38:	cd bf       	out	0x3d, r28	; 61
    1d3a:	cf 91       	pop	r28
    1d3c:	df 91       	pop	r29
    1d3e:	08 95       	ret

00001d40 <Main_Options>:
 *					 whether it was opening door or changing password
 *
 * [Args in]       : NONE
 * [Args out]      : NONE
 *******************************************************************************/
void Main_Options(void){
    1d40:	df 93       	push	r29
    1d42:	cf 93       	push	r28
    1d44:	00 d0       	rcall	.+0      	; 0x1d46 <Main_Options+0x6>
    1d46:	0f 92       	push	r0
    1d48:	cd b7       	in	r28, 0x3d	; 61
    1d4a:	de b7       	in	r29, 0x3e	; 62

	uint8 received_option;                /*a variable to hold the chosen option sent from HMI*/
	received_option = ReceiveFromHMI();   /*receive option from HMI ECU*/
    1d4c:	0e 94 a2 0a 	call	0x1544	; 0x1544 <ReceiveFromHMI>
    1d50:	89 83       	std	Y+1, r24	; 0x01
	matched_flag=0;
    1d52:	10 92 a2 00 	sts	0x00A2, r1

	switch(received_option){
    1d56:	89 81       	ldd	r24, Y+1	; 0x01
    1d58:	28 2f       	mov	r18, r24
    1d5a:	30 e0       	ldi	r19, 0x00	; 0
    1d5c:	3b 83       	std	Y+3, r19	; 0x03
    1d5e:	2a 83       	std	Y+2, r18	; 0x02
    1d60:	8a 81       	ldd	r24, Y+2	; 0x02
    1d62:	9b 81       	ldd	r25, Y+3	; 0x03
    1d64:	8b 32       	cpi	r24, 0x2B	; 43
    1d66:	91 05       	cpc	r25, r1
    1d68:	09 f4       	brne	.+2      	; 0x1d6c <Main_Options+0x2c>
    1d6a:	3e c0       	rjmp	.+124    	; 0x1de8 <Main_Options+0xa8>
    1d6c:	2a 81       	ldd	r18, Y+2	; 0x02
    1d6e:	3b 81       	ldd	r19, Y+3	; 0x03
    1d70:	2d 32       	cpi	r18, 0x2D	; 45
    1d72:	31 05       	cpc	r19, r1
    1d74:	09 f4       	brne	.+2      	; 0x1d78 <Main_Options+0x38>
    1d76:	74 c0       	rjmp	.+232    	; 0x1e60 <Main_Options+0x120>
    1d78:	77 c0       	rjmp	.+238    	; 0x1e68 <Main_Options+0x128>
	case openDoor:                               /*if HMI chose '+' (open door) */
		while(0==matched_flag){                  /*not to back to main until taking the 3 password entry chances*/
			read_from_EEPROM(saved_pass);        /*get the password saved in EEPROM*/
    1d7a:	8e eb       	ldi	r24, 0xBE	; 190
    1d7c:	90 e0       	ldi	r25, 0x00	; 0
    1d7e:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <read_from_EEPROM>
			get_pass_from_HMI(received_pass);    /*get the password from HMI*/
    1d82:	8e ea       	ldi	r24, 0xAE	; 174
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	0e 94 b9 0a 	call	0x1572	; 0x1572 <get_pass_from_HMI>
			matched_flag = compare_pass(saved_pass,received_pass); /*check for matching*/
    1d8a:	8e eb       	ldi	r24, 0xBE	; 190
    1d8c:	90 e0       	ldi	r25, 0x00	; 0
    1d8e:	2e ea       	ldi	r18, 0xAE	; 174
    1d90:	30 e0       	ldi	r19, 0x00	; 0
    1d92:	b9 01       	movw	r22, r18
    1d94:	0e 94 76 0c 	call	0x18ec	; 0x18ec <compare_pass>
    1d98:	80 93 a2 00 	sts	0x00A2, r24
			if(0==matched_flag){                 /*if mis-match send failure to HMI and increment wrongPass value*/
    1d9c:	80 91 a2 00 	lds	r24, 0x00A2
    1da0:	88 23       	and	r24, r24
    1da2:	d9 f4       	brne	.+54     	; 0x1dda <Main_Options+0x9a>
				SendToHMI(FAILURE);
    1da4:	80 e0       	ldi	r24, 0x00	; 0
    1da6:	0e 94 8a 0a 	call	0x1514	; 0x1514 <SendToHMI>
				Wrong_Pass();
    1daa:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <Wrong_Pass>
				if(backToMain==1){               /*if taken the 3 password entry chances*/
    1dae:	80 91 a3 00 	lds	r24, 0x00A3
    1db2:	90 91 a4 00 	lds	r25, 0x00A4
    1db6:	a0 91 a5 00 	lds	r26, 0x00A5
    1dba:	b0 91 a6 00 	lds	r27, 0x00A6
    1dbe:	81 30       	cpi	r24, 0x01	; 1
    1dc0:	91 05       	cpc	r25, r1
    1dc2:	a1 05       	cpc	r26, r1
    1dc4:	b1 05       	cpc	r27, r1
    1dc6:	81 f4       	brne	.+32     	; 0x1de8 <Main_Options+0xa8>
					backToMain=0;                /*reset back to main value*/
    1dc8:	10 92 a3 00 	sts	0x00A3, r1
    1dcc:	10 92 a4 00 	sts	0x00A4, r1
    1dd0:	10 92 a5 00 	sts	0x00A5, r1
    1dd4:	10 92 a6 00 	sts	0x00A6, r1
    1dd8:	47 c0       	rjmp	.+142    	; 0x1e68 <Main_Options+0x128>
					break;                       /*break to get back to main after the warning buzzer*/
				}
			}
			else{                                /*if matching send success to HMI, start door movement and reset wrongPass value*/
				SendToHMI(SUCCESS);
    1dda:	81 e0       	ldi	r24, 0x01	; 1
    1ddc:	0e 94 8a 0a 	call	0x1514	; 0x1514 <SendToHMI>
				wrongPass=0;
    1de0:	10 92 b4 00 	sts	0x00B4, r1
				DoorMovement();
    1de4:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <DoorMovement>
	received_option = ReceiveFromHMI();   /*receive option from HMI ECU*/
	matched_flag=0;

	switch(received_option){
	case openDoor:                               /*if HMI chose '+' (open door) */
		while(0==matched_flag){                  /*not to back to main until taking the 3 password entry chances*/
    1de8:	80 91 a2 00 	lds	r24, 0x00A2
    1dec:	88 23       	and	r24, r24
    1dee:	29 f2       	breq	.-118    	; 0x1d7a <Main_Options+0x3a>
    1df0:	3b c0       	rjmp	.+118    	; 0x1e68 <Main_Options+0x128>
		}
		break;

	case changePass:                             /*if HMI chose '-' (change password) */
		while(0==matched_flag){                  /*not to back to main until taking the 3 password entry chances*/
			read_from_EEPROM(saved_pass);        /*get the password saved in EEPROM*/
    1df2:	8e eb       	ldi	r24, 0xBE	; 190
    1df4:	90 e0       	ldi	r25, 0x00	; 0
    1df6:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <read_from_EEPROM>
			get_pass_from_HMI(received_pass);    /*get the password from HMI*/
    1dfa:	8e ea       	ldi	r24, 0xAE	; 174
    1dfc:	90 e0       	ldi	r25, 0x00	; 0
    1dfe:	0e 94 b9 0a 	call	0x1572	; 0x1572 <get_pass_from_HMI>
			matched_flag = compare_pass(saved_pass,received_pass);
    1e02:	8e eb       	ldi	r24, 0xBE	; 190
    1e04:	90 e0       	ldi	r25, 0x00	; 0
    1e06:	2e ea       	ldi	r18, 0xAE	; 174
    1e08:	30 e0       	ldi	r19, 0x00	; 0
    1e0a:	b9 01       	movw	r22, r18
    1e0c:	0e 94 76 0c 	call	0x18ec	; 0x18ec <compare_pass>
    1e10:	80 93 a2 00 	sts	0x00A2, r24
			if(0==matched_flag){                 /*if mis-match send failure to HMI and increment wrongPass value*/
    1e14:	80 91 a2 00 	lds	r24, 0x00A2
    1e18:	88 23       	and	r24, r24
    1e1a:	d9 f4       	brne	.+54     	; 0x1e52 <Main_Options+0x112>
				SendToHMI(FAILURE);
    1e1c:	80 e0       	ldi	r24, 0x00	; 0
    1e1e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <SendToHMI>
				Wrong_Pass();
    1e22:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <Wrong_Pass>
				if(backToMain==1){               /*if taken the 3 password entry chances*/
    1e26:	80 91 a3 00 	lds	r24, 0x00A3
    1e2a:	90 91 a4 00 	lds	r25, 0x00A4
    1e2e:	a0 91 a5 00 	lds	r26, 0x00A5
    1e32:	b0 91 a6 00 	lds	r27, 0x00A6
    1e36:	81 30       	cpi	r24, 0x01	; 1
    1e38:	91 05       	cpc	r25, r1
    1e3a:	a1 05       	cpc	r26, r1
    1e3c:	b1 05       	cpc	r27, r1
    1e3e:	81 f4       	brne	.+32     	; 0x1e60 <Main_Options+0x120>
					backToMain=0;                /*reset back to main value*/
    1e40:	10 92 a3 00 	sts	0x00A3, r1
    1e44:	10 92 a4 00 	sts	0x00A4, r1
    1e48:	10 92 a5 00 	sts	0x00A5, r1
    1e4c:	10 92 a6 00 	sts	0x00A6, r1
    1e50:	0b c0       	rjmp	.+22     	; 0x1e68 <Main_Options+0x128>
					break;                       /*break to get back to main after the warning buzzer*/
				}

			}
			else{                                /*if matching send success to HMI, set up a new password and reset wrongPass value*/
				SendToHMI(SUCCESS);
    1e52:	81 e0       	ldi	r24, 0x01	; 1
    1e54:	0e 94 8a 0a 	call	0x1514	; 0x1514 <SendToHMI>
				wrongPass=0;
    1e58:	10 92 b4 00 	sts	0x00B4, r1
				new_pasword();
    1e5c:	0e 94 df 0a 	call	0x15be	; 0x15be <new_pasword>
			}
		}
		break;

	case changePass:                             /*if HMI chose '-' (change password) */
		while(0==matched_flag){                  /*not to back to main until taking the 3 password entry chances*/
    1e60:	80 91 a2 00 	lds	r24, 0x00A2
    1e64:	88 23       	and	r24, r24
    1e66:	29 f2       	breq	.-118    	; 0x1df2 <Main_Options+0xb2>
			}
		}
		break;

	}
}
    1e68:	0f 90       	pop	r0
    1e6a:	0f 90       	pop	r0
    1e6c:	0f 90       	pop	r0
    1e6e:	cf 91       	pop	r28
    1e70:	df 91       	pop	r29
    1e72:	08 95       	ret

00001e74 <main>:
uint8 saved_pass[5];     /*Array to save the password in EEPROM in it*/
uint8 first_time_flag=0; /*A flag to see if it's the first time to use this system or not*/


int main (void)
{
    1e74:	df 93       	push	r29
    1e76:	cf 93       	push	r28
    1e78:	cd b7       	in	r28, 0x3d	; 61
    1e7a:	de b7       	in	r29, 0x3e	; 62
    1e7c:	68 97       	sbiw	r28, 0x18	; 24
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	de bf       	out	0x3e, r29	; 62
    1e84:	0f be       	out	0x3f, r0	; 63
    1e86:	cd bf       	out	0x3d, r28	; 61
*                           Peripherals Initialization                         *
*******************************************************************************/
	/*I've used LCD here for debugging to see if password is saved in the external EEPROM
	 * or not and to display what is saved in it
	 */
	LCD_init();          /*initializing LCD to use its function*/
    1e88:	0e 94 a3 05 	call	0xb46	; 0xb46 <LCD_init>

	TWI_ConfigType config_Ptr = {NO_PRESCALER,Normal_Mode,MY_SLAVE}; /*configurations of I2C*/
    1e8c:	ce 01       	movw	r24, r28
    1e8e:	02 96       	adiw	r24, 0x02	; 2
    1e90:	98 8b       	std	Y+16, r25	; 0x10
    1e92:	8f 87       	std	Y+15, r24	; 0x0f
    1e94:	eb e9       	ldi	r30, 0x9B	; 155
    1e96:	f0 e0       	ldi	r31, 0x00	; 0
    1e98:	fa 8b       	std	Y+18, r31	; 0x12
    1e9a:	e9 8b       	std	Y+17, r30	; 0x11
    1e9c:	f6 e0       	ldi	r31, 0x06	; 6
    1e9e:	fb 8b       	std	Y+19, r31	; 0x13
    1ea0:	e9 89       	ldd	r30, Y+17	; 0x11
    1ea2:	fa 89       	ldd	r31, Y+18	; 0x12
    1ea4:	00 80       	ld	r0, Z
    1ea6:	89 89       	ldd	r24, Y+17	; 0x11
    1ea8:	9a 89       	ldd	r25, Y+18	; 0x12
    1eaa:	01 96       	adiw	r24, 0x01	; 1
    1eac:	9a 8b       	std	Y+18, r25	; 0x12
    1eae:	89 8b       	std	Y+17, r24	; 0x11
    1eb0:	ef 85       	ldd	r30, Y+15	; 0x0f
    1eb2:	f8 89       	ldd	r31, Y+16	; 0x10
    1eb4:	00 82       	st	Z, r0
    1eb6:	8f 85       	ldd	r24, Y+15	; 0x0f
    1eb8:	98 89       	ldd	r25, Y+16	; 0x10
    1eba:	01 96       	adiw	r24, 0x01	; 1
    1ebc:	98 8b       	std	Y+16, r25	; 0x10
    1ebe:	8f 87       	std	Y+15, r24	; 0x0f
    1ec0:	9b 89       	ldd	r25, Y+19	; 0x13
    1ec2:	91 50       	subi	r25, 0x01	; 1
    1ec4:	9b 8b       	std	Y+19, r25	; 0x13
    1ec6:	eb 89       	ldd	r30, Y+19	; 0x13
    1ec8:	ee 23       	and	r30, r30
    1eca:	51 f7       	brne	.-44     	; 0x1ea0 <main+0x2c>
	TWI_init(&config_Ptr);    /*initializing I2C*/
    1ecc:	ce 01       	movw	r24, r28
    1ece:	02 96       	adiw	r24, 0x02	; 2
    1ed0:	0e 94 de 16 	call	0x2dbc	; 0x2dbc <TWI_init>
	UART_ConfigType ConfigPtr = {Paraity_Disabled,One_Stop_bit,eight_bit,9600}; /*configurations of UART*/
    1ed4:	ce 01       	movw	r24, r28
    1ed6:	08 96       	adiw	r24, 0x08	; 8
    1ed8:	9d 8b       	std	Y+21, r25	; 0x15
    1eda:	8c 8b       	std	Y+20, r24	; 0x14
    1edc:	e4 e9       	ldi	r30, 0x94	; 148
    1ede:	f0 e0       	ldi	r31, 0x00	; 0
    1ee0:	ff 8b       	std	Y+23, r31	; 0x17
    1ee2:	ee 8b       	std	Y+22, r30	; 0x16
    1ee4:	f7 e0       	ldi	r31, 0x07	; 7
    1ee6:	f8 8f       	std	Y+24, r31	; 0x18
    1ee8:	ee 89       	ldd	r30, Y+22	; 0x16
    1eea:	ff 89       	ldd	r31, Y+23	; 0x17
    1eec:	00 80       	ld	r0, Z
    1eee:	8e 89       	ldd	r24, Y+22	; 0x16
    1ef0:	9f 89       	ldd	r25, Y+23	; 0x17
    1ef2:	01 96       	adiw	r24, 0x01	; 1
    1ef4:	9f 8b       	std	Y+23, r25	; 0x17
    1ef6:	8e 8b       	std	Y+22, r24	; 0x16
    1ef8:	ec 89       	ldd	r30, Y+20	; 0x14
    1efa:	fd 89       	ldd	r31, Y+21	; 0x15
    1efc:	00 82       	st	Z, r0
    1efe:	8c 89       	ldd	r24, Y+20	; 0x14
    1f00:	9d 89       	ldd	r25, Y+21	; 0x15
    1f02:	01 96       	adiw	r24, 0x01	; 1
    1f04:	9d 8b       	std	Y+21, r25	; 0x15
    1f06:	8c 8b       	std	Y+20, r24	; 0x14
    1f08:	98 8d       	ldd	r25, Y+24	; 0x18
    1f0a:	91 50       	subi	r25, 0x01	; 1
    1f0c:	98 8f       	std	Y+24, r25	; 0x18
    1f0e:	e8 8d       	ldd	r30, Y+24	; 0x18
    1f10:	ee 23       	and	r30, r30
    1f12:	51 f7       	brne	.-44     	; 0x1ee8 <main+0x74>
	UART_init(&ConfigPtr);     /*initializing UART*/
    1f14:	ce 01       	movw	r24, r28
    1f16:	08 96       	adiw	r24, 0x08	; 8
    1f18:	0e 94 84 17 	call	0x2f08	; 0x2f08 <UART_init>
	DcMotor_Init();            /*initializing DC_Motor*/
    1f1c:	0e 94 c1 13 	call	0x2782	; 0x2782 <DcMotor_Init>
	buzzer_Init();
    1f20:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <buzzer_Init>
	SREG|=(1<<7);              /*Enabling Global interrupt*/
    1f24:	af e5       	ldi	r26, 0x5F	; 95
    1f26:	b0 e0       	ldi	r27, 0x00	; 0
    1f28:	ef e5       	ldi	r30, 0x5F	; 95
    1f2a:	f0 e0       	ldi	r31, 0x00	; 0
    1f2c:	80 81       	ld	r24, Z
    1f2e:	80 68       	ori	r24, 0x80	; 128
    1f30:	8c 93       	st	X, r24
	forgot the password you can cheat and see it in the LCD on the down right
	for now I've reset it and the next one to use the same proteus would be asked to enter a new password.
	 */
	//save_to_EEPROM(first_pass);

	read_from_EEPROM(saved_pass);         /*get the password saved in EEPROM*/
    1f32:	8e eb       	ldi	r24, 0xBE	; 190
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <read_from_EEPROM>

	LCD_displayStringRowColumn(0,0,"Pass in EEPROM:");
    1f3a:	20 e7       	ldi	r18, 0x70	; 112
    1f3c:	30 e0       	ldi	r19, 0x00	; 0
    1f3e:	80 e0       	ldi	r24, 0x00	; 0
    1f40:	60 e0       	ldi	r22, 0x00	; 0
    1f42:	a9 01       	movw	r20, r18
    1f44:	0e 94 1b 0a 	call	0x1436	; 0x1436 <LCD_displayStringRowColumn>

	uint8 i;
	for(i=0;i<5;i++){
    1f48:	19 82       	std	Y+1, r1	; 0x01
    1f4a:	20 c0       	rjmp	.+64     	; 0x1f8c <main+0x118>
		LCD_moveCursor(1,i);
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	69 81       	ldd	r22, Y+1	; 0x01
    1f50:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <LCD_moveCursor>
		if(saved_pass[0]=='%')
    1f54:	80 91 be 00 	lds	r24, 0x00BE
    1f58:	85 32       	cpi	r24, 0x25	; 37
    1f5a:	51 f4       	brne	.+20     	; 0x1f70 <main+0xfc>
			LCD_displayCharacter(saved_pass[i]);           /*display this password on the control LCD*/
    1f5c:	89 81       	ldd	r24, Y+1	; 0x01
    1f5e:	88 2f       	mov	r24, r24
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	fc 01       	movw	r30, r24
    1f64:	e2 54       	subi	r30, 0x42	; 66
    1f66:	ff 4f       	sbci	r31, 0xFF	; 255
    1f68:	80 81       	ld	r24, Z
    1f6a:	0e 94 bb 07 	call	0xf76	; 0xf76 <LCD_displayCharacter>
    1f6e:	0b c0       	rjmp	.+22     	; 0x1f86 <main+0x112>
		else
			LCD_intgerToString(saved_pass[i]);             /*display this password on the control LCD*/
    1f70:	89 81       	ldd	r24, Y+1	; 0x01
    1f72:	88 2f       	mov	r24, r24
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	fc 01       	movw	r30, r24
    1f78:	e2 54       	subi	r30, 0x42	; 66
    1f7a:	ff 4f       	sbci	r31, 0xFF	; 255
    1f7c:	80 81       	ld	r24, Z
    1f7e:	88 2f       	mov	r24, r24
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	0e 94 34 0a 	call	0x1468	; 0x1468 <LCD_intgerToString>
	read_from_EEPROM(saved_pass);         /*get the password saved in EEPROM*/

	LCD_displayStringRowColumn(0,0,"Pass in EEPROM:");

	uint8 i;
	for(i=0;i<5;i++){
    1f86:	89 81       	ldd	r24, Y+1	; 0x01
    1f88:	8f 5f       	subi	r24, 0xFF	; 255
    1f8a:	89 83       	std	Y+1, r24	; 0x01
    1f8c:	89 81       	ldd	r24, Y+1	; 0x01
    1f8e:	85 30       	cpi	r24, 0x05	; 5
    1f90:	e8 f2       	brcs	.-70     	; 0x1f4c <main+0xd8>
			LCD_displayCharacter(saved_pass[i]);           /*display this password on the control LCD*/
		else
			LCD_intgerToString(saved_pass[i]);             /*display this password on the control LCD*/
	}

	first_time_flag=compare_pass(first_pass,saved_pass);  /*compare between the known first password and the one saved in EEPROM*/
    1f92:	88 e8       	ldi	r24, 0x88	; 136
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	2e eb       	ldi	r18, 0xBE	; 190
    1f98:	30 e0       	ldi	r19, 0x00	; 0
    1f9a:	b9 01       	movw	r22, r18
    1f9c:	0e 94 76 0c 	call	0x18ec	; 0x18ec <compare_pass>
    1fa0:	80 93 a7 00 	sts	0x00A7, r24

	if(1==first_time_flag){
    1fa4:	80 91 a7 00 	lds	r24, 0x00A7
    1fa8:	81 30       	cpi	r24, 0x01	; 1
    1faa:	31 f4       	brne	.+12     	; 0x1fb8 <main+0x144>
		SendToHMI(SUCCESS);           /*if the password never change set up a new password*/
    1fac:	81 e0       	ldi	r24, 0x01	; 1
    1fae:	0e 94 8a 0a 	call	0x1514	; 0x1514 <SendToHMI>
		new_pasword();
    1fb2:	0e 94 df 0a 	call	0x15be	; 0x15be <new_pasword>
    1fb6:	03 c0       	rjmp	.+6      	; 0x1fbe <main+0x14a>
	}
	else{                             /*else go to main options*/
		SendToHMI(FAILURE);
    1fb8:	80 e0       	ldi	r24, 0x00	; 0
    1fba:	0e 94 8a 0a 	call	0x1514	; 0x1514 <SendToHMI>
/*******************************************************************************
*                           All time running(App.) code                        *
*******************************************************************************/
	while(1)
	{
		Main_Options();             /*wait for user action(option selection)*/
    1fbe:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <Main_Options>
    1fc2:	fd cf       	rjmp	.-6      	; 0x1fbe <main+0x14a>

00001fc4 <EEPROM_writeByte>:
 *******************************************************************************/
#include "external_eeprom.h"
#include "twi.h"

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
    1fc4:	df 93       	push	r29
    1fc6:	cf 93       	push	r28
    1fc8:	00 d0       	rcall	.+0      	; 0x1fca <EEPROM_writeByte+0x6>
    1fca:	00 d0       	rcall	.+0      	; 0x1fcc <EEPROM_writeByte+0x8>
    1fcc:	cd b7       	in	r28, 0x3d	; 61
    1fce:	de b7       	in	r29, 0x3e	; 62
    1fd0:	9a 83       	std	Y+2, r25	; 0x02
    1fd2:	89 83       	std	Y+1, r24	; 0x01
    1fd4:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
    1fd6:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <TWI_start>
    if (TWI_getStatus() != TWI_START)
    1fda:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    1fde:	88 30       	cpi	r24, 0x08	; 8
    1fe0:	11 f0       	breq	.+4      	; 0x1fe6 <EEPROM_writeByte+0x22>
        return ERROR;
    1fe2:	1c 82       	std	Y+4, r1	; 0x04
    1fe4:	28 c0       	rjmp	.+80     	; 0x2036 <EEPROM_writeByte+0x72>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)(0xA0 | ((u16addr & 0x0700)>>7)));
    1fe6:	89 81       	ldd	r24, Y+1	; 0x01
    1fe8:	9a 81       	ldd	r25, Y+2	; 0x02
    1fea:	80 70       	andi	r24, 0x00	; 0
    1fec:	97 70       	andi	r25, 0x07	; 7
    1fee:	88 0f       	add	r24, r24
    1ff0:	89 2f       	mov	r24, r25
    1ff2:	88 1f       	adc	r24, r24
    1ff4:	99 0b       	sbc	r25, r25
    1ff6:	91 95       	neg	r25
    1ff8:	80 6a       	ori	r24, 0xA0	; 160
    1ffa:	0e 94 38 17 	call	0x2e70	; 0x2e70 <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    1ffe:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    2002:	88 31       	cpi	r24, 0x18	; 24
    2004:	11 f0       	breq	.+4      	; 0x200a <EEPROM_writeByte+0x46>
        return ERROR; 
    2006:	1c 82       	std	Y+4, r1	; 0x04
    2008:	16 c0       	rjmp	.+44     	; 0x2036 <EEPROM_writeByte+0x72>
		 
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
    200a:	89 81       	ldd	r24, Y+1	; 0x01
    200c:	0e 94 38 17 	call	0x2e70	; 0x2e70 <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    2010:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    2014:	88 32       	cpi	r24, 0x28	; 40
    2016:	11 f0       	breq	.+4      	; 0x201c <EEPROM_writeByte+0x58>
        return ERROR;
    2018:	1c 82       	std	Y+4, r1	; 0x04
    201a:	0d c0       	rjmp	.+26     	; 0x2036 <EEPROM_writeByte+0x72>
		
    /* write byte to eeprom */
    TWI_writeByte(u8data);
    201c:	8b 81       	ldd	r24, Y+3	; 0x03
    201e:	0e 94 38 17 	call	0x2e70	; 0x2e70 <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    2022:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    2026:	88 32       	cpi	r24, 0x28	; 40
    2028:	11 f0       	breq	.+4      	; 0x202e <EEPROM_writeByte+0x6a>
        return ERROR;
    202a:	1c 82       	std	Y+4, r1	; 0x04
    202c:	04 c0       	rjmp	.+8      	; 0x2036 <EEPROM_writeByte+0x72>

    /* Send the Stop Bit */
    TWI_stop();
    202e:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <TWI_stop>
	
    return SUCCESS;
    2032:	81 e0       	ldi	r24, 0x01	; 1
    2034:	8c 83       	std	Y+4, r24	; 0x04
    2036:	8c 81       	ldd	r24, Y+4	; 0x04
}
    2038:	0f 90       	pop	r0
    203a:	0f 90       	pop	r0
    203c:	0f 90       	pop	r0
    203e:	0f 90       	pop	r0
    2040:	cf 91       	pop	r28
    2042:	df 91       	pop	r29
    2044:	08 95       	ret

00002046 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
    2046:	df 93       	push	r29
    2048:	cf 93       	push	r28
    204a:	00 d0       	rcall	.+0      	; 0x204c <EEPROM_readByte+0x6>
    204c:	00 d0       	rcall	.+0      	; 0x204e <EEPROM_readByte+0x8>
    204e:	0f 92       	push	r0
    2050:	cd b7       	in	r28, 0x3d	; 61
    2052:	de b7       	in	r29, 0x3e	; 62
    2054:	9a 83       	std	Y+2, r25	; 0x02
    2056:	89 83       	std	Y+1, r24	; 0x01
    2058:	7c 83       	std	Y+4, r23	; 0x04
    205a:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
    205c:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <TWI_start>
    if (TWI_getStatus() != TWI_START)
    2060:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    2064:	88 30       	cpi	r24, 0x08	; 8
    2066:	11 f0       	breq	.+4      	; 0x206c <EEPROM_readByte+0x26>
        return ERROR;
    2068:	1d 82       	std	Y+5, r1	; 0x05
    206a:	44 c0       	rjmp	.+136    	; 0x20f4 <EEPROM_readByte+0xae>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7)));
    206c:	89 81       	ldd	r24, Y+1	; 0x01
    206e:	9a 81       	ldd	r25, Y+2	; 0x02
    2070:	80 70       	andi	r24, 0x00	; 0
    2072:	97 70       	andi	r25, 0x07	; 7
    2074:	88 0f       	add	r24, r24
    2076:	89 2f       	mov	r24, r25
    2078:	88 1f       	adc	r24, r24
    207a:	99 0b       	sbc	r25, r25
    207c:	91 95       	neg	r25
    207e:	80 6a       	ori	r24, 0xA0	; 160
    2080:	0e 94 38 17 	call	0x2e70	; 0x2e70 <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    2084:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    2088:	88 31       	cpi	r24, 0x18	; 24
    208a:	11 f0       	breq	.+4      	; 0x2090 <EEPROM_readByte+0x4a>
        return ERROR;
    208c:	1d 82       	std	Y+5, r1	; 0x05
    208e:	32 c0       	rjmp	.+100    	; 0x20f4 <EEPROM_readByte+0xae>
		
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
    2090:	89 81       	ldd	r24, Y+1	; 0x01
    2092:	0e 94 38 17 	call	0x2e70	; 0x2e70 <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    2096:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    209a:	88 32       	cpi	r24, 0x28	; 40
    209c:	11 f0       	breq	.+4      	; 0x20a2 <EEPROM_readByte+0x5c>
        return ERROR;
    209e:	1d 82       	std	Y+5, r1	; 0x05
    20a0:	29 c0       	rjmp	.+82     	; 0x20f4 <EEPROM_readByte+0xae>
		
    /* Send the Repeated Start Bit */
    TWI_start();
    20a2:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <TWI_start>
    if (TWI_getStatus() != TWI_REP_START)
    20a6:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    20aa:	80 31       	cpi	r24, 0x10	; 16
    20ac:	11 f0       	breq	.+4      	; 0x20b2 <EEPROM_readByte+0x6c>
        return ERROR;
    20ae:	1d 82       	std	Y+5, r1	; 0x05
    20b0:	21 c0       	rjmp	.+66     	; 0x20f4 <EEPROM_readByte+0xae>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=1 (Read) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7) | 1));
    20b2:	89 81       	ldd	r24, Y+1	; 0x01
    20b4:	9a 81       	ldd	r25, Y+2	; 0x02
    20b6:	80 70       	andi	r24, 0x00	; 0
    20b8:	97 70       	andi	r25, 0x07	; 7
    20ba:	88 0f       	add	r24, r24
    20bc:	89 2f       	mov	r24, r25
    20be:	88 1f       	adc	r24, r24
    20c0:	99 0b       	sbc	r25, r25
    20c2:	91 95       	neg	r25
    20c4:	81 6a       	ori	r24, 0xA1	; 161
    20c6:	0e 94 38 17 	call	0x2e70	; 0x2e70 <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_R_ACK)
    20ca:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    20ce:	80 34       	cpi	r24, 0x40	; 64
    20d0:	11 f0       	breq	.+4      	; 0x20d6 <EEPROM_readByte+0x90>
        return ERROR;
    20d2:	1d 82       	std	Y+5, r1	; 0x05
    20d4:	0f c0       	rjmp	.+30     	; 0x20f4 <EEPROM_readByte+0xae>

    /* Read Byte from Memory without send ACK */
    *u8data = TWI_readByteWithNACK();
    20d6:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <TWI_readByteWithNACK>
    20da:	eb 81       	ldd	r30, Y+3	; 0x03
    20dc:	fc 81       	ldd	r31, Y+4	; 0x04
    20de:	80 83       	st	Z, r24
    if (TWI_getStatus() != TWI_MR_DATA_NACK)
    20e0:	0e 94 75 17 	call	0x2eea	; 0x2eea <TWI_getStatus>
    20e4:	88 35       	cpi	r24, 0x58	; 88
    20e6:	11 f0       	breq	.+4      	; 0x20ec <EEPROM_readByte+0xa6>
        return ERROR;
    20e8:	1d 82       	std	Y+5, r1	; 0x05
    20ea:	04 c0       	rjmp	.+8      	; 0x20f4 <EEPROM_readByte+0xae>

    /* Send the Stop Bit */
    TWI_stop();
    20ec:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <TWI_stop>

    return SUCCESS;
    20f0:	81 e0       	ldi	r24, 0x01	; 1
    20f2:	8d 83       	std	Y+5, r24	; 0x05
    20f4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    20f6:	0f 90       	pop	r0
    20f8:	0f 90       	pop	r0
    20fa:	0f 90       	pop	r0
    20fc:	0f 90       	pop	r0
    20fe:	0f 90       	pop	r0
    2100:	cf 91       	pop	r28
    2102:	df 91       	pop	r29
    2104:	08 95       	ret

00002106 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    2106:	df 93       	push	r29
    2108:	cf 93       	push	r28
    210a:	00 d0       	rcall	.+0      	; 0x210c <GPIO_setupPinDirection+0x6>
    210c:	00 d0       	rcall	.+0      	; 0x210e <GPIO_setupPinDirection+0x8>
    210e:	0f 92       	push	r0
    2110:	cd b7       	in	r28, 0x3d	; 61
    2112:	de b7       	in	r29, 0x3e	; 62
    2114:	89 83       	std	Y+1, r24	; 0x01
    2116:	6a 83       	std	Y+2, r22	; 0x02
    2118:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    211a:	8a 81       	ldd	r24, Y+2	; 0x02
    211c:	88 30       	cpi	r24, 0x08	; 8
    211e:	08 f0       	brcs	.+2      	; 0x2122 <GPIO_setupPinDirection+0x1c>
    2120:	d5 c0       	rjmp	.+426    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
    2122:	89 81       	ldd	r24, Y+1	; 0x01
    2124:	84 30       	cpi	r24, 0x04	; 4
    2126:	08 f0       	brcs	.+2      	; 0x212a <GPIO_setupPinDirection+0x24>
    2128:	d1 c0       	rjmp	.+418    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    212a:	89 81       	ldd	r24, Y+1	; 0x01
    212c:	28 2f       	mov	r18, r24
    212e:	30 e0       	ldi	r19, 0x00	; 0
    2130:	3d 83       	std	Y+5, r19	; 0x05
    2132:	2c 83       	std	Y+4, r18	; 0x04
    2134:	8c 81       	ldd	r24, Y+4	; 0x04
    2136:	9d 81       	ldd	r25, Y+5	; 0x05
    2138:	81 30       	cpi	r24, 0x01	; 1
    213a:	91 05       	cpc	r25, r1
    213c:	09 f4       	brne	.+2      	; 0x2140 <GPIO_setupPinDirection+0x3a>
    213e:	43 c0       	rjmp	.+134    	; 0x21c6 <GPIO_setupPinDirection+0xc0>
    2140:	2c 81       	ldd	r18, Y+4	; 0x04
    2142:	3d 81       	ldd	r19, Y+5	; 0x05
    2144:	22 30       	cpi	r18, 0x02	; 2
    2146:	31 05       	cpc	r19, r1
    2148:	2c f4       	brge	.+10     	; 0x2154 <GPIO_setupPinDirection+0x4e>
    214a:	8c 81       	ldd	r24, Y+4	; 0x04
    214c:	9d 81       	ldd	r25, Y+5	; 0x05
    214e:	00 97       	sbiw	r24, 0x00	; 0
    2150:	71 f0       	breq	.+28     	; 0x216e <GPIO_setupPinDirection+0x68>
    2152:	bc c0       	rjmp	.+376    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
    2154:	2c 81       	ldd	r18, Y+4	; 0x04
    2156:	3d 81       	ldd	r19, Y+5	; 0x05
    2158:	22 30       	cpi	r18, 0x02	; 2
    215a:	31 05       	cpc	r19, r1
    215c:	09 f4       	brne	.+2      	; 0x2160 <GPIO_setupPinDirection+0x5a>
    215e:	5f c0       	rjmp	.+190    	; 0x221e <GPIO_setupPinDirection+0x118>
    2160:	8c 81       	ldd	r24, Y+4	; 0x04
    2162:	9d 81       	ldd	r25, Y+5	; 0x05
    2164:	83 30       	cpi	r24, 0x03	; 3
    2166:	91 05       	cpc	r25, r1
    2168:	09 f4       	brne	.+2      	; 0x216c <GPIO_setupPinDirection+0x66>
    216a:	85 c0       	rjmp	.+266    	; 0x2276 <GPIO_setupPinDirection+0x170>
    216c:	af c0       	rjmp	.+350    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    216e:	8b 81       	ldd	r24, Y+3	; 0x03
    2170:	81 30       	cpi	r24, 0x01	; 1
    2172:	a1 f4       	brne	.+40     	; 0x219c <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
    2174:	aa e3       	ldi	r26, 0x3A	; 58
    2176:	b0 e0       	ldi	r27, 0x00	; 0
    2178:	ea e3       	ldi	r30, 0x3A	; 58
    217a:	f0 e0       	ldi	r31, 0x00	; 0
    217c:	80 81       	ld	r24, Z
    217e:	48 2f       	mov	r20, r24
    2180:	8a 81       	ldd	r24, Y+2	; 0x02
    2182:	28 2f       	mov	r18, r24
    2184:	30 e0       	ldi	r19, 0x00	; 0
    2186:	81 e0       	ldi	r24, 0x01	; 1
    2188:	90 e0       	ldi	r25, 0x00	; 0
    218a:	02 2e       	mov	r0, r18
    218c:	02 c0       	rjmp	.+4      	; 0x2192 <GPIO_setupPinDirection+0x8c>
    218e:	88 0f       	add	r24, r24
    2190:	99 1f       	adc	r25, r25
    2192:	0a 94       	dec	r0
    2194:	e2 f7       	brpl	.-8      	; 0x218e <GPIO_setupPinDirection+0x88>
    2196:	84 2b       	or	r24, r20
    2198:	8c 93       	st	X, r24
    219a:	98 c0       	rjmp	.+304    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    219c:	aa e3       	ldi	r26, 0x3A	; 58
    219e:	b0 e0       	ldi	r27, 0x00	; 0
    21a0:	ea e3       	ldi	r30, 0x3A	; 58
    21a2:	f0 e0       	ldi	r31, 0x00	; 0
    21a4:	80 81       	ld	r24, Z
    21a6:	48 2f       	mov	r20, r24
    21a8:	8a 81       	ldd	r24, Y+2	; 0x02
    21aa:	28 2f       	mov	r18, r24
    21ac:	30 e0       	ldi	r19, 0x00	; 0
    21ae:	81 e0       	ldi	r24, 0x01	; 1
    21b0:	90 e0       	ldi	r25, 0x00	; 0
    21b2:	02 2e       	mov	r0, r18
    21b4:	02 c0       	rjmp	.+4      	; 0x21ba <GPIO_setupPinDirection+0xb4>
    21b6:	88 0f       	add	r24, r24
    21b8:	99 1f       	adc	r25, r25
    21ba:	0a 94       	dec	r0
    21bc:	e2 f7       	brpl	.-8      	; 0x21b6 <GPIO_setupPinDirection+0xb0>
    21be:	80 95       	com	r24
    21c0:	84 23       	and	r24, r20
    21c2:	8c 93       	st	X, r24
    21c4:	83 c0       	rjmp	.+262    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    21c6:	8b 81       	ldd	r24, Y+3	; 0x03
    21c8:	81 30       	cpi	r24, 0x01	; 1
    21ca:	a1 f4       	brne	.+40     	; 0x21f4 <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
    21cc:	a7 e3       	ldi	r26, 0x37	; 55
    21ce:	b0 e0       	ldi	r27, 0x00	; 0
    21d0:	e7 e3       	ldi	r30, 0x37	; 55
    21d2:	f0 e0       	ldi	r31, 0x00	; 0
    21d4:	80 81       	ld	r24, Z
    21d6:	48 2f       	mov	r20, r24
    21d8:	8a 81       	ldd	r24, Y+2	; 0x02
    21da:	28 2f       	mov	r18, r24
    21dc:	30 e0       	ldi	r19, 0x00	; 0
    21de:	81 e0       	ldi	r24, 0x01	; 1
    21e0:	90 e0       	ldi	r25, 0x00	; 0
    21e2:	02 2e       	mov	r0, r18
    21e4:	02 c0       	rjmp	.+4      	; 0x21ea <GPIO_setupPinDirection+0xe4>
    21e6:	88 0f       	add	r24, r24
    21e8:	99 1f       	adc	r25, r25
    21ea:	0a 94       	dec	r0
    21ec:	e2 f7       	brpl	.-8      	; 0x21e6 <GPIO_setupPinDirection+0xe0>
    21ee:	84 2b       	or	r24, r20
    21f0:	8c 93       	st	X, r24
    21f2:	6c c0       	rjmp	.+216    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    21f4:	a7 e3       	ldi	r26, 0x37	; 55
    21f6:	b0 e0       	ldi	r27, 0x00	; 0
    21f8:	e7 e3       	ldi	r30, 0x37	; 55
    21fa:	f0 e0       	ldi	r31, 0x00	; 0
    21fc:	80 81       	ld	r24, Z
    21fe:	48 2f       	mov	r20, r24
    2200:	8a 81       	ldd	r24, Y+2	; 0x02
    2202:	28 2f       	mov	r18, r24
    2204:	30 e0       	ldi	r19, 0x00	; 0
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	90 e0       	ldi	r25, 0x00	; 0
    220a:	02 2e       	mov	r0, r18
    220c:	02 c0       	rjmp	.+4      	; 0x2212 <GPIO_setupPinDirection+0x10c>
    220e:	88 0f       	add	r24, r24
    2210:	99 1f       	adc	r25, r25
    2212:	0a 94       	dec	r0
    2214:	e2 f7       	brpl	.-8      	; 0x220e <GPIO_setupPinDirection+0x108>
    2216:	80 95       	com	r24
    2218:	84 23       	and	r24, r20
    221a:	8c 93       	st	X, r24
    221c:	57 c0       	rjmp	.+174    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    221e:	8b 81       	ldd	r24, Y+3	; 0x03
    2220:	81 30       	cpi	r24, 0x01	; 1
    2222:	a1 f4       	brne	.+40     	; 0x224c <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
    2224:	a4 e3       	ldi	r26, 0x34	; 52
    2226:	b0 e0       	ldi	r27, 0x00	; 0
    2228:	e4 e3       	ldi	r30, 0x34	; 52
    222a:	f0 e0       	ldi	r31, 0x00	; 0
    222c:	80 81       	ld	r24, Z
    222e:	48 2f       	mov	r20, r24
    2230:	8a 81       	ldd	r24, Y+2	; 0x02
    2232:	28 2f       	mov	r18, r24
    2234:	30 e0       	ldi	r19, 0x00	; 0
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	02 2e       	mov	r0, r18
    223c:	02 c0       	rjmp	.+4      	; 0x2242 <GPIO_setupPinDirection+0x13c>
    223e:	88 0f       	add	r24, r24
    2240:	99 1f       	adc	r25, r25
    2242:	0a 94       	dec	r0
    2244:	e2 f7       	brpl	.-8      	; 0x223e <GPIO_setupPinDirection+0x138>
    2246:	84 2b       	or	r24, r20
    2248:	8c 93       	st	X, r24
    224a:	40 c0       	rjmp	.+128    	; 0x22cc <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    224c:	a4 e3       	ldi	r26, 0x34	; 52
    224e:	b0 e0       	ldi	r27, 0x00	; 0
    2250:	e4 e3       	ldi	r30, 0x34	; 52
    2252:	f0 e0       	ldi	r31, 0x00	; 0
    2254:	80 81       	ld	r24, Z
    2256:	48 2f       	mov	r20, r24
    2258:	8a 81       	ldd	r24, Y+2	; 0x02
    225a:	28 2f       	mov	r18, r24
    225c:	30 e0       	ldi	r19, 0x00	; 0
    225e:	81 e0       	ldi	r24, 0x01	; 1
    2260:	90 e0       	ldi	r25, 0x00	; 0
    2262:	02 2e       	mov	r0, r18
    2264:	02 c0       	rjmp	.+4      	; 0x226a <GPIO_setupPinDirection+0x164>
    2266:	88 0f       	add	r24, r24
    2268:	99 1f       	adc	r25, r25
    226a:	0a 94       	dec	r0
    226c:	e2 f7       	brpl	.-8      	; 0x2266 <GPIO_setupPinDirection+0x160>
    226e:	80 95       	com	r24
    2270:	84 23       	and	r24, r20
    2272:	8c 93       	st	X, r24
    2274:	2b c0       	rjmp	.+86     	; 0x22cc <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    2276:	8b 81       	ldd	r24, Y+3	; 0x03
    2278:	81 30       	cpi	r24, 0x01	; 1
    227a:	a1 f4       	brne	.+40     	; 0x22a4 <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
    227c:	a1 e3       	ldi	r26, 0x31	; 49
    227e:	b0 e0       	ldi	r27, 0x00	; 0
    2280:	e1 e3       	ldi	r30, 0x31	; 49
    2282:	f0 e0       	ldi	r31, 0x00	; 0
    2284:	80 81       	ld	r24, Z
    2286:	48 2f       	mov	r20, r24
    2288:	8a 81       	ldd	r24, Y+2	; 0x02
    228a:	28 2f       	mov	r18, r24
    228c:	30 e0       	ldi	r19, 0x00	; 0
    228e:	81 e0       	ldi	r24, 0x01	; 1
    2290:	90 e0       	ldi	r25, 0x00	; 0
    2292:	02 2e       	mov	r0, r18
    2294:	02 c0       	rjmp	.+4      	; 0x229a <GPIO_setupPinDirection+0x194>
    2296:	88 0f       	add	r24, r24
    2298:	99 1f       	adc	r25, r25
    229a:	0a 94       	dec	r0
    229c:	e2 f7       	brpl	.-8      	; 0x2296 <GPIO_setupPinDirection+0x190>
    229e:	84 2b       	or	r24, r20
    22a0:	8c 93       	st	X, r24
    22a2:	14 c0       	rjmp	.+40     	; 0x22cc <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    22a4:	a1 e3       	ldi	r26, 0x31	; 49
    22a6:	b0 e0       	ldi	r27, 0x00	; 0
    22a8:	e1 e3       	ldi	r30, 0x31	; 49
    22aa:	f0 e0       	ldi	r31, 0x00	; 0
    22ac:	80 81       	ld	r24, Z
    22ae:	48 2f       	mov	r20, r24
    22b0:	8a 81       	ldd	r24, Y+2	; 0x02
    22b2:	28 2f       	mov	r18, r24
    22b4:	30 e0       	ldi	r19, 0x00	; 0
    22b6:	81 e0       	ldi	r24, 0x01	; 1
    22b8:	90 e0       	ldi	r25, 0x00	; 0
    22ba:	02 2e       	mov	r0, r18
    22bc:	02 c0       	rjmp	.+4      	; 0x22c2 <GPIO_setupPinDirection+0x1bc>
    22be:	88 0f       	add	r24, r24
    22c0:	99 1f       	adc	r25, r25
    22c2:	0a 94       	dec	r0
    22c4:	e2 f7       	brpl	.-8      	; 0x22be <GPIO_setupPinDirection+0x1b8>
    22c6:	80 95       	com	r24
    22c8:	84 23       	and	r24, r20
    22ca:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    22cc:	0f 90       	pop	r0
    22ce:	0f 90       	pop	r0
    22d0:	0f 90       	pop	r0
    22d2:	0f 90       	pop	r0
    22d4:	0f 90       	pop	r0
    22d6:	cf 91       	pop	r28
    22d8:	df 91       	pop	r29
    22da:	08 95       	ret

000022dc <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    22dc:	df 93       	push	r29
    22de:	cf 93       	push	r28
    22e0:	00 d0       	rcall	.+0      	; 0x22e2 <GPIO_writePin+0x6>
    22e2:	00 d0       	rcall	.+0      	; 0x22e4 <GPIO_writePin+0x8>
    22e4:	0f 92       	push	r0
    22e6:	cd b7       	in	r28, 0x3d	; 61
    22e8:	de b7       	in	r29, 0x3e	; 62
    22ea:	89 83       	std	Y+1, r24	; 0x01
    22ec:	6a 83       	std	Y+2, r22	; 0x02
    22ee:	4b 83       	std	Y+3, r20	; 0x03
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    22f0:	8a 81       	ldd	r24, Y+2	; 0x02
    22f2:	88 30       	cpi	r24, 0x08	; 8
    22f4:	08 f0       	brcs	.+2      	; 0x22f8 <GPIO_writePin+0x1c>
    22f6:	d5 c0       	rjmp	.+426    	; 0x24a2 <GPIO_writePin+0x1c6>
    22f8:	89 81       	ldd	r24, Y+1	; 0x01
    22fa:	84 30       	cpi	r24, 0x04	; 4
    22fc:	08 f0       	brcs	.+2      	; 0x2300 <GPIO_writePin+0x24>
    22fe:	d1 c0       	rjmp	.+418    	; 0x24a2 <GPIO_writePin+0x1c6>
	{
		/* Do Nothing */
	}
	else
	{
		switch(port_num)
    2300:	89 81       	ldd	r24, Y+1	; 0x01
    2302:	28 2f       	mov	r18, r24
    2304:	30 e0       	ldi	r19, 0x00	; 0
    2306:	3d 83       	std	Y+5, r19	; 0x05
    2308:	2c 83       	std	Y+4, r18	; 0x04
    230a:	8c 81       	ldd	r24, Y+4	; 0x04
    230c:	9d 81       	ldd	r25, Y+5	; 0x05
    230e:	81 30       	cpi	r24, 0x01	; 1
    2310:	91 05       	cpc	r25, r1
    2312:	09 f4       	brne	.+2      	; 0x2316 <GPIO_writePin+0x3a>
    2314:	43 c0       	rjmp	.+134    	; 0x239c <GPIO_writePin+0xc0>
    2316:	2c 81       	ldd	r18, Y+4	; 0x04
    2318:	3d 81       	ldd	r19, Y+5	; 0x05
    231a:	22 30       	cpi	r18, 0x02	; 2
    231c:	31 05       	cpc	r19, r1
    231e:	2c f4       	brge	.+10     	; 0x232a <GPIO_writePin+0x4e>
    2320:	8c 81       	ldd	r24, Y+4	; 0x04
    2322:	9d 81       	ldd	r25, Y+5	; 0x05
    2324:	00 97       	sbiw	r24, 0x00	; 0
    2326:	71 f0       	breq	.+28     	; 0x2344 <GPIO_writePin+0x68>
    2328:	bc c0       	rjmp	.+376    	; 0x24a2 <GPIO_writePin+0x1c6>
    232a:	2c 81       	ldd	r18, Y+4	; 0x04
    232c:	3d 81       	ldd	r19, Y+5	; 0x05
    232e:	22 30       	cpi	r18, 0x02	; 2
    2330:	31 05       	cpc	r19, r1
    2332:	09 f4       	brne	.+2      	; 0x2336 <GPIO_writePin+0x5a>
    2334:	5f c0       	rjmp	.+190    	; 0x23f4 <GPIO_writePin+0x118>
    2336:	8c 81       	ldd	r24, Y+4	; 0x04
    2338:	9d 81       	ldd	r25, Y+5	; 0x05
    233a:	83 30       	cpi	r24, 0x03	; 3
    233c:	91 05       	cpc	r25, r1
    233e:	09 f4       	brne	.+2      	; 0x2342 <GPIO_writePin+0x66>
    2340:	85 c0       	rjmp	.+266    	; 0x244c <GPIO_writePin+0x170>
    2342:	af c0       	rjmp	.+350    	; 0x24a2 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    2344:	8b 81       	ldd	r24, Y+3	; 0x03
    2346:	81 30       	cpi	r24, 0x01	; 1
    2348:	a1 f4       	brne	.+40     	; 0x2372 <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    234a:	ab e3       	ldi	r26, 0x3B	; 59
    234c:	b0 e0       	ldi	r27, 0x00	; 0
    234e:	eb e3       	ldi	r30, 0x3B	; 59
    2350:	f0 e0       	ldi	r31, 0x00	; 0
    2352:	80 81       	ld	r24, Z
    2354:	48 2f       	mov	r20, r24
    2356:	8a 81       	ldd	r24, Y+2	; 0x02
    2358:	28 2f       	mov	r18, r24
    235a:	30 e0       	ldi	r19, 0x00	; 0
    235c:	81 e0       	ldi	r24, 0x01	; 1
    235e:	90 e0       	ldi	r25, 0x00	; 0
    2360:	02 2e       	mov	r0, r18
    2362:	02 c0       	rjmp	.+4      	; 0x2368 <GPIO_writePin+0x8c>
    2364:	88 0f       	add	r24, r24
    2366:	99 1f       	adc	r25, r25
    2368:	0a 94       	dec	r0
    236a:	e2 f7       	brpl	.-8      	; 0x2364 <GPIO_writePin+0x88>
    236c:	84 2b       	or	r24, r20
    236e:	8c 93       	st	X, r24
    2370:	98 c0       	rjmp	.+304    	; 0x24a2 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    2372:	ab e3       	ldi	r26, 0x3B	; 59
    2374:	b0 e0       	ldi	r27, 0x00	; 0
    2376:	eb e3       	ldi	r30, 0x3B	; 59
    2378:	f0 e0       	ldi	r31, 0x00	; 0
    237a:	80 81       	ld	r24, Z
    237c:	48 2f       	mov	r20, r24
    237e:	8a 81       	ldd	r24, Y+2	; 0x02
    2380:	28 2f       	mov	r18, r24
    2382:	30 e0       	ldi	r19, 0x00	; 0
    2384:	81 e0       	ldi	r24, 0x01	; 1
    2386:	90 e0       	ldi	r25, 0x00	; 0
    2388:	02 2e       	mov	r0, r18
    238a:	02 c0       	rjmp	.+4      	; 0x2390 <GPIO_writePin+0xb4>
    238c:	88 0f       	add	r24, r24
    238e:	99 1f       	adc	r25, r25
    2390:	0a 94       	dec	r0
    2392:	e2 f7       	brpl	.-8      	; 0x238c <GPIO_writePin+0xb0>
    2394:	80 95       	com	r24
    2396:	84 23       	and	r24, r20
    2398:	8c 93       	st	X, r24
    239a:	83 c0       	rjmp	.+262    	; 0x24a2 <GPIO_writePin+0x1c6>
			}
			break;

		case PORTB_ID:
			if(value == LOGIC_HIGH)
    239c:	8b 81       	ldd	r24, Y+3	; 0x03
    239e:	81 30       	cpi	r24, 0x01	; 1
    23a0:	a1 f4       	brne	.+40     	; 0x23ca <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    23a2:	a8 e3       	ldi	r26, 0x38	; 56
    23a4:	b0 e0       	ldi	r27, 0x00	; 0
    23a6:	e8 e3       	ldi	r30, 0x38	; 56
    23a8:	f0 e0       	ldi	r31, 0x00	; 0
    23aa:	80 81       	ld	r24, Z
    23ac:	48 2f       	mov	r20, r24
    23ae:	8a 81       	ldd	r24, Y+2	; 0x02
    23b0:	28 2f       	mov	r18, r24
    23b2:	30 e0       	ldi	r19, 0x00	; 0
    23b4:	81 e0       	ldi	r24, 0x01	; 1
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	02 2e       	mov	r0, r18
    23ba:	02 c0       	rjmp	.+4      	; 0x23c0 <GPIO_writePin+0xe4>
    23bc:	88 0f       	add	r24, r24
    23be:	99 1f       	adc	r25, r25
    23c0:	0a 94       	dec	r0
    23c2:	e2 f7       	brpl	.-8      	; 0x23bc <GPIO_writePin+0xe0>
    23c4:	84 2b       	or	r24, r20
    23c6:	8c 93       	st	X, r24
    23c8:	6c c0       	rjmp	.+216    	; 0x24a2 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    23ca:	a8 e3       	ldi	r26, 0x38	; 56
    23cc:	b0 e0       	ldi	r27, 0x00	; 0
    23ce:	e8 e3       	ldi	r30, 0x38	; 56
    23d0:	f0 e0       	ldi	r31, 0x00	; 0
    23d2:	80 81       	ld	r24, Z
    23d4:	48 2f       	mov	r20, r24
    23d6:	8a 81       	ldd	r24, Y+2	; 0x02
    23d8:	28 2f       	mov	r18, r24
    23da:	30 e0       	ldi	r19, 0x00	; 0
    23dc:	81 e0       	ldi	r24, 0x01	; 1
    23de:	90 e0       	ldi	r25, 0x00	; 0
    23e0:	02 2e       	mov	r0, r18
    23e2:	02 c0       	rjmp	.+4      	; 0x23e8 <GPIO_writePin+0x10c>
    23e4:	88 0f       	add	r24, r24
    23e6:	99 1f       	adc	r25, r25
    23e8:	0a 94       	dec	r0
    23ea:	e2 f7       	brpl	.-8      	; 0x23e4 <GPIO_writePin+0x108>
    23ec:	80 95       	com	r24
    23ee:	84 23       	and	r24, r20
    23f0:	8c 93       	st	X, r24
    23f2:	57 c0       	rjmp	.+174    	; 0x24a2 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    23f4:	8b 81       	ldd	r24, Y+3	; 0x03
    23f6:	81 30       	cpi	r24, 0x01	; 1
    23f8:	a1 f4       	brne	.+40     	; 0x2422 <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    23fa:	a5 e3       	ldi	r26, 0x35	; 53
    23fc:	b0 e0       	ldi	r27, 0x00	; 0
    23fe:	e5 e3       	ldi	r30, 0x35	; 53
    2400:	f0 e0       	ldi	r31, 0x00	; 0
    2402:	80 81       	ld	r24, Z
    2404:	48 2f       	mov	r20, r24
    2406:	8a 81       	ldd	r24, Y+2	; 0x02
    2408:	28 2f       	mov	r18, r24
    240a:	30 e0       	ldi	r19, 0x00	; 0
    240c:	81 e0       	ldi	r24, 0x01	; 1
    240e:	90 e0       	ldi	r25, 0x00	; 0
    2410:	02 2e       	mov	r0, r18
    2412:	02 c0       	rjmp	.+4      	; 0x2418 <GPIO_writePin+0x13c>
    2414:	88 0f       	add	r24, r24
    2416:	99 1f       	adc	r25, r25
    2418:	0a 94       	dec	r0
    241a:	e2 f7       	brpl	.-8      	; 0x2414 <GPIO_writePin+0x138>
    241c:	84 2b       	or	r24, r20
    241e:	8c 93       	st	X, r24
    2420:	40 c0       	rjmp	.+128    	; 0x24a2 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    2422:	a5 e3       	ldi	r26, 0x35	; 53
    2424:	b0 e0       	ldi	r27, 0x00	; 0
    2426:	e5 e3       	ldi	r30, 0x35	; 53
    2428:	f0 e0       	ldi	r31, 0x00	; 0
    242a:	80 81       	ld	r24, Z
    242c:	48 2f       	mov	r20, r24
    242e:	8a 81       	ldd	r24, Y+2	; 0x02
    2430:	28 2f       	mov	r18, r24
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	81 e0       	ldi	r24, 0x01	; 1
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	02 2e       	mov	r0, r18
    243a:	02 c0       	rjmp	.+4      	; 0x2440 <GPIO_writePin+0x164>
    243c:	88 0f       	add	r24, r24
    243e:	99 1f       	adc	r25, r25
    2440:	0a 94       	dec	r0
    2442:	e2 f7       	brpl	.-8      	; 0x243c <GPIO_writePin+0x160>
    2444:	80 95       	com	r24
    2446:	84 23       	and	r24, r20
    2448:	8c 93       	st	X, r24
    244a:	2b c0       	rjmp	.+86     	; 0x24a2 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    244c:	8b 81       	ldd	r24, Y+3	; 0x03
    244e:	81 30       	cpi	r24, 0x01	; 1
    2450:	a1 f4       	brne	.+40     	; 0x247a <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    2452:	a2 e3       	ldi	r26, 0x32	; 50
    2454:	b0 e0       	ldi	r27, 0x00	; 0
    2456:	e2 e3       	ldi	r30, 0x32	; 50
    2458:	f0 e0       	ldi	r31, 0x00	; 0
    245a:	80 81       	ld	r24, Z
    245c:	48 2f       	mov	r20, r24
    245e:	8a 81       	ldd	r24, Y+2	; 0x02
    2460:	28 2f       	mov	r18, r24
    2462:	30 e0       	ldi	r19, 0x00	; 0
    2464:	81 e0       	ldi	r24, 0x01	; 1
    2466:	90 e0       	ldi	r25, 0x00	; 0
    2468:	02 2e       	mov	r0, r18
    246a:	02 c0       	rjmp	.+4      	; 0x2470 <GPIO_writePin+0x194>
    246c:	88 0f       	add	r24, r24
    246e:	99 1f       	adc	r25, r25
    2470:	0a 94       	dec	r0
    2472:	e2 f7       	brpl	.-8      	; 0x246c <GPIO_writePin+0x190>
    2474:	84 2b       	or	r24, r20
    2476:	8c 93       	st	X, r24
    2478:	14 c0       	rjmp	.+40     	; 0x24a2 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    247a:	a2 e3       	ldi	r26, 0x32	; 50
    247c:	b0 e0       	ldi	r27, 0x00	; 0
    247e:	e2 e3       	ldi	r30, 0x32	; 50
    2480:	f0 e0       	ldi	r31, 0x00	; 0
    2482:	80 81       	ld	r24, Z
    2484:	48 2f       	mov	r20, r24
    2486:	8a 81       	ldd	r24, Y+2	; 0x02
    2488:	28 2f       	mov	r18, r24
    248a:	30 e0       	ldi	r19, 0x00	; 0
    248c:	81 e0       	ldi	r24, 0x01	; 1
    248e:	90 e0       	ldi	r25, 0x00	; 0
    2490:	02 2e       	mov	r0, r18
    2492:	02 c0       	rjmp	.+4      	; 0x2498 <GPIO_writePin+0x1bc>
    2494:	88 0f       	add	r24, r24
    2496:	99 1f       	adc	r25, r25
    2498:	0a 94       	dec	r0
    249a:	e2 f7       	brpl	.-8      	; 0x2494 <GPIO_writePin+0x1b8>
    249c:	80 95       	com	r24
    249e:	84 23       	and	r24, r20
    24a0:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    24a2:	0f 90       	pop	r0
    24a4:	0f 90       	pop	r0
    24a6:	0f 90       	pop	r0
    24a8:	0f 90       	pop	r0
    24aa:	0f 90       	pop	r0
    24ac:	cf 91       	pop	r28
    24ae:	df 91       	pop	r29
    24b0:	08 95       	ret

000024b2 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    24b2:	df 93       	push	r29
    24b4:	cf 93       	push	r28
    24b6:	00 d0       	rcall	.+0      	; 0x24b8 <GPIO_readPin+0x6>
    24b8:	00 d0       	rcall	.+0      	; 0x24ba <GPIO_readPin+0x8>
    24ba:	0f 92       	push	r0
    24bc:	cd b7       	in	r28, 0x3d	; 61
    24be:	de b7       	in	r29, 0x3e	; 62
    24c0:	8a 83       	std	Y+2, r24	; 0x02
    24c2:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    24c4:	19 82       	std	Y+1, r1	; 0x01

	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    24c6:	8b 81       	ldd	r24, Y+3	; 0x03
    24c8:	88 30       	cpi	r24, 0x08	; 8
    24ca:	08 f0       	brcs	.+2      	; 0x24ce <GPIO_readPin+0x1c>
    24cc:	84 c0       	rjmp	.+264    	; 0x25d6 <GPIO_readPin+0x124>
    24ce:	8a 81       	ldd	r24, Y+2	; 0x02
    24d0:	84 30       	cpi	r24, 0x04	; 4
    24d2:	08 f0       	brcs	.+2      	; 0x24d6 <GPIO_readPin+0x24>
    24d4:	80 c0       	rjmp	.+256    	; 0x25d6 <GPIO_readPin+0x124>
	{
		/* Do Nothing */
	}
	else
	{
		switch(port_num)
    24d6:	8a 81       	ldd	r24, Y+2	; 0x02
    24d8:	28 2f       	mov	r18, r24
    24da:	30 e0       	ldi	r19, 0x00	; 0
    24dc:	3d 83       	std	Y+5, r19	; 0x05
    24de:	2c 83       	std	Y+4, r18	; 0x04
    24e0:	4c 81       	ldd	r20, Y+4	; 0x04
    24e2:	5d 81       	ldd	r21, Y+5	; 0x05
    24e4:	41 30       	cpi	r20, 0x01	; 1
    24e6:	51 05       	cpc	r21, r1
    24e8:	79 f1       	breq	.+94     	; 0x2548 <GPIO_readPin+0x96>
    24ea:	8c 81       	ldd	r24, Y+4	; 0x04
    24ec:	9d 81       	ldd	r25, Y+5	; 0x05
    24ee:	82 30       	cpi	r24, 0x02	; 2
    24f0:	91 05       	cpc	r25, r1
    24f2:	34 f4       	brge	.+12     	; 0x2500 <GPIO_readPin+0x4e>
    24f4:	2c 81       	ldd	r18, Y+4	; 0x04
    24f6:	3d 81       	ldd	r19, Y+5	; 0x05
    24f8:	21 15       	cp	r18, r1
    24fa:	31 05       	cpc	r19, r1
    24fc:	69 f0       	breq	.+26     	; 0x2518 <GPIO_readPin+0x66>
    24fe:	6b c0       	rjmp	.+214    	; 0x25d6 <GPIO_readPin+0x124>
    2500:	4c 81       	ldd	r20, Y+4	; 0x04
    2502:	5d 81       	ldd	r21, Y+5	; 0x05
    2504:	42 30       	cpi	r20, 0x02	; 2
    2506:	51 05       	cpc	r21, r1
    2508:	b9 f1       	breq	.+110    	; 0x2578 <GPIO_readPin+0xc6>
    250a:	8c 81       	ldd	r24, Y+4	; 0x04
    250c:	9d 81       	ldd	r25, Y+5	; 0x05
    250e:	83 30       	cpi	r24, 0x03	; 3
    2510:	91 05       	cpc	r25, r1
    2512:	09 f4       	brne	.+2      	; 0x2516 <GPIO_readPin+0x64>
    2514:	49 c0       	rjmp	.+146    	; 0x25a8 <GPIO_readPin+0xf6>
    2516:	5f c0       	rjmp	.+190    	; 0x25d6 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    2518:	e9 e3       	ldi	r30, 0x39	; 57
    251a:	f0 e0       	ldi	r31, 0x00	; 0
    251c:	80 81       	ld	r24, Z
    251e:	28 2f       	mov	r18, r24
    2520:	30 e0       	ldi	r19, 0x00	; 0
    2522:	8b 81       	ldd	r24, Y+3	; 0x03
    2524:	88 2f       	mov	r24, r24
    2526:	90 e0       	ldi	r25, 0x00	; 0
    2528:	a9 01       	movw	r20, r18
    252a:	02 c0       	rjmp	.+4      	; 0x2530 <GPIO_readPin+0x7e>
    252c:	55 95       	asr	r21
    252e:	47 95       	ror	r20
    2530:	8a 95       	dec	r24
    2532:	e2 f7       	brpl	.-8      	; 0x252c <GPIO_readPin+0x7a>
    2534:	ca 01       	movw	r24, r20
    2536:	81 70       	andi	r24, 0x01	; 1
    2538:	90 70       	andi	r25, 0x00	; 0
    253a:	88 23       	and	r24, r24
    253c:	19 f0       	breq	.+6      	; 0x2544 <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    253e:	81 e0       	ldi	r24, 0x01	; 1
    2540:	89 83       	std	Y+1, r24	; 0x01
    2542:	49 c0       	rjmp	.+146    	; 0x25d6 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    2544:	19 82       	std	Y+1, r1	; 0x01
    2546:	47 c0       	rjmp	.+142    	; 0x25d6 <GPIO_readPin+0x124>
			}
			break;

		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    2548:	e6 e3       	ldi	r30, 0x36	; 54
    254a:	f0 e0       	ldi	r31, 0x00	; 0
    254c:	80 81       	ld	r24, Z
    254e:	28 2f       	mov	r18, r24
    2550:	30 e0       	ldi	r19, 0x00	; 0
    2552:	8b 81       	ldd	r24, Y+3	; 0x03
    2554:	88 2f       	mov	r24, r24
    2556:	90 e0       	ldi	r25, 0x00	; 0
    2558:	a9 01       	movw	r20, r18
    255a:	02 c0       	rjmp	.+4      	; 0x2560 <GPIO_readPin+0xae>
    255c:	55 95       	asr	r21
    255e:	47 95       	ror	r20
    2560:	8a 95       	dec	r24
    2562:	e2 f7       	brpl	.-8      	; 0x255c <GPIO_readPin+0xaa>
    2564:	ca 01       	movw	r24, r20
    2566:	81 70       	andi	r24, 0x01	; 1
    2568:	90 70       	andi	r25, 0x00	; 0
    256a:	88 23       	and	r24, r24
    256c:	19 f0       	breq	.+6      	; 0x2574 <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    256e:	81 e0       	ldi	r24, 0x01	; 1
    2570:	89 83       	std	Y+1, r24	; 0x01
    2572:	31 c0       	rjmp	.+98     	; 0x25d6 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    2574:	19 82       	std	Y+1, r1	; 0x01
    2576:	2f c0       	rjmp	.+94     	; 0x25d6 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    2578:	e3 e3       	ldi	r30, 0x33	; 51
    257a:	f0 e0       	ldi	r31, 0x00	; 0
    257c:	80 81       	ld	r24, Z
    257e:	28 2f       	mov	r18, r24
    2580:	30 e0       	ldi	r19, 0x00	; 0
    2582:	8b 81       	ldd	r24, Y+3	; 0x03
    2584:	88 2f       	mov	r24, r24
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	a9 01       	movw	r20, r18
    258a:	02 c0       	rjmp	.+4      	; 0x2590 <GPIO_readPin+0xde>
    258c:	55 95       	asr	r21
    258e:	47 95       	ror	r20
    2590:	8a 95       	dec	r24
    2592:	e2 f7       	brpl	.-8      	; 0x258c <GPIO_readPin+0xda>
    2594:	ca 01       	movw	r24, r20
    2596:	81 70       	andi	r24, 0x01	; 1
    2598:	90 70       	andi	r25, 0x00	; 0
    259a:	88 23       	and	r24, r24
    259c:	19 f0       	breq	.+6      	; 0x25a4 <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    259e:	81 e0       	ldi	r24, 0x01	; 1
    25a0:	89 83       	std	Y+1, r24	; 0x01
    25a2:	19 c0       	rjmp	.+50     	; 0x25d6 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    25a4:	19 82       	std	Y+1, r1	; 0x01
    25a6:	17 c0       	rjmp	.+46     	; 0x25d6 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    25a8:	e0 e3       	ldi	r30, 0x30	; 48
    25aa:	f0 e0       	ldi	r31, 0x00	; 0
    25ac:	80 81       	ld	r24, Z
    25ae:	28 2f       	mov	r18, r24
    25b0:	30 e0       	ldi	r19, 0x00	; 0
    25b2:	8b 81       	ldd	r24, Y+3	; 0x03
    25b4:	88 2f       	mov	r24, r24
    25b6:	90 e0       	ldi	r25, 0x00	; 0
    25b8:	a9 01       	movw	r20, r18
    25ba:	02 c0       	rjmp	.+4      	; 0x25c0 <GPIO_readPin+0x10e>
    25bc:	55 95       	asr	r21
    25be:	47 95       	ror	r20
    25c0:	8a 95       	dec	r24
    25c2:	e2 f7       	brpl	.-8      	; 0x25bc <GPIO_readPin+0x10a>
    25c4:	ca 01       	movw	r24, r20
    25c6:	81 70       	andi	r24, 0x01	; 1
    25c8:	90 70       	andi	r25, 0x00	; 0
    25ca:	88 23       	and	r24, r24
    25cc:	19 f0       	breq	.+6      	; 0x25d4 <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    25ce:	81 e0       	ldi	r24, 0x01	; 1
    25d0:	89 83       	std	Y+1, r24	; 0x01
    25d2:	01 c0       	rjmp	.+2      	; 0x25d6 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    25d4:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}
	return pin_value;
    25d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    25d8:	0f 90       	pop	r0
    25da:	0f 90       	pop	r0
    25dc:	0f 90       	pop	r0
    25de:	0f 90       	pop	r0
    25e0:	0f 90       	pop	r0
    25e2:	cf 91       	pop	r28
    25e4:	df 91       	pop	r29
    25e6:	08 95       	ret

000025e8 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    25e8:	df 93       	push	r29
    25ea:	cf 93       	push	r28
    25ec:	00 d0       	rcall	.+0      	; 0x25ee <GPIO_setupPortDirection+0x6>
    25ee:	00 d0       	rcall	.+0      	; 0x25f0 <GPIO_setupPortDirection+0x8>
    25f0:	cd b7       	in	r28, 0x3d	; 61
    25f2:	de b7       	in	r29, 0x3e	; 62
    25f4:	89 83       	std	Y+1, r24	; 0x01
    25f6:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    25f8:	89 81       	ldd	r24, Y+1	; 0x01
    25fa:	84 30       	cpi	r24, 0x04	; 4
    25fc:	90 f5       	brcc	.+100    	; 0x2662 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    25fe:	89 81       	ldd	r24, Y+1	; 0x01
    2600:	28 2f       	mov	r18, r24
    2602:	30 e0       	ldi	r19, 0x00	; 0
    2604:	3c 83       	std	Y+4, r19	; 0x04
    2606:	2b 83       	std	Y+3, r18	; 0x03
    2608:	8b 81       	ldd	r24, Y+3	; 0x03
    260a:	9c 81       	ldd	r25, Y+4	; 0x04
    260c:	81 30       	cpi	r24, 0x01	; 1
    260e:	91 05       	cpc	r25, r1
    2610:	d1 f0       	breq	.+52     	; 0x2646 <GPIO_setupPortDirection+0x5e>
    2612:	2b 81       	ldd	r18, Y+3	; 0x03
    2614:	3c 81       	ldd	r19, Y+4	; 0x04
    2616:	22 30       	cpi	r18, 0x02	; 2
    2618:	31 05       	cpc	r19, r1
    261a:	2c f4       	brge	.+10     	; 0x2626 <GPIO_setupPortDirection+0x3e>
    261c:	8b 81       	ldd	r24, Y+3	; 0x03
    261e:	9c 81       	ldd	r25, Y+4	; 0x04
    2620:	00 97       	sbiw	r24, 0x00	; 0
    2622:	61 f0       	breq	.+24     	; 0x263c <GPIO_setupPortDirection+0x54>
    2624:	1e c0       	rjmp	.+60     	; 0x2662 <GPIO_setupPortDirection+0x7a>
    2626:	2b 81       	ldd	r18, Y+3	; 0x03
    2628:	3c 81       	ldd	r19, Y+4	; 0x04
    262a:	22 30       	cpi	r18, 0x02	; 2
    262c:	31 05       	cpc	r19, r1
    262e:	81 f0       	breq	.+32     	; 0x2650 <GPIO_setupPortDirection+0x68>
    2630:	8b 81       	ldd	r24, Y+3	; 0x03
    2632:	9c 81       	ldd	r25, Y+4	; 0x04
    2634:	83 30       	cpi	r24, 0x03	; 3
    2636:	91 05       	cpc	r25, r1
    2638:	81 f0       	breq	.+32     	; 0x265a <GPIO_setupPortDirection+0x72>
    263a:	13 c0       	rjmp	.+38     	; 0x2662 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    263c:	ea e3       	ldi	r30, 0x3A	; 58
    263e:	f0 e0       	ldi	r31, 0x00	; 0
    2640:	8a 81       	ldd	r24, Y+2	; 0x02
    2642:	80 83       	st	Z, r24
    2644:	0e c0       	rjmp	.+28     	; 0x2662 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    2646:	e7 e3       	ldi	r30, 0x37	; 55
    2648:	f0 e0       	ldi	r31, 0x00	; 0
    264a:	8a 81       	ldd	r24, Y+2	; 0x02
    264c:	80 83       	st	Z, r24
    264e:	09 c0       	rjmp	.+18     	; 0x2662 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    2650:	e4 e3       	ldi	r30, 0x34	; 52
    2652:	f0 e0       	ldi	r31, 0x00	; 0
    2654:	8a 81       	ldd	r24, Y+2	; 0x02
    2656:	80 83       	st	Z, r24
    2658:	04 c0       	rjmp	.+8      	; 0x2662 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    265a:	e1 e3       	ldi	r30, 0x31	; 49
    265c:	f0 e0       	ldi	r31, 0x00	; 0
    265e:	8a 81       	ldd	r24, Y+2	; 0x02
    2660:	80 83       	st	Z, r24
			break;
		}
	}
}
    2662:	0f 90       	pop	r0
    2664:	0f 90       	pop	r0
    2666:	0f 90       	pop	r0
    2668:	0f 90       	pop	r0
    266a:	cf 91       	pop	r28
    266c:	df 91       	pop	r29
    266e:	08 95       	ret

00002670 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    2670:	df 93       	push	r29
    2672:	cf 93       	push	r28
    2674:	00 d0       	rcall	.+0      	; 0x2676 <GPIO_writePort+0x6>
    2676:	00 d0       	rcall	.+0      	; 0x2678 <GPIO_writePort+0x8>
    2678:	cd b7       	in	r28, 0x3d	; 61
    267a:	de b7       	in	r29, 0x3e	; 62
    267c:	89 83       	std	Y+1, r24	; 0x01
    267e:	6a 83       	std	Y+2, r22	; 0x02
	if((port_num >= NUM_OF_PORTS))
    2680:	89 81       	ldd	r24, Y+1	; 0x01
    2682:	84 30       	cpi	r24, 0x04	; 4
    2684:	90 f5       	brcc	.+100    	; 0x26ea <GPIO_writePort+0x7a>
	{
		/* Do Nothing */
	}
	else
	{
		switch(port_num)
    2686:	89 81       	ldd	r24, Y+1	; 0x01
    2688:	28 2f       	mov	r18, r24
    268a:	30 e0       	ldi	r19, 0x00	; 0
    268c:	3c 83       	std	Y+4, r19	; 0x04
    268e:	2b 83       	std	Y+3, r18	; 0x03
    2690:	8b 81       	ldd	r24, Y+3	; 0x03
    2692:	9c 81       	ldd	r25, Y+4	; 0x04
    2694:	81 30       	cpi	r24, 0x01	; 1
    2696:	91 05       	cpc	r25, r1
    2698:	d1 f0       	breq	.+52     	; 0x26ce <GPIO_writePort+0x5e>
    269a:	2b 81       	ldd	r18, Y+3	; 0x03
    269c:	3c 81       	ldd	r19, Y+4	; 0x04
    269e:	22 30       	cpi	r18, 0x02	; 2
    26a0:	31 05       	cpc	r19, r1
    26a2:	2c f4       	brge	.+10     	; 0x26ae <GPIO_writePort+0x3e>
    26a4:	8b 81       	ldd	r24, Y+3	; 0x03
    26a6:	9c 81       	ldd	r25, Y+4	; 0x04
    26a8:	00 97       	sbiw	r24, 0x00	; 0
    26aa:	61 f0       	breq	.+24     	; 0x26c4 <GPIO_writePort+0x54>
    26ac:	1e c0       	rjmp	.+60     	; 0x26ea <GPIO_writePort+0x7a>
    26ae:	2b 81       	ldd	r18, Y+3	; 0x03
    26b0:	3c 81       	ldd	r19, Y+4	; 0x04
    26b2:	22 30       	cpi	r18, 0x02	; 2
    26b4:	31 05       	cpc	r19, r1
    26b6:	81 f0       	breq	.+32     	; 0x26d8 <GPIO_writePort+0x68>
    26b8:	8b 81       	ldd	r24, Y+3	; 0x03
    26ba:	9c 81       	ldd	r25, Y+4	; 0x04
    26bc:	83 30       	cpi	r24, 0x03	; 3
    26be:	91 05       	cpc	r25, r1
    26c0:	81 f0       	breq	.+32     	; 0x26e2 <GPIO_writePort+0x72>
    26c2:	13 c0       	rjmp	.+38     	; 0x26ea <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    26c4:	eb e3       	ldi	r30, 0x3B	; 59
    26c6:	f0 e0       	ldi	r31, 0x00	; 0
    26c8:	8a 81       	ldd	r24, Y+2	; 0x02
    26ca:	80 83       	st	Z, r24
    26cc:	0e c0       	rjmp	.+28     	; 0x26ea <GPIO_writePort+0x7a>
			break;

		case PORTB_ID:
			PORTB = value;
    26ce:	e8 e3       	ldi	r30, 0x38	; 56
    26d0:	f0 e0       	ldi	r31, 0x00	; 0
    26d2:	8a 81       	ldd	r24, Y+2	; 0x02
    26d4:	80 83       	st	Z, r24
    26d6:	09 c0       	rjmp	.+18     	; 0x26ea <GPIO_writePort+0x7a>
			break;

		case PORTC_ID:
			PORTC = value;
    26d8:	e5 e3       	ldi	r30, 0x35	; 53
    26da:	f0 e0       	ldi	r31, 0x00	; 0
    26dc:	8a 81       	ldd	r24, Y+2	; 0x02
    26de:	80 83       	st	Z, r24
    26e0:	04 c0       	rjmp	.+8      	; 0x26ea <GPIO_writePort+0x7a>
			break;

		case PORTD_ID:
			PORTD = value;
    26e2:	e2 e3       	ldi	r30, 0x32	; 50
    26e4:	f0 e0       	ldi	r31, 0x00	; 0
    26e6:	8a 81       	ldd	r24, Y+2	; 0x02
    26e8:	80 83       	st	Z, r24
			break;
		}
	}
}
    26ea:	0f 90       	pop	r0
    26ec:	0f 90       	pop	r0
    26ee:	0f 90       	pop	r0
    26f0:	0f 90       	pop	r0
    26f2:	cf 91       	pop	r28
    26f4:	df 91       	pop	r29
    26f6:	08 95       	ret

000026f8 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{	uint8 value = LOGIC_LOW;
    26f8:	df 93       	push	r29
    26fa:	cf 93       	push	r28
    26fc:	00 d0       	rcall	.+0      	; 0x26fe <GPIO_readPort+0x6>
    26fe:	00 d0       	rcall	.+0      	; 0x2700 <GPIO_readPort+0x8>
    2700:	cd b7       	in	r28, 0x3d	; 61
    2702:	de b7       	in	r29, 0x3e	; 62
    2704:	8a 83       	std	Y+2, r24	; 0x02
    2706:	19 82       	std	Y+1, r1	; 0x01

	if((port_num >= NUM_OF_PORTS))
    2708:	8a 81       	ldd	r24, Y+2	; 0x02
    270a:	84 30       	cpi	r24, 0x04	; 4
    270c:	90 f5       	brcc	.+100    	; 0x2772 <GPIO_readPort+0x7a>
	{
		/* Do Nothing */
	}
	else
	{
		switch(port_num)
    270e:	8a 81       	ldd	r24, Y+2	; 0x02
    2710:	28 2f       	mov	r18, r24
    2712:	30 e0       	ldi	r19, 0x00	; 0
    2714:	3c 83       	std	Y+4, r19	; 0x04
    2716:	2b 83       	std	Y+3, r18	; 0x03
    2718:	8b 81       	ldd	r24, Y+3	; 0x03
    271a:	9c 81       	ldd	r25, Y+4	; 0x04
    271c:	81 30       	cpi	r24, 0x01	; 1
    271e:	91 05       	cpc	r25, r1
    2720:	d1 f0       	breq	.+52     	; 0x2756 <GPIO_readPort+0x5e>
    2722:	2b 81       	ldd	r18, Y+3	; 0x03
    2724:	3c 81       	ldd	r19, Y+4	; 0x04
    2726:	22 30       	cpi	r18, 0x02	; 2
    2728:	31 05       	cpc	r19, r1
    272a:	2c f4       	brge	.+10     	; 0x2736 <GPIO_readPort+0x3e>
    272c:	8b 81       	ldd	r24, Y+3	; 0x03
    272e:	9c 81       	ldd	r25, Y+4	; 0x04
    2730:	00 97       	sbiw	r24, 0x00	; 0
    2732:	61 f0       	breq	.+24     	; 0x274c <GPIO_readPort+0x54>
    2734:	1e c0       	rjmp	.+60     	; 0x2772 <GPIO_readPort+0x7a>
    2736:	2b 81       	ldd	r18, Y+3	; 0x03
    2738:	3c 81       	ldd	r19, Y+4	; 0x04
    273a:	22 30       	cpi	r18, 0x02	; 2
    273c:	31 05       	cpc	r19, r1
    273e:	81 f0       	breq	.+32     	; 0x2760 <GPIO_readPort+0x68>
    2740:	8b 81       	ldd	r24, Y+3	; 0x03
    2742:	9c 81       	ldd	r25, Y+4	; 0x04
    2744:	83 30       	cpi	r24, 0x03	; 3
    2746:	91 05       	cpc	r25, r1
    2748:	81 f0       	breq	.+32     	; 0x276a <GPIO_readPort+0x72>
    274a:	13 c0       	rjmp	.+38     	; 0x2772 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    274c:	e9 e3       	ldi	r30, 0x39	; 57
    274e:	f0 e0       	ldi	r31, 0x00	; 0
    2750:	80 81       	ld	r24, Z
    2752:	89 83       	std	Y+1, r24	; 0x01
    2754:	0e c0       	rjmp	.+28     	; 0x2772 <GPIO_readPort+0x7a>
			break;

		case PORTB_ID:
			value = PINB;
    2756:	e6 e3       	ldi	r30, 0x36	; 54
    2758:	f0 e0       	ldi	r31, 0x00	; 0
    275a:	80 81       	ld	r24, Z
    275c:	89 83       	std	Y+1, r24	; 0x01
    275e:	09 c0       	rjmp	.+18     	; 0x2772 <GPIO_readPort+0x7a>
			break;

		case PORTC_ID:
			value = PINC;
    2760:	e3 e3       	ldi	r30, 0x33	; 51
    2762:	f0 e0       	ldi	r31, 0x00	; 0
    2764:	80 81       	ld	r24, Z
    2766:	89 83       	std	Y+1, r24	; 0x01
    2768:	04 c0       	rjmp	.+8      	; 0x2772 <GPIO_readPort+0x7a>
			break;

		case PORTD_ID:
			value = PIND;
    276a:	e0 e3       	ldi	r30, 0x30	; 48
    276c:	f0 e0       	ldi	r31, 0x00	; 0
    276e:	80 81       	ld	r24, Z
    2770:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}
	return value;
    2772:	89 81       	ldd	r24, Y+1	; 0x01
}
    2774:	0f 90       	pop	r0
    2776:	0f 90       	pop	r0
    2778:	0f 90       	pop	r0
    277a:	0f 90       	pop	r0
    277c:	cf 91       	pop	r28
    277e:	df 91       	pop	r29
    2780:	08 95       	ret

00002782 <DcMotor_Init>:
 *                     motor pins through the GPIO driver.
 *                    Stop at the DC-Motor at the beginning through the GPIO driver.
 *
 * [Args]          : NONE
 *******************************************************************************/
void DcMotor_Init(void){
    2782:	df 93       	push	r29
    2784:	cf 93       	push	r28
    2786:	cd b7       	in	r28, 0x3d	; 61
    2788:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(MOTOR_PORT_ID, MOTOR_PIN0_ID, PIN_OUTPUT);
    278a:	80 e0       	ldi	r24, 0x00	; 0
    278c:	60 e0       	ldi	r22, 0x00	; 0
    278e:	41 e0       	ldi	r20, 0x01	; 1
    2790:	0e 94 83 10 	call	0x2106	; 0x2106 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(MOTOR_PORT_ID, MOTOR_PIN1_ID, PIN_OUTPUT);
    2794:	80 e0       	ldi	r24, 0x00	; 0
    2796:	61 e0       	ldi	r22, 0x01	; 1
    2798:	41 e0       	ldi	r20, 0x01	; 1
    279a:	0e 94 83 10 	call	0x2106	; 0x2106 <GPIO_setupPinDirection>
	GPIO_writePin(MOTOR_PORT_ID, MOTOR_PIN0_ID, LOGIC_LOW);
    279e:	80 e0       	ldi	r24, 0x00	; 0
    27a0:	60 e0       	ldi	r22, 0x00	; 0
    27a2:	40 e0       	ldi	r20, 0x00	; 0
    27a4:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
	GPIO_writePin(MOTOR_PORT_ID, MOTOR_PIN1_ID, LOGIC_LOW);
    27a8:	80 e0       	ldi	r24, 0x00	; 0
    27aa:	61 e0       	ldi	r22, 0x01	; 1
    27ac:	40 e0       	ldi	r20, 0x00	; 0
    27ae:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
}
    27b2:	cf 91       	pop	r28
    27b4:	df 91       	pop	r29
    27b6:	08 95       	ret

000027b8 <DcMotor_Rotate>:
 *
 *    [IN]            :  uint8 speed
 *                       speed: decimal value for the required motor speed, it should be from 0  100
 *********************************************************************************/

void DcMotor_Rotate(DcMotor_State state){
    27b8:	df 93       	push	r29
    27ba:	cf 93       	push	r28
    27bc:	00 d0       	rcall	.+0      	; 0x27be <DcMotor_Rotate+0x6>
    27be:	0f 92       	push	r0
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
    27c4:	89 83       	std	Y+1, r24	; 0x01
/*switch case for determining which state to choose:
 *      Stop      -   Clock Wise     -    Anti-clock wise
 *   IN1 , IN2    -    IN1 , IN2     -     IN1 , IN2
 *    0  ,  0     -     0  ,  1      -      1  ,  0
 * */
switch(state){
    27c6:	89 81       	ldd	r24, Y+1	; 0x01
    27c8:	28 2f       	mov	r18, r24
    27ca:	30 e0       	ldi	r19, 0x00	; 0
    27cc:	3b 83       	std	Y+3, r19	; 0x03
    27ce:	2a 83       	std	Y+2, r18	; 0x02
    27d0:	8a 81       	ldd	r24, Y+2	; 0x02
    27d2:	9b 81       	ldd	r25, Y+3	; 0x03
    27d4:	81 30       	cpi	r24, 0x01	; 1
    27d6:	91 05       	cpc	r25, r1
    27d8:	a1 f0       	breq	.+40     	; 0x2802 <DcMotor_Rotate+0x4a>
    27da:	2a 81       	ldd	r18, Y+2	; 0x02
    27dc:	3b 81       	ldd	r19, Y+3	; 0x03
    27de:	22 30       	cpi	r18, 0x02	; 2
    27e0:	31 05       	cpc	r19, r1
    27e2:	d1 f0       	breq	.+52     	; 0x2818 <DcMotor_Rotate+0x60>
    27e4:	8a 81       	ldd	r24, Y+2	; 0x02
    27e6:	9b 81       	ldd	r25, Y+3	; 0x03
    27e8:	00 97       	sbiw	r24, 0x00	; 0
    27ea:	01 f5       	brne	.+64     	; 0x282c <DcMotor_Rotate+0x74>
case stop:
	GPIO_writePin(MOTOR_PORT_ID, MOTOR_PIN0_ID, LOGIC_LOW);
    27ec:	80 e0       	ldi	r24, 0x00	; 0
    27ee:	60 e0       	ldi	r22, 0x00	; 0
    27f0:	40 e0       	ldi	r20, 0x00	; 0
    27f2:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
	GPIO_writePin(MOTOR_PORT_ID, MOTOR_PIN1_ID, LOGIC_LOW);
    27f6:	80 e0       	ldi	r24, 0x00	; 0
    27f8:	61 e0       	ldi	r22, 0x01	; 1
    27fa:	40 e0       	ldi	r20, 0x00	; 0
    27fc:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
    2800:	15 c0       	rjmp	.+42     	; 0x282c <DcMotor_Rotate+0x74>
	break;
case CW:
	GPIO_writePin(MOTOR_PORT_ID, MOTOR_PIN0_ID, LOGIC_LOW);
    2802:	80 e0       	ldi	r24, 0x00	; 0
    2804:	60 e0       	ldi	r22, 0x00	; 0
    2806:	40 e0       	ldi	r20, 0x00	; 0
    2808:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
	GPIO_writePin(MOTOR_PORT_ID, MOTOR_PIN1_ID, LOGIC_HIGH);
    280c:	80 e0       	ldi	r24, 0x00	; 0
    280e:	61 e0       	ldi	r22, 0x01	; 1
    2810:	41 e0       	ldi	r20, 0x01	; 1
    2812:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
    2816:	0a c0       	rjmp	.+20     	; 0x282c <DcMotor_Rotate+0x74>
	break;
case A_CW:
	GPIO_writePin(MOTOR_PORT_ID, MOTOR_PIN0_ID, LOGIC_HIGH);
    2818:	80 e0       	ldi	r24, 0x00	; 0
    281a:	60 e0       	ldi	r22, 0x00	; 0
    281c:	41 e0       	ldi	r20, 0x01	; 1
    281e:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
	GPIO_writePin(MOTOR_PORT_ID, MOTOR_PIN1_ID, LOGIC_LOW);
    2822:	80 e0       	ldi	r24, 0x00	; 0
    2824:	61 e0       	ldi	r22, 0x01	; 1
    2826:	40 e0       	ldi	r20, 0x00	; 0
    2828:	0e 94 6e 11 	call	0x22dc	; 0x22dc <GPIO_writePin>
	break;
}
}
    282c:	0f 90       	pop	r0
    282e:	0f 90       	pop	r0
    2830:	0f 90       	pop	r0
    2832:	cf 91       	pop	r28
    2834:	df 91       	pop	r29
    2836:	08 95       	ret

00002838 <__vector_9>:
static volatile void (*t1_callBackPtr)(void) = NULL_PTR;
static volatile void (*t2_callBackPtr)(void) = NULL_PTR;



ISR(TIMER0_OVF_vect){
    2838:	1f 92       	push	r1
    283a:	0f 92       	push	r0
    283c:	0f b6       	in	r0, 0x3f	; 63
    283e:	0f 92       	push	r0
    2840:	11 24       	eor	r1, r1
    2842:	2f 93       	push	r18
    2844:	3f 93       	push	r19
    2846:	4f 93       	push	r20
    2848:	5f 93       	push	r21
    284a:	6f 93       	push	r22
    284c:	7f 93       	push	r23
    284e:	8f 93       	push	r24
    2850:	9f 93       	push	r25
    2852:	af 93       	push	r26
    2854:	bf 93       	push	r27
    2856:	ef 93       	push	r30
    2858:	ff 93       	push	r31
    285a:	df 93       	push	r29
    285c:	cf 93       	push	r28
    285e:	cd b7       	in	r28, 0x3d	; 61
    2860:	de b7       	in	r29, 0x3e	; 62
	if(t0_callBackPtr != NULL_PTR)
    2862:	80 91 a8 00 	lds	r24, 0x00A8
    2866:	90 91 a9 00 	lds	r25, 0x00A9
    286a:	00 97       	sbiw	r24, 0x00	; 0
    286c:	29 f0       	breq	.+10     	; 0x2878 <__vector_9+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*t0_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    286e:	e0 91 a8 00 	lds	r30, 0x00A8
    2872:	f0 91 a9 00 	lds	r31, 0x00A9
    2876:	09 95       	icall
	}
}
    2878:	cf 91       	pop	r28
    287a:	df 91       	pop	r29
    287c:	ff 91       	pop	r31
    287e:	ef 91       	pop	r30
    2880:	bf 91       	pop	r27
    2882:	af 91       	pop	r26
    2884:	9f 91       	pop	r25
    2886:	8f 91       	pop	r24
    2888:	7f 91       	pop	r23
    288a:	6f 91       	pop	r22
    288c:	5f 91       	pop	r21
    288e:	4f 91       	pop	r20
    2890:	3f 91       	pop	r19
    2892:	2f 91       	pop	r18
    2894:	0f 90       	pop	r0
    2896:	0f be       	out	0x3f, r0	; 63
    2898:	0f 90       	pop	r0
    289a:	1f 90       	pop	r1
    289c:	18 95       	reti

0000289e <__vector_19>:
ISR(TIMER0_COMP_vect){
    289e:	1f 92       	push	r1
    28a0:	0f 92       	push	r0
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	0f 92       	push	r0
    28a6:	11 24       	eor	r1, r1
    28a8:	2f 93       	push	r18
    28aa:	3f 93       	push	r19
    28ac:	4f 93       	push	r20
    28ae:	5f 93       	push	r21
    28b0:	6f 93       	push	r22
    28b2:	7f 93       	push	r23
    28b4:	8f 93       	push	r24
    28b6:	9f 93       	push	r25
    28b8:	af 93       	push	r26
    28ba:	bf 93       	push	r27
    28bc:	ef 93       	push	r30
    28be:	ff 93       	push	r31
    28c0:	df 93       	push	r29
    28c2:	cf 93       	push	r28
    28c4:	cd b7       	in	r28, 0x3d	; 61
    28c6:	de b7       	in	r29, 0x3e	; 62
	if(t0_callBackPtr != NULL_PTR)
    28c8:	80 91 a8 00 	lds	r24, 0x00A8
    28cc:	90 91 a9 00 	lds	r25, 0x00A9
    28d0:	00 97       	sbiw	r24, 0x00	; 0
    28d2:	29 f0       	breq	.+10     	; 0x28de <__vector_19+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*t0_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    28d4:	e0 91 a8 00 	lds	r30, 0x00A8
    28d8:	f0 91 a9 00 	lds	r31, 0x00A9
    28dc:	09 95       	icall
	}
}
    28de:	cf 91       	pop	r28
    28e0:	df 91       	pop	r29
    28e2:	ff 91       	pop	r31
    28e4:	ef 91       	pop	r30
    28e6:	bf 91       	pop	r27
    28e8:	af 91       	pop	r26
    28ea:	9f 91       	pop	r25
    28ec:	8f 91       	pop	r24
    28ee:	7f 91       	pop	r23
    28f0:	6f 91       	pop	r22
    28f2:	5f 91       	pop	r21
    28f4:	4f 91       	pop	r20
    28f6:	3f 91       	pop	r19
    28f8:	2f 91       	pop	r18
    28fa:	0f 90       	pop	r0
    28fc:	0f be       	out	0x3f, r0	; 63
    28fe:	0f 90       	pop	r0
    2900:	1f 90       	pop	r1
    2902:	18 95       	reti

00002904 <__vector_8>:
ISR(TIMER1_OVF_vect){
    2904:	1f 92       	push	r1
    2906:	0f 92       	push	r0
    2908:	0f b6       	in	r0, 0x3f	; 63
    290a:	0f 92       	push	r0
    290c:	11 24       	eor	r1, r1
    290e:	2f 93       	push	r18
    2910:	3f 93       	push	r19
    2912:	4f 93       	push	r20
    2914:	5f 93       	push	r21
    2916:	6f 93       	push	r22
    2918:	7f 93       	push	r23
    291a:	8f 93       	push	r24
    291c:	9f 93       	push	r25
    291e:	af 93       	push	r26
    2920:	bf 93       	push	r27
    2922:	ef 93       	push	r30
    2924:	ff 93       	push	r31
    2926:	df 93       	push	r29
    2928:	cf 93       	push	r28
    292a:	cd b7       	in	r28, 0x3d	; 61
    292c:	de b7       	in	r29, 0x3e	; 62
	if(t1_callBackPtr != NULL_PTR)
    292e:	80 91 aa 00 	lds	r24, 0x00AA
    2932:	90 91 ab 00 	lds	r25, 0x00AB
    2936:	00 97       	sbiw	r24, 0x00	; 0
    2938:	29 f0       	breq	.+10     	; 0x2944 <__vector_8+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*t1_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    293a:	e0 91 aa 00 	lds	r30, 0x00AA
    293e:	f0 91 ab 00 	lds	r31, 0x00AB
    2942:	09 95       	icall
	}
}
    2944:	cf 91       	pop	r28
    2946:	df 91       	pop	r29
    2948:	ff 91       	pop	r31
    294a:	ef 91       	pop	r30
    294c:	bf 91       	pop	r27
    294e:	af 91       	pop	r26
    2950:	9f 91       	pop	r25
    2952:	8f 91       	pop	r24
    2954:	7f 91       	pop	r23
    2956:	6f 91       	pop	r22
    2958:	5f 91       	pop	r21
    295a:	4f 91       	pop	r20
    295c:	3f 91       	pop	r19
    295e:	2f 91       	pop	r18
    2960:	0f 90       	pop	r0
    2962:	0f be       	out	0x3f, r0	; 63
    2964:	0f 90       	pop	r0
    2966:	1f 90       	pop	r1
    2968:	18 95       	reti

0000296a <__vector_6>:

ISR(TIMER1_COMPA_vect){
    296a:	1f 92       	push	r1
    296c:	0f 92       	push	r0
    296e:	0f b6       	in	r0, 0x3f	; 63
    2970:	0f 92       	push	r0
    2972:	11 24       	eor	r1, r1
    2974:	2f 93       	push	r18
    2976:	3f 93       	push	r19
    2978:	4f 93       	push	r20
    297a:	5f 93       	push	r21
    297c:	6f 93       	push	r22
    297e:	7f 93       	push	r23
    2980:	8f 93       	push	r24
    2982:	9f 93       	push	r25
    2984:	af 93       	push	r26
    2986:	bf 93       	push	r27
    2988:	ef 93       	push	r30
    298a:	ff 93       	push	r31
    298c:	df 93       	push	r29
    298e:	cf 93       	push	r28
    2990:	cd b7       	in	r28, 0x3d	; 61
    2992:	de b7       	in	r29, 0x3e	; 62
	if(t1_callBackPtr != NULL_PTR)
    2994:	80 91 aa 00 	lds	r24, 0x00AA
    2998:	90 91 ab 00 	lds	r25, 0x00AB
    299c:	00 97       	sbiw	r24, 0x00	; 0
    299e:	29 f0       	breq	.+10     	; 0x29aa <__vector_6+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*t1_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    29a0:	e0 91 aa 00 	lds	r30, 0x00AA
    29a4:	f0 91 ab 00 	lds	r31, 0x00AB
    29a8:	09 95       	icall
	}
}
    29aa:	cf 91       	pop	r28
    29ac:	df 91       	pop	r29
    29ae:	ff 91       	pop	r31
    29b0:	ef 91       	pop	r30
    29b2:	bf 91       	pop	r27
    29b4:	af 91       	pop	r26
    29b6:	9f 91       	pop	r25
    29b8:	8f 91       	pop	r24
    29ba:	7f 91       	pop	r23
    29bc:	6f 91       	pop	r22
    29be:	5f 91       	pop	r21
    29c0:	4f 91       	pop	r20
    29c2:	3f 91       	pop	r19
    29c4:	2f 91       	pop	r18
    29c6:	0f 90       	pop	r0
    29c8:	0f be       	out	0x3f, r0	; 63
    29ca:	0f 90       	pop	r0
    29cc:	1f 90       	pop	r1
    29ce:	18 95       	reti

000029d0 <__vector_4>:

ISR(TIMER2_OVF_vect){
    29d0:	1f 92       	push	r1
    29d2:	0f 92       	push	r0
    29d4:	0f b6       	in	r0, 0x3f	; 63
    29d6:	0f 92       	push	r0
    29d8:	11 24       	eor	r1, r1
    29da:	2f 93       	push	r18
    29dc:	3f 93       	push	r19
    29de:	4f 93       	push	r20
    29e0:	5f 93       	push	r21
    29e2:	6f 93       	push	r22
    29e4:	7f 93       	push	r23
    29e6:	8f 93       	push	r24
    29e8:	9f 93       	push	r25
    29ea:	af 93       	push	r26
    29ec:	bf 93       	push	r27
    29ee:	ef 93       	push	r30
    29f0:	ff 93       	push	r31
    29f2:	df 93       	push	r29
    29f4:	cf 93       	push	r28
    29f6:	cd b7       	in	r28, 0x3d	; 61
    29f8:	de b7       	in	r29, 0x3e	; 62
	if(t2_callBackPtr != NULL_PTR)
    29fa:	80 91 ac 00 	lds	r24, 0x00AC
    29fe:	90 91 ad 00 	lds	r25, 0x00AD
    2a02:	00 97       	sbiw	r24, 0x00	; 0
    2a04:	29 f0       	breq	.+10     	; 0x2a10 <__vector_4+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*t2_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    2a06:	e0 91 ac 00 	lds	r30, 0x00AC
    2a0a:	f0 91 ad 00 	lds	r31, 0x00AD
    2a0e:	09 95       	icall
	}
}
    2a10:	cf 91       	pop	r28
    2a12:	df 91       	pop	r29
    2a14:	ff 91       	pop	r31
    2a16:	ef 91       	pop	r30
    2a18:	bf 91       	pop	r27
    2a1a:	af 91       	pop	r26
    2a1c:	9f 91       	pop	r25
    2a1e:	8f 91       	pop	r24
    2a20:	7f 91       	pop	r23
    2a22:	6f 91       	pop	r22
    2a24:	5f 91       	pop	r21
    2a26:	4f 91       	pop	r20
    2a28:	3f 91       	pop	r19
    2a2a:	2f 91       	pop	r18
    2a2c:	0f 90       	pop	r0
    2a2e:	0f be       	out	0x3f, r0	; 63
    2a30:	0f 90       	pop	r0
    2a32:	1f 90       	pop	r1
    2a34:	18 95       	reti

00002a36 <__vector_3>:

ISR(TIMER2_COMP_vect){
    2a36:	1f 92       	push	r1
    2a38:	0f 92       	push	r0
    2a3a:	0f b6       	in	r0, 0x3f	; 63
    2a3c:	0f 92       	push	r0
    2a3e:	11 24       	eor	r1, r1
    2a40:	2f 93       	push	r18
    2a42:	3f 93       	push	r19
    2a44:	4f 93       	push	r20
    2a46:	5f 93       	push	r21
    2a48:	6f 93       	push	r22
    2a4a:	7f 93       	push	r23
    2a4c:	8f 93       	push	r24
    2a4e:	9f 93       	push	r25
    2a50:	af 93       	push	r26
    2a52:	bf 93       	push	r27
    2a54:	ef 93       	push	r30
    2a56:	ff 93       	push	r31
    2a58:	df 93       	push	r29
    2a5a:	cf 93       	push	r28
    2a5c:	cd b7       	in	r28, 0x3d	; 61
    2a5e:	de b7       	in	r29, 0x3e	; 62
	if(t2_callBackPtr != NULL_PTR)
    2a60:	80 91 ac 00 	lds	r24, 0x00AC
    2a64:	90 91 ad 00 	lds	r25, 0x00AD
    2a68:	00 97       	sbiw	r24, 0x00	; 0
    2a6a:	29 f0       	breq	.+10     	; 0x2a76 <__vector_3+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*t2_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    2a6c:	e0 91 ac 00 	lds	r30, 0x00AC
    2a70:	f0 91 ad 00 	lds	r31, 0x00AD
    2a74:	09 95       	icall
	}
}
    2a76:	cf 91       	pop	r28
    2a78:	df 91       	pop	r29
    2a7a:	ff 91       	pop	r31
    2a7c:	ef 91       	pop	r30
    2a7e:	bf 91       	pop	r27
    2a80:	af 91       	pop	r26
    2a82:	9f 91       	pop	r25
    2a84:	8f 91       	pop	r24
    2a86:	7f 91       	pop	r23
    2a88:	6f 91       	pop	r22
    2a8a:	5f 91       	pop	r21
    2a8c:	4f 91       	pop	r20
    2a8e:	3f 91       	pop	r19
    2a90:	2f 91       	pop	r18
    2a92:	0f 90       	pop	r0
    2a94:	0f be       	out	0x3f, r0	; 63
    2a96:	0f 90       	pop	r0
    2a98:	1f 90       	pop	r1
    2a9a:	18 95       	reti

00002a9c <Timer_Init>:



void Timer_Init(const Timer_ConfigType * Config_Ptr){
    2a9c:	df 93       	push	r29
    2a9e:	cf 93       	push	r28
    2aa0:	00 d0       	rcall	.+0      	; 0x2aa2 <Timer_Init+0x6>
    2aa2:	cd b7       	in	r28, 0x3d	; 61
    2aa4:	de b7       	in	r29, 0x3e	; 62
    2aa6:	9a 83       	std	Y+2, r25	; 0x02
    2aa8:	89 83       	std	Y+1, r24	; 0x01

	if(Config_Ptr->Timer_number == 0){
    2aaa:	e9 81       	ldd	r30, Y+1	; 0x01
    2aac:	fa 81       	ldd	r31, Y+2	; 0x02
    2aae:	80 81       	ld	r24, Z
    2ab0:	88 23       	and	r24, r24
    2ab2:	09 f0       	breq	.+2      	; 0x2ab6 <Timer_Init+0x1a>
    2ab4:	4c c0       	rjmp	.+152    	; 0x2b4e <Timer_Init+0xb2>
		TCNT0 = (uint8)(Config_Ptr->iValue);
    2ab6:	a2 e5       	ldi	r26, 0x52	; 82
    2ab8:	b0 e0       	ldi	r27, 0x00	; 0
    2aba:	e9 81       	ldd	r30, Y+1	; 0x01
    2abc:	fa 81       	ldd	r31, Y+2	; 0x02
    2abe:	82 81       	ldd	r24, Z+2	; 0x02
    2ac0:	93 81       	ldd	r25, Z+3	; 0x03
    2ac2:	8c 93       	st	X, r24
		TCCR0 = (TCCR0 & 0xF8) | ((Config_Ptr->clock));
    2ac4:	a3 e5       	ldi	r26, 0x53	; 83
    2ac6:	b0 e0       	ldi	r27, 0x00	; 0
    2ac8:	e3 e5       	ldi	r30, 0x53	; 83
    2aca:	f0 e0       	ldi	r31, 0x00	; 0
    2acc:	80 81       	ld	r24, Z
    2ace:	98 2f       	mov	r25, r24
    2ad0:	98 7f       	andi	r25, 0xF8	; 248
    2ad2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad6:	86 81       	ldd	r24, Z+6	; 0x06
    2ad8:	89 2b       	or	r24, r25
    2ada:	8c 93       	st	X, r24

		if(Config_Ptr->mode == overFlow){
    2adc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ade:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae0:	81 81       	ldd	r24, Z+1	; 0x01
    2ae2:	88 23       	and	r24, r24
    2ae4:	99 f4       	brne	.+38     	; 0x2b0c <Timer_Init+0x70>
			CLEAR_BIT(TCCR0,WGM01);
    2ae6:	a3 e5       	ldi	r26, 0x53	; 83
    2ae8:	b0 e0       	ldi	r27, 0x00	; 0
    2aea:	e3 e5       	ldi	r30, 0x53	; 83
    2aec:	f0 e0       	ldi	r31, 0x00	; 0
    2aee:	80 81       	ld	r24, Z
    2af0:	87 7f       	andi	r24, 0xF7	; 247
    2af2:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR0,WGM00);
    2af4:	a3 e5       	ldi	r26, 0x53	; 83
    2af6:	b0 e0       	ldi	r27, 0x00	; 0
    2af8:	e3 e5       	ldi	r30, 0x53	; 83
    2afa:	f0 e0       	ldi	r31, 0x00	; 0
    2afc:	80 81       	ld	r24, Z
    2afe:	8f 7b       	andi	r24, 0xBF	; 191
    2b00:	8c 93       	st	X, r24
			TIMSK = (1<<TOIE0);
    2b02:	e9 e5       	ldi	r30, 0x59	; 89
    2b04:	f0 e0       	ldi	r31, 0x00	; 0
    2b06:	81 e0       	ldi	r24, 0x01	; 1
    2b08:	80 83       	st	Z, r24
    2b0a:	21 c0       	rjmp	.+66     	; 0x2b4e <Timer_Init+0xb2>
		}
		else if(Config_Ptr->mode == compare){
    2b0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b10:	81 81       	ldd	r24, Z+1	; 0x01
    2b12:	81 30       	cpi	r24, 0x01	; 1
    2b14:	e1 f4       	brne	.+56     	; 0x2b4e <Timer_Init+0xb2>
			SET_BIT(TCCR0,WGM01);
    2b16:	a3 e5       	ldi	r26, 0x53	; 83
    2b18:	b0 e0       	ldi	r27, 0x00	; 0
    2b1a:	e3 e5       	ldi	r30, 0x53	; 83
    2b1c:	f0 e0       	ldi	r31, 0x00	; 0
    2b1e:	80 81       	ld	r24, Z
    2b20:	88 60       	ori	r24, 0x08	; 8
    2b22:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR0,WGM00);
    2b24:	a3 e5       	ldi	r26, 0x53	; 83
    2b26:	b0 e0       	ldi	r27, 0x00	; 0
    2b28:	e3 e5       	ldi	r30, 0x53	; 83
    2b2a:	f0 e0       	ldi	r31, 0x00	; 0
    2b2c:	80 81       	ld	r24, Z
    2b2e:	8f 7b       	andi	r24, 0xBF	; 191
    2b30:	8c 93       	st	X, r24
			OCR0 = Config_Ptr->compValue;
    2b32:	ac e5       	ldi	r26, 0x5C	; 92
    2b34:	b0 e0       	ldi	r27, 0x00	; 0
    2b36:	e9 81       	ldd	r30, Y+1	; 0x01
    2b38:	fa 81       	ldd	r31, Y+2	; 0x02
    2b3a:	84 81       	ldd	r24, Z+4	; 0x04
    2b3c:	95 81       	ldd	r25, Z+5	; 0x05
    2b3e:	8c 93       	st	X, r24
			TIMSK |= (1<<OCIE0);
    2b40:	a9 e5       	ldi	r26, 0x59	; 89
    2b42:	b0 e0       	ldi	r27, 0x00	; 0
    2b44:	e9 e5       	ldi	r30, 0x59	; 89
    2b46:	f0 e0       	ldi	r31, 0x00	; 0
    2b48:	80 81       	ld	r24, Z
    2b4a:	82 60       	ori	r24, 0x02	; 2
    2b4c:	8c 93       	st	X, r24
		}

	}

	if(Config_Ptr->Timer_number == 1){
    2b4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b50:	fa 81       	ldd	r31, Y+2	; 0x02
    2b52:	80 81       	ld	r24, Z
    2b54:	81 30       	cpi	r24, 0x01	; 1
    2b56:	09 f0       	breq	.+2      	; 0x2b5a <Timer_Init+0xbe>
    2b58:	73 c0       	rjmp	.+230    	; 0x2c40 <Timer_Init+0x1a4>
		TCCR1B = (uint8)(TCCR1B & 0xF8) | ((Config_Ptr->clock));
    2b5a:	ae e4       	ldi	r26, 0x4E	; 78
    2b5c:	b0 e0       	ldi	r27, 0x00	; 0
    2b5e:	ee e4       	ldi	r30, 0x4E	; 78
    2b60:	f0 e0       	ldi	r31, 0x00	; 0
    2b62:	80 81       	ld	r24, Z
    2b64:	98 2f       	mov	r25, r24
    2b66:	98 7f       	andi	r25, 0xF8	; 248
    2b68:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b6c:	86 81       	ldd	r24, Z+6	; 0x06
    2b6e:	89 2b       	or	r24, r25
    2b70:	8c 93       	st	X, r24
		TCNT1 = Config_Ptr->iValue;
    2b72:	ac e4       	ldi	r26, 0x4C	; 76
    2b74:	b0 e0       	ldi	r27, 0x00	; 0
    2b76:	e9 81       	ldd	r30, Y+1	; 0x01
    2b78:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7a:	82 81       	ldd	r24, Z+2	; 0x02
    2b7c:	93 81       	ldd	r25, Z+3	; 0x03
    2b7e:	11 96       	adiw	r26, 0x01	; 1
    2b80:	9c 93       	st	X, r25
    2b82:	8e 93       	st	-X, r24
		if(Config_Ptr->mode == overFlow){
    2b84:	e9 81       	ldd	r30, Y+1	; 0x01
    2b86:	fa 81       	ldd	r31, Y+2	; 0x02
    2b88:	81 81       	ldd	r24, Z+1	; 0x01
    2b8a:	88 23       	and	r24, r24
    2b8c:	09 f5       	brne	.+66     	; 0x2bd0 <Timer_Init+0x134>
			CLEAR_BIT(TCCR1A,WGM11);
    2b8e:	af e4       	ldi	r26, 0x4F	; 79
    2b90:	b0 e0       	ldi	r27, 0x00	; 0
    2b92:	ef e4       	ldi	r30, 0x4F	; 79
    2b94:	f0 e0       	ldi	r31, 0x00	; 0
    2b96:	80 81       	ld	r24, Z
    2b98:	8d 7f       	andi	r24, 0xFD	; 253
    2b9a:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR1A,WGM10);
    2b9c:	af e4       	ldi	r26, 0x4F	; 79
    2b9e:	b0 e0       	ldi	r27, 0x00	; 0
    2ba0:	ef e4       	ldi	r30, 0x4F	; 79
    2ba2:	f0 e0       	ldi	r31, 0x00	; 0
    2ba4:	80 81       	ld	r24, Z
    2ba6:	8e 7f       	andi	r24, 0xFE	; 254
    2ba8:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR1B,WGM12);
    2baa:	ae e4       	ldi	r26, 0x4E	; 78
    2bac:	b0 e0       	ldi	r27, 0x00	; 0
    2bae:	ee e4       	ldi	r30, 0x4E	; 78
    2bb0:	f0 e0       	ldi	r31, 0x00	; 0
    2bb2:	80 81       	ld	r24, Z
    2bb4:	87 7f       	andi	r24, 0xF7	; 247
    2bb6:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR1B,WGM13);
    2bb8:	ae e4       	ldi	r26, 0x4E	; 78
    2bba:	b0 e0       	ldi	r27, 0x00	; 0
    2bbc:	ee e4       	ldi	r30, 0x4E	; 78
    2bbe:	f0 e0       	ldi	r31, 0x00	; 0
    2bc0:	80 81       	ld	r24, Z
    2bc2:	8f 7e       	andi	r24, 0xEF	; 239
    2bc4:	8c 93       	st	X, r24
			TIMSK = (1<<TOIE1);
    2bc6:	e9 e5       	ldi	r30, 0x59	; 89
    2bc8:	f0 e0       	ldi	r31, 0x00	; 0
    2bca:	84 e0       	ldi	r24, 0x04	; 4
    2bcc:	80 83       	st	Z, r24
    2bce:	38 c0       	rjmp	.+112    	; 0x2c40 <Timer_Init+0x1a4>
		}
		else if(Config_Ptr->mode == compare){
    2bd0:	e9 81       	ldd	r30, Y+1	; 0x01
    2bd2:	fa 81       	ldd	r31, Y+2	; 0x02
    2bd4:	81 81       	ldd	r24, Z+1	; 0x01
    2bd6:	81 30       	cpi	r24, 0x01	; 1
    2bd8:	99 f5       	brne	.+102    	; 0x2c40 <Timer_Init+0x1a4>
			CLEAR_BIT(TCCR1A,WGM11);
    2bda:	af e4       	ldi	r26, 0x4F	; 79
    2bdc:	b0 e0       	ldi	r27, 0x00	; 0
    2bde:	ef e4       	ldi	r30, 0x4F	; 79
    2be0:	f0 e0       	ldi	r31, 0x00	; 0
    2be2:	80 81       	ld	r24, Z
    2be4:	8d 7f       	andi	r24, 0xFD	; 253
    2be6:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR1A,WGM10);
    2be8:	af e4       	ldi	r26, 0x4F	; 79
    2bea:	b0 e0       	ldi	r27, 0x00	; 0
    2bec:	ef e4       	ldi	r30, 0x4F	; 79
    2bee:	f0 e0       	ldi	r31, 0x00	; 0
    2bf0:	80 81       	ld	r24, Z
    2bf2:	8e 7f       	andi	r24, 0xFE	; 254
    2bf4:	8c 93       	st	X, r24
			SET_BIT(TCCR1B,WGM12);
    2bf6:	ae e4       	ldi	r26, 0x4E	; 78
    2bf8:	b0 e0       	ldi	r27, 0x00	; 0
    2bfa:	ee e4       	ldi	r30, 0x4E	; 78
    2bfc:	f0 e0       	ldi	r31, 0x00	; 0
    2bfe:	80 81       	ld	r24, Z
    2c00:	88 60       	ori	r24, 0x08	; 8
    2c02:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR1B,WGM13);
    2c04:	ae e4       	ldi	r26, 0x4E	; 78
    2c06:	b0 e0       	ldi	r27, 0x00	; 0
    2c08:	ee e4       	ldi	r30, 0x4E	; 78
    2c0a:	f0 e0       	ldi	r31, 0x00	; 0
    2c0c:	80 81       	ld	r24, Z
    2c0e:	8f 7e       	andi	r24, 0xEF	; 239
    2c10:	8c 93       	st	X, r24
			TIMSK |= (1<<OCIE1A);
    2c12:	a9 e5       	ldi	r26, 0x59	; 89
    2c14:	b0 e0       	ldi	r27, 0x00	; 0
    2c16:	e9 e5       	ldi	r30, 0x59	; 89
    2c18:	f0 e0       	ldi	r31, 0x00	; 0
    2c1a:	80 81       	ld	r24, Z
    2c1c:	80 61       	ori	r24, 0x10	; 16
    2c1e:	8c 93       	st	X, r24
			TIMSK |= (1<<OCIE1B);
    2c20:	a9 e5       	ldi	r26, 0x59	; 89
    2c22:	b0 e0       	ldi	r27, 0x00	; 0
    2c24:	e9 e5       	ldi	r30, 0x59	; 89
    2c26:	f0 e0       	ldi	r31, 0x00	; 0
    2c28:	80 81       	ld	r24, Z
    2c2a:	88 60       	ori	r24, 0x08	; 8
    2c2c:	8c 93       	st	X, r24
			OCR1A = Config_Ptr->compValue;
    2c2e:	aa e4       	ldi	r26, 0x4A	; 74
    2c30:	b0 e0       	ldi	r27, 0x00	; 0
    2c32:	e9 81       	ldd	r30, Y+1	; 0x01
    2c34:	fa 81       	ldd	r31, Y+2	; 0x02
    2c36:	84 81       	ldd	r24, Z+4	; 0x04
    2c38:	95 81       	ldd	r25, Z+5	; 0x05
    2c3a:	11 96       	adiw	r26, 0x01	; 1
    2c3c:	9c 93       	st	X, r25
    2c3e:	8e 93       	st	-X, r24
		}

	}

	if(Config_Ptr->Timer_number == 2){
    2c40:	e9 81       	ldd	r30, Y+1	; 0x01
    2c42:	fa 81       	ldd	r31, Y+2	; 0x02
    2c44:	80 81       	ld	r24, Z
    2c46:	82 30       	cpi	r24, 0x02	; 2
    2c48:	09 f0       	breq	.+2      	; 0x2c4c <Timer_Init+0x1b0>
    2c4a:	53 c0       	rjmp	.+166    	; 0x2cf2 <Timer_Init+0x256>
		TCNT2 = (uint8)Config_Ptr->iValue;
    2c4c:	a4 e4       	ldi	r26, 0x44	; 68
    2c4e:	b0 e0       	ldi	r27, 0x00	; 0
    2c50:	e9 81       	ldd	r30, Y+1	; 0x01
    2c52:	fa 81       	ldd	r31, Y+2	; 0x02
    2c54:	82 81       	ldd	r24, Z+2	; 0x02
    2c56:	93 81       	ldd	r25, Z+3	; 0x03
    2c58:	8c 93       	st	X, r24
		TCCR2 = (TCCR2 & 0xF8) | ((Config_Ptr->clock));
    2c5a:	a5 e4       	ldi	r26, 0x45	; 69
    2c5c:	b0 e0       	ldi	r27, 0x00	; 0
    2c5e:	e5 e4       	ldi	r30, 0x45	; 69
    2c60:	f0 e0       	ldi	r31, 0x00	; 0
    2c62:	80 81       	ld	r24, Z
    2c64:	98 2f       	mov	r25, r24
    2c66:	98 7f       	andi	r25, 0xF8	; 248
    2c68:	e9 81       	ldd	r30, Y+1	; 0x01
    2c6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c6c:	86 81       	ldd	r24, Z+6	; 0x06
    2c6e:	89 2b       	or	r24, r25
    2c70:	8c 93       	st	X, r24

		if(Config_Ptr->mode == overFlow){
    2c72:	e9 81       	ldd	r30, Y+1	; 0x01
    2c74:	fa 81       	ldd	r31, Y+2	; 0x02
    2c76:	81 81       	ldd	r24, Z+1	; 0x01
    2c78:	88 23       	and	r24, r24
    2c7a:	d1 f4       	brne	.+52     	; 0x2cb0 <Timer_Init+0x214>
			CLEAR_BIT(TCCR2,WGM21);
    2c7c:	a5 e4       	ldi	r26, 0x45	; 69
    2c7e:	b0 e0       	ldi	r27, 0x00	; 0
    2c80:	e5 e4       	ldi	r30, 0x45	; 69
    2c82:	f0 e0       	ldi	r31, 0x00	; 0
    2c84:	80 81       	ld	r24, Z
    2c86:	87 7f       	andi	r24, 0xF7	; 247
    2c88:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR2,WGM20);
    2c8a:	a5 e4       	ldi	r26, 0x45	; 69
    2c8c:	b0 e0       	ldi	r27, 0x00	; 0
    2c8e:	e5 e4       	ldi	r30, 0x45	; 69
    2c90:	f0 e0       	ldi	r31, 0x00	; 0
    2c92:	80 81       	ld	r24, Z
    2c94:	8f 7b       	andi	r24, 0xBF	; 191
    2c96:	8c 93       	st	X, r24
			TIMSK = (1<<TOIE2);
    2c98:	e9 e5       	ldi	r30, 0x59	; 89
    2c9a:	f0 e0       	ldi	r31, 0x00	; 0
    2c9c:	80 e4       	ldi	r24, 0x40	; 64
    2c9e:	80 83       	st	Z, r24
			SET_BIT(TIFR,TOV2);
    2ca0:	a8 e5       	ldi	r26, 0x58	; 88
    2ca2:	b0 e0       	ldi	r27, 0x00	; 0
    2ca4:	e8 e5       	ldi	r30, 0x58	; 88
    2ca6:	f0 e0       	ldi	r31, 0x00	; 0
    2ca8:	80 81       	ld	r24, Z
    2caa:	80 64       	ori	r24, 0x40	; 64
    2cac:	8c 93       	st	X, r24
    2cae:	21 c0       	rjmp	.+66     	; 0x2cf2 <Timer_Init+0x256>

		}
		else if(Config_Ptr->mode == compare){
    2cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    2cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    2cb4:	81 81       	ldd	r24, Z+1	; 0x01
    2cb6:	81 30       	cpi	r24, 0x01	; 1
    2cb8:	e1 f4       	brne	.+56     	; 0x2cf2 <Timer_Init+0x256>
			SET_BIT(TCCR2,WGM21);
    2cba:	a5 e4       	ldi	r26, 0x45	; 69
    2cbc:	b0 e0       	ldi	r27, 0x00	; 0
    2cbe:	e5 e4       	ldi	r30, 0x45	; 69
    2cc0:	f0 e0       	ldi	r31, 0x00	; 0
    2cc2:	80 81       	ld	r24, Z
    2cc4:	88 60       	ori	r24, 0x08	; 8
    2cc6:	8c 93       	st	X, r24
			CLEAR_BIT(TCCR2,WGM20);
    2cc8:	a5 e4       	ldi	r26, 0x45	; 69
    2cca:	b0 e0       	ldi	r27, 0x00	; 0
    2ccc:	e5 e4       	ldi	r30, 0x45	; 69
    2cce:	f0 e0       	ldi	r31, 0x00	; 0
    2cd0:	80 81       	ld	r24, Z
    2cd2:	8f 7b       	andi	r24, 0xBF	; 191
    2cd4:	8c 93       	st	X, r24
			OCR2 = Config_Ptr->compValue;
    2cd6:	a3 e4       	ldi	r26, 0x43	; 67
    2cd8:	b0 e0       	ldi	r27, 0x00	; 0
    2cda:	e9 81       	ldd	r30, Y+1	; 0x01
    2cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    2cde:	84 81       	ldd	r24, Z+4	; 0x04
    2ce0:	95 81       	ldd	r25, Z+5	; 0x05
    2ce2:	8c 93       	st	X, r24
			TIMSK |= (1<<OCIE2);
    2ce4:	a9 e5       	ldi	r26, 0x59	; 89
    2ce6:	b0 e0       	ldi	r27, 0x00	; 0
    2ce8:	e9 e5       	ldi	r30, 0x59	; 89
    2cea:	f0 e0       	ldi	r31, 0x00	; 0
    2cec:	80 81       	ld	r24, Z
    2cee:	80 68       	ori	r24, 0x80	; 128
    2cf0:	8c 93       	st	X, r24
		}
	}
}
    2cf2:	0f 90       	pop	r0
    2cf4:	0f 90       	pop	r0
    2cf6:	cf 91       	pop	r28
    2cf8:	df 91       	pop	r29
    2cfa:	08 95       	ret

00002cfc <Timer_DeInit>:


void Timer_DeInit(void){
    2cfc:	df 93       	push	r29
    2cfe:	cf 93       	push	r28
    2d00:	cd b7       	in	r28, 0x3d	; 61
    2d02:	de b7       	in	r29, 0x3e	; 62
	TCNT0  = 0;
    2d04:	e2 e5       	ldi	r30, 0x52	; 82
    2d06:	f0 e0       	ldi	r31, 0x00	; 0
    2d08:	10 82       	st	Z, r1
	TCNT1  = 0;
    2d0a:	ec e4       	ldi	r30, 0x4C	; 76
    2d0c:	f0 e0       	ldi	r31, 0x00	; 0
    2d0e:	11 82       	std	Z+1, r1	; 0x01
    2d10:	10 82       	st	Z, r1
	TCNT2  = 0;
    2d12:	e4 e4       	ldi	r30, 0x44	; 68
    2d14:	f0 e0       	ldi	r31, 0x00	; 0
    2d16:	10 82       	st	Z, r1
	TCCR0  = 0;
    2d18:	e3 e5       	ldi	r30, 0x53	; 83
    2d1a:	f0 e0       	ldi	r31, 0x00	; 0
    2d1c:	10 82       	st	Z, r1
	TCCR2  = 0;
    2d1e:	e5 e4       	ldi	r30, 0x45	; 69
    2d20:	f0 e0       	ldi	r31, 0x00	; 0
    2d22:	10 82       	st	Z, r1
	TIMSK &= 0X20;  //due to ICU bit
    2d24:	a9 e5       	ldi	r26, 0x59	; 89
    2d26:	b0 e0       	ldi	r27, 0x00	; 0
    2d28:	e9 e5       	ldi	r30, 0x59	; 89
    2d2a:	f0 e0       	ldi	r31, 0x00	; 0
    2d2c:	80 81       	ld	r24, Z
    2d2e:	80 72       	andi	r24, 0x20	; 32
    2d30:	8c 93       	st	X, r24
	OCR0   = 0;
    2d32:	ec e5       	ldi	r30, 0x5C	; 92
    2d34:	f0 e0       	ldi	r31, 0x00	; 0
    2d36:	10 82       	st	Z, r1
	OCR2   = 0;
    2d38:	e3 e4       	ldi	r30, 0x43	; 67
    2d3a:	f0 e0       	ldi	r31, 0x00	; 0
    2d3c:	10 82       	st	Z, r1
	TCCR1B = 0;
    2d3e:	ee e4       	ldi	r30, 0x4E	; 78
    2d40:	f0 e0       	ldi	r31, 0x00	; 0
    2d42:	10 82       	st	Z, r1
	TCCR1A = 0;
    2d44:	ef e4       	ldi	r30, 0x4F	; 79
    2d46:	f0 e0       	ldi	r31, 0x00	; 0
    2d48:	10 82       	st	Z, r1
}
    2d4a:	cf 91       	pop	r28
    2d4c:	df 91       	pop	r29
    2d4e:	08 95       	ret

00002d50 <Timer0_SetCallBack>:

void Timer0_SetCallBack(void(*a0_ptr)(void)){
    2d50:	df 93       	push	r29
    2d52:	cf 93       	push	r28
    2d54:	00 d0       	rcall	.+0      	; 0x2d56 <Timer0_SetCallBack+0x6>
    2d56:	cd b7       	in	r28, 0x3d	; 61
    2d58:	de b7       	in	r29, 0x3e	; 62
    2d5a:	9a 83       	std	Y+2, r25	; 0x02
    2d5c:	89 83       	std	Y+1, r24	; 0x01
	t0_callBackPtr = a0_ptr;
    2d5e:	89 81       	ldd	r24, Y+1	; 0x01
    2d60:	9a 81       	ldd	r25, Y+2	; 0x02
    2d62:	90 93 a9 00 	sts	0x00A9, r25
    2d66:	80 93 a8 00 	sts	0x00A8, r24
}
    2d6a:	0f 90       	pop	r0
    2d6c:	0f 90       	pop	r0
    2d6e:	cf 91       	pop	r28
    2d70:	df 91       	pop	r29
    2d72:	08 95       	ret

00002d74 <Timer1_SetCallBack>:

void Timer1_SetCallBack(void(*a1_ptr)(void)){
    2d74:	df 93       	push	r29
    2d76:	cf 93       	push	r28
    2d78:	00 d0       	rcall	.+0      	; 0x2d7a <Timer1_SetCallBack+0x6>
    2d7a:	cd b7       	in	r28, 0x3d	; 61
    2d7c:	de b7       	in	r29, 0x3e	; 62
    2d7e:	9a 83       	std	Y+2, r25	; 0x02
    2d80:	89 83       	std	Y+1, r24	; 0x01
	t1_callBackPtr = a1_ptr;
    2d82:	89 81       	ldd	r24, Y+1	; 0x01
    2d84:	9a 81       	ldd	r25, Y+2	; 0x02
    2d86:	90 93 ab 00 	sts	0x00AB, r25
    2d8a:	80 93 aa 00 	sts	0x00AA, r24
}
    2d8e:	0f 90       	pop	r0
    2d90:	0f 90       	pop	r0
    2d92:	cf 91       	pop	r28
    2d94:	df 91       	pop	r29
    2d96:	08 95       	ret

00002d98 <Timer2_SetCallBack>:

void Timer2_SetCallBack(void(*a2_ptr)(void)){
    2d98:	df 93       	push	r29
    2d9a:	cf 93       	push	r28
    2d9c:	00 d0       	rcall	.+0      	; 0x2d9e <Timer2_SetCallBack+0x6>
    2d9e:	cd b7       	in	r28, 0x3d	; 61
    2da0:	de b7       	in	r29, 0x3e	; 62
    2da2:	9a 83       	std	Y+2, r25	; 0x02
    2da4:	89 83       	std	Y+1, r24	; 0x01
	t2_callBackPtr = a2_ptr;
    2da6:	89 81       	ldd	r24, Y+1	; 0x01
    2da8:	9a 81       	ldd	r25, Y+2	; 0x02
    2daa:	90 93 ad 00 	sts	0x00AD, r25
    2dae:	80 93 ac 00 	sts	0x00AC, r24
}
    2db2:	0f 90       	pop	r0
    2db4:	0f 90       	pop	r0
    2db6:	cf 91       	pop	r28
    2db8:	df 91       	pop	r29
    2dba:	08 95       	ret

00002dbc <TWI_init>:
#include "math.h"
#include "common_macros.h"
#include <avr/io.h>

void TWI_init(const TWI_ConfigType *Config_Ptr)
{
    2dbc:	0f 93       	push	r16
    2dbe:	1f 93       	push	r17
    2dc0:	df 93       	push	r29
    2dc2:	cf 93       	push	r28
    2dc4:	00 d0       	rcall	.+0      	; 0x2dc6 <TWI_init+0xa>
    2dc6:	cd b7       	in	r28, 0x3d	; 61
    2dc8:	de b7       	in	r29, 0x3e	; 62
    2dca:	9a 83       	std	Y+2, r25	; 0x02
    2dcc:	89 83       	std	Y+1, r24	; 0x01
    TWBR = 8000000/( (Config_Ptr->Prescaler)*16);  /*according to the SCL Frequency equation with prescaler zero*/
    2dce:	00 e2       	ldi	r16, 0x20	; 32
    2dd0:	10 e0       	ldi	r17, 0x00	; 0
    2dd2:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd4:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd6:	80 81       	ld	r24, Z
    2dd8:	88 2f       	mov	r24, r24
    2dda:	90 e0       	ldi	r25, 0x00	; 0
    2ddc:	82 95       	swap	r24
    2dde:	92 95       	swap	r25
    2de0:	90 7f       	andi	r25, 0xF0	; 240
    2de2:	98 27       	eor	r25, r24
    2de4:	80 7f       	andi	r24, 0xF0	; 240
    2de6:	98 27       	eor	r25, r24
    2de8:	9c 01       	movw	r18, r24
    2dea:	44 27       	eor	r20, r20
    2dec:	37 fd       	sbrc	r19, 7
    2dee:	40 95       	com	r20
    2df0:	54 2f       	mov	r21, r20
    2df2:	80 e0       	ldi	r24, 0x00	; 0
    2df4:	92 e1       	ldi	r25, 0x12	; 18
    2df6:	aa e7       	ldi	r26, 0x7A	; 122
    2df8:	b0 e0       	ldi	r27, 0x00	; 0
    2dfa:	bc 01       	movw	r22, r24
    2dfc:	cd 01       	movw	r24, r26
    2dfe:	0e 94 b9 18 	call	0x3172	; 0x3172 <__divmodsi4>
    2e02:	da 01       	movw	r26, r20
    2e04:	c9 01       	movw	r24, r18
    2e06:	f8 01       	movw	r30, r16
    2e08:	80 83       	st	Z, r24
	TWSR = ((Config_Ptr->Prescaler));
    2e0a:	a1 e2       	ldi	r26, 0x21	; 33
    2e0c:	b0 e0       	ldi	r27, 0x00	; 0
    2e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e10:	fa 81       	ldd	r31, Y+2	; 0x02
    2e12:	80 81       	ld	r24, Z
    2e14:	8c 93       	st	X, r24

    /* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
       General Call Recognition: Off */
    TWAR = ((Config_Ptr->Slave_address<<1)); // my address = 0x01 :)
    2e16:	a2 e2       	ldi	r26, 0x22	; 34
    2e18:	b0 e0       	ldi	r27, 0x00	; 0
    2e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e1e:	85 81       	ldd	r24, Z+5	; 0x05
    2e20:	88 0f       	add	r24, r24
    2e22:	8c 93       	st	X, r24

    TWCR = (1<<TWEN); /* enable TWI */
    2e24:	e6 e5       	ldi	r30, 0x56	; 86
    2e26:	f0 e0       	ldi	r31, 0x00	; 0
    2e28:	84 e0       	ldi	r24, 0x04	; 4
    2e2a:	80 83       	st	Z, r24
}
    2e2c:	0f 90       	pop	r0
    2e2e:	0f 90       	pop	r0
    2e30:	cf 91       	pop	r28
    2e32:	df 91       	pop	r29
    2e34:	1f 91       	pop	r17
    2e36:	0f 91       	pop	r16
    2e38:	08 95       	ret

00002e3a <TWI_start>:

void TWI_start(void)
{
    2e3a:	df 93       	push	r29
    2e3c:	cf 93       	push	r28
    2e3e:	cd b7       	in	r28, 0x3d	; 61
    2e40:	de b7       	in	r29, 0x3e	; 62
    /* 
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    2e42:	e6 e5       	ldi	r30, 0x56	; 86
    2e44:	f0 e0       	ldi	r31, 0x00	; 0
    2e46:	84 ea       	ldi	r24, 0xA4	; 164
    2e48:	80 83       	st	Z, r24
    
    /* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    2e4a:	e6 e5       	ldi	r30, 0x56	; 86
    2e4c:	f0 e0       	ldi	r31, 0x00	; 0
    2e4e:	80 81       	ld	r24, Z
    2e50:	88 23       	and	r24, r24
    2e52:	dc f7       	brge	.-10     	; 0x2e4a <TWI_start+0x10>
}
    2e54:	cf 91       	pop	r28
    2e56:	df 91       	pop	r29
    2e58:	08 95       	ret

00002e5a <TWI_stop>:

void TWI_stop(void)
{
    2e5a:	df 93       	push	r29
    2e5c:	cf 93       	push	r28
    2e5e:	cd b7       	in	r28, 0x3d	; 61
    2e60:	de b7       	in	r29, 0x3e	; 62
    /* 
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
    2e62:	e6 e5       	ldi	r30, 0x56	; 86
    2e64:	f0 e0       	ldi	r31, 0x00	; 0
    2e66:	84 e9       	ldi	r24, 0x94	; 148
    2e68:	80 83       	st	Z, r24
}
    2e6a:	cf 91       	pop	r28
    2e6c:	df 91       	pop	r29
    2e6e:	08 95       	ret

00002e70 <TWI_writeByte>:

void TWI_writeByte(uint8 data)
{
    2e70:	df 93       	push	r29
    2e72:	cf 93       	push	r28
    2e74:	0f 92       	push	r0
    2e76:	cd b7       	in	r28, 0x3d	; 61
    2e78:	de b7       	in	r29, 0x3e	; 62
    2e7a:	89 83       	std	Y+1, r24	; 0x01
    /* Put data On TWI data Register */
    TWDR = data;
    2e7c:	e3 e2       	ldi	r30, 0x23	; 35
    2e7e:	f0 e0       	ldi	r31, 0x00	; 0
    2e80:	89 81       	ldd	r24, Y+1	; 0x01
    2e82:	80 83       	st	Z, r24
    /* 
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1 
	 */ 
    TWCR = (1 << TWINT) | (1 << TWEN);
    2e84:	e6 e5       	ldi	r30, 0x56	; 86
    2e86:	f0 e0       	ldi	r31, 0x00	; 0
    2e88:	84 e8       	ldi	r24, 0x84	; 132
    2e8a:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register(data is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    2e8c:	e6 e5       	ldi	r30, 0x56	; 86
    2e8e:	f0 e0       	ldi	r31, 0x00	; 0
    2e90:	80 81       	ld	r24, Z
    2e92:	88 23       	and	r24, r24
    2e94:	dc f7       	brge	.-10     	; 0x2e8c <TWI_writeByte+0x1c>
}
    2e96:	0f 90       	pop	r0
    2e98:	cf 91       	pop	r28
    2e9a:	df 91       	pop	r29
    2e9c:	08 95       	ret

00002e9e <TWI_readByteWithACK>:

uint8 TWI_readByteWithACK(void)
{
    2e9e:	df 93       	push	r29
    2ea0:	cf 93       	push	r28
    2ea2:	cd b7       	in	r28, 0x3d	; 61
    2ea4:	de b7       	in	r29, 0x3e	; 62
	/* 
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable sending ACK after reading or receiving data TWEA=1
	 * Enable TWI Module TWEN=1 
	 */ 
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    2ea6:	e6 e5       	ldi	r30, 0x56	; 86
    2ea8:	f0 e0       	ldi	r31, 0x00	; 0
    2eaa:	84 ec       	ldi	r24, 0xC4	; 196
    2eac:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    2eae:	e6 e5       	ldi	r30, 0x56	; 86
    2eb0:	f0 e0       	ldi	r31, 0x00	; 0
    2eb2:	80 81       	ld	r24, Z
    2eb4:	88 23       	and	r24, r24
    2eb6:	dc f7       	brge	.-10     	; 0x2eae <TWI_readByteWithACK+0x10>
    /* Read Data */
    return TWDR;
    2eb8:	e3 e2       	ldi	r30, 0x23	; 35
    2eba:	f0 e0       	ldi	r31, 0x00	; 0
    2ebc:	80 81       	ld	r24, Z
}
    2ebe:	cf 91       	pop	r28
    2ec0:	df 91       	pop	r29
    2ec2:	08 95       	ret

00002ec4 <TWI_readByteWithNACK>:

uint8 TWI_readByteWithNACK(void)
{
    2ec4:	df 93       	push	r29
    2ec6:	cf 93       	push	r28
    2ec8:	cd b7       	in	r28, 0x3d	; 61
    2eca:	de b7       	in	r29, 0x3e	; 62
	/* 
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWEN);
    2ecc:	e6 e5       	ldi	r30, 0x56	; 86
    2ece:	f0 e0       	ldi	r31, 0x00	; 0
    2ed0:	84 e8       	ldi	r24, 0x84	; 132
    2ed2:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    2ed4:	e6 e5       	ldi	r30, 0x56	; 86
    2ed6:	f0 e0       	ldi	r31, 0x00	; 0
    2ed8:	80 81       	ld	r24, Z
    2eda:	88 23       	and	r24, r24
    2edc:	dc f7       	brge	.-10     	; 0x2ed4 <TWI_readByteWithNACK+0x10>
    /* Read Data */
    return TWDR;
    2ede:	e3 e2       	ldi	r30, 0x23	; 35
    2ee0:	f0 e0       	ldi	r31, 0x00	; 0
    2ee2:	80 81       	ld	r24, Z
}
    2ee4:	cf 91       	pop	r28
    2ee6:	df 91       	pop	r29
    2ee8:	08 95       	ret

00002eea <TWI_getStatus>:

uint8 TWI_getStatus(void)
{
    2eea:	df 93       	push	r29
    2eec:	cf 93       	push	r28
    2eee:	0f 92       	push	r0
    2ef0:	cd b7       	in	r28, 0x3d	; 61
    2ef2:	de b7       	in	r29, 0x3e	; 62
    uint8 status;
    /* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
    status = TWSR & 0xF8;
    2ef4:	e1 e2       	ldi	r30, 0x21	; 33
    2ef6:	f0 e0       	ldi	r31, 0x00	; 0
    2ef8:	80 81       	ld	r24, Z
    2efa:	88 7f       	andi	r24, 0xF8	; 248
    2efc:	89 83       	std	Y+1, r24	; 0x01
    return status;
    2efe:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f00:	0f 90       	pop	r0
    2f02:	cf 91       	pop	r28
    2f04:	df 91       	pop	r29
    2f06:	08 95       	ret

00002f08 <UART_init>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
    2f08:	df 93       	push	r29
    2f0a:	cf 93       	push	r28
    2f0c:	00 d0       	rcall	.+0      	; 0x2f0e <UART_init+0x6>
    2f0e:	00 d0       	rcall	.+0      	; 0x2f10 <UART_init+0x8>
    2f10:	cd b7       	in	r28, 0x3d	; 61
    2f12:	de b7       	in	r29, 0x3e	; 62
    2f14:	9c 83       	std	Y+4, r25	; 0x04
    2f16:	8b 83       	std	Y+3, r24	; 0x03
	uint16 ubrr_value = 0;
    2f18:	1a 82       	std	Y+2, r1	; 0x02
    2f1a:	19 82       	std	Y+1, r1	; 0x01

	/* U2X = 1 for double transmission speed */
	UCSRA = (1<<U2X);
    2f1c:	eb e2       	ldi	r30, 0x2B	; 43
    2f1e:	f0 e0       	ldi	r31, 0x00	; 0
    2f20:	82 e0       	ldi	r24, 0x02	; 2
    2f22:	80 83       	st	Z, r24
	 * RXEN  = 1 Receiver Enable
	 * RXEN  = 1 Transmitter Enable
	 * UCSZ2 = 0 For 8-bit data mode
	 * RXB8 & TXB8 not used for 8-bit data mode
	 ***********************************************************************/ 
	UCSRB = (1<<RXEN) | (1<<TXEN);
    2f24:	ea e2       	ldi	r30, 0x2A	; 42
    2f26:	f0 e0       	ldi	r31, 0x00	; 0
    2f28:	88 e1       	ldi	r24, 0x18	; 24
    2f2a:	80 83       	st	Z, r24
	 * UPM1:0  = 00 Disable parity bit
	 * USBS    = 0 One stop bit
	 * UCSZ1:0 = 11 For 8-bit data mode
	 * UCPOL   = 0 Used with the Synchronous operation only
	 ***********************************************************************/ 	
	UCSRC = (1<<URSEL);
    2f2c:	e0 e4       	ldi	r30, 0x40	; 64
    2f2e:	f0 e0       	ldi	r31, 0x00	; 0
    2f30:	80 e8       	ldi	r24, 0x80	; 128
    2f32:	80 83       	st	Z, r24
	UCSRC = (UCSRC & 0xF9) | ((Config_Ptr -> Data_bit << 1));
    2f34:	a0 e4       	ldi	r26, 0x40	; 64
    2f36:	b0 e0       	ldi	r27, 0x00	; 0
    2f38:	e0 e4       	ldi	r30, 0x40	; 64
    2f3a:	f0 e0       	ldi	r31, 0x00	; 0
    2f3c:	80 81       	ld	r24, Z
    2f3e:	28 2f       	mov	r18, r24
    2f40:	29 7f       	andi	r18, 0xF9	; 249
    2f42:	eb 81       	ldd	r30, Y+3	; 0x03
    2f44:	fc 81       	ldd	r31, Y+4	; 0x04
    2f46:	82 81       	ldd	r24, Z+2	; 0x02
    2f48:	88 2f       	mov	r24, r24
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	88 0f       	add	r24, r24
    2f4e:	99 1f       	adc	r25, r25
    2f50:	82 2b       	or	r24, r18
    2f52:	8c 93       	st	X, r24

	UCSRC = (UCSRC & 0xCF) | ((Config_Ptr -> parity_mode << 4));
    2f54:	a0 e4       	ldi	r26, 0x40	; 64
    2f56:	b0 e0       	ldi	r27, 0x00	; 0
    2f58:	e0 e4       	ldi	r30, 0x40	; 64
    2f5a:	f0 e0       	ldi	r31, 0x00	; 0
    2f5c:	80 81       	ld	r24, Z
    2f5e:	28 2f       	mov	r18, r24
    2f60:	2f 7c       	andi	r18, 0xCF	; 207
    2f62:	eb 81       	ldd	r30, Y+3	; 0x03
    2f64:	fc 81       	ldd	r31, Y+4	; 0x04
    2f66:	80 81       	ld	r24, Z
    2f68:	88 2f       	mov	r24, r24
    2f6a:	90 e0       	ldi	r25, 0x00	; 0
    2f6c:	82 95       	swap	r24
    2f6e:	92 95       	swap	r25
    2f70:	90 7f       	andi	r25, 0xF0	; 240
    2f72:	98 27       	eor	r25, r24
    2f74:	80 7f       	andi	r24, 0xF0	; 240
    2f76:	98 27       	eor	r25, r24
    2f78:	82 2b       	or	r24, r18
    2f7a:	8c 93       	st	X, r24
	UCSRC = (UCSRC & 0xF7) | ((Config_Ptr -> stop_Bit_num << 3));
    2f7c:	a0 e4       	ldi	r26, 0x40	; 64
    2f7e:	b0 e0       	ldi	r27, 0x00	; 0
    2f80:	e0 e4       	ldi	r30, 0x40	; 64
    2f82:	f0 e0       	ldi	r31, 0x00	; 0
    2f84:	80 81       	ld	r24, Z
    2f86:	28 2f       	mov	r18, r24
    2f88:	27 7f       	andi	r18, 0xF7	; 247
    2f8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f8e:	81 81       	ldd	r24, Z+1	; 0x01
    2f90:	88 2f       	mov	r24, r24
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	88 0f       	add	r24, r24
    2f96:	99 1f       	adc	r25, r25
    2f98:	88 0f       	add	r24, r24
    2f9a:	99 1f       	adc	r25, r25
    2f9c:	88 0f       	add	r24, r24
    2f9e:	99 1f       	adc	r25, r25
    2fa0:	82 2b       	or	r24, r18
    2fa2:	8c 93       	st	X, r24

	/* Calculate the UBRR register value */
	ubrr_value = (uint16)(((F_CPU / ((Config_Ptr -> Baud_Rate) * 8UL))) - 1);
    2fa4:	eb 81       	ldd	r30, Y+3	; 0x03
    2fa6:	fc 81       	ldd	r31, Y+4	; 0x04
    2fa8:	83 81       	ldd	r24, Z+3	; 0x03
    2faa:	94 81       	ldd	r25, Z+4	; 0x04
    2fac:	a5 81       	ldd	r26, Z+5	; 0x05
    2fae:	b6 81       	ldd	r27, Z+6	; 0x06
    2fb0:	88 0f       	add	r24, r24
    2fb2:	99 1f       	adc	r25, r25
    2fb4:	aa 1f       	adc	r26, r26
    2fb6:	bb 1f       	adc	r27, r27
    2fb8:	88 0f       	add	r24, r24
    2fba:	99 1f       	adc	r25, r25
    2fbc:	aa 1f       	adc	r26, r26
    2fbe:	bb 1f       	adc	r27, r27
    2fc0:	88 0f       	add	r24, r24
    2fc2:	99 1f       	adc	r25, r25
    2fc4:	aa 1f       	adc	r26, r26
    2fc6:	bb 1f       	adc	r27, r27
    2fc8:	9c 01       	movw	r18, r24
    2fca:	ad 01       	movw	r20, r26
    2fcc:	80 e4       	ldi	r24, 0x40	; 64
    2fce:	92 e4       	ldi	r25, 0x42	; 66
    2fd0:	af e0       	ldi	r26, 0x0F	; 15
    2fd2:	b0 e0       	ldi	r27, 0x00	; 0
    2fd4:	bc 01       	movw	r22, r24
    2fd6:	cd 01       	movw	r24, r26
    2fd8:	0e 94 97 18 	call	0x312e	; 0x312e <__udivmodsi4>
    2fdc:	da 01       	movw	r26, r20
    2fde:	c9 01       	movw	r24, r18
    2fe0:	01 97       	sbiw	r24, 0x01	; 1
    2fe2:	9a 83       	std	Y+2, r25	; 0x02
    2fe4:	89 83       	std	Y+1, r24	; 0x01

	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UBRRH = ubrr_value>>8;
    2fe6:	e0 e4       	ldi	r30, 0x40	; 64
    2fe8:	f0 e0       	ldi	r31, 0x00	; 0
    2fea:	89 81       	ldd	r24, Y+1	; 0x01
    2fec:	9a 81       	ldd	r25, Y+2	; 0x02
    2fee:	89 2f       	mov	r24, r25
    2ff0:	99 27       	eor	r25, r25
    2ff2:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
    2ff4:	e9 e2       	ldi	r30, 0x29	; 41
    2ff6:	f0 e0       	ldi	r31, 0x00	; 0
    2ff8:	89 81       	ldd	r24, Y+1	; 0x01
    2ffa:	80 83       	st	Z, r24
}
    2ffc:	0f 90       	pop	r0
    2ffe:	0f 90       	pop	r0
    3000:	0f 90       	pop	r0
    3002:	0f 90       	pop	r0
    3004:	cf 91       	pop	r28
    3006:	df 91       	pop	r29
    3008:	08 95       	ret

0000300a <UART_sendByte>:
/*
 * Description :
 * Functional responsible for send byte to another UART device.
 */
void UART_sendByte(const uint8 data)
{
    300a:	df 93       	push	r29
    300c:	cf 93       	push	r28
    300e:	0f 92       	push	r0
    3010:	cd b7       	in	r28, 0x3d	; 61
    3012:	de b7       	in	r29, 0x3e	; 62
    3014:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * UDRE flag is set when the Tx buffer (UDR) is empty and ready for
	 * transmitting a new byte so wait until this flag is set to one
	 */
	while(BIT_IS_CLEAR(UCSRA,UDRE)){}
    3016:	eb e2       	ldi	r30, 0x2B	; 43
    3018:	f0 e0       	ldi	r31, 0x00	; 0
    301a:	80 81       	ld	r24, Z
    301c:	88 2f       	mov	r24, r24
    301e:	90 e0       	ldi	r25, 0x00	; 0
    3020:	80 72       	andi	r24, 0x20	; 32
    3022:	90 70       	andi	r25, 0x00	; 0
    3024:	00 97       	sbiw	r24, 0x00	; 0
    3026:	b9 f3       	breq	.-18     	; 0x3016 <UART_sendByte+0xc>

	/*
	 * Put the required data in the UDR register and it also clear the UDRE flag as
	 * the UDR register is not empty now
	 */
	UDR = data;
    3028:	ec e2       	ldi	r30, 0x2C	; 44
    302a:	f0 e0       	ldi	r31, 0x00	; 0
    302c:	89 81       	ldd	r24, Y+1	; 0x01
    302e:	80 83       	st	Z, r24
	/************************* Another Method *************************
	UDR = data;
	while(BIT_IS_CLEAR(UCSRA,TXC)){} // Wait until the transmission is complete TXC = 1
	SET_BIT(UCSRA,TXC); // Clear the TXC flag
	 *******************************************************************/
}
    3030:	0f 90       	pop	r0
    3032:	cf 91       	pop	r28
    3034:	df 91       	pop	r29
    3036:	08 95       	ret

00003038 <UART_recieveByte>:
/*
 * Description :
 * Functional responsible for receive byte from another UART device.
 */
uint8 UART_recieveByte(void)
{
    3038:	df 93       	push	r29
    303a:	cf 93       	push	r28
    303c:	cd b7       	in	r28, 0x3d	; 61
    303e:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this flag is set to one */
	while(BIT_IS_CLEAR(UCSRA,RXC)){}
    3040:	eb e2       	ldi	r30, 0x2B	; 43
    3042:	f0 e0       	ldi	r31, 0x00	; 0
    3044:	80 81       	ld	r24, Z
    3046:	88 23       	and	r24, r24
    3048:	dc f7       	brge	.-10     	; 0x3040 <UART_recieveByte+0x8>

	/*
	 * Read the received data from the Rx buffer (UDR)
	 * The RXC flag will be cleared after read the data
	 */
	return UDR;
    304a:	ec e2       	ldi	r30, 0x2C	; 44
    304c:	f0 e0       	ldi	r31, 0x00	; 0
    304e:	80 81       	ld	r24, Z
}
    3050:	cf 91       	pop	r28
    3052:	df 91       	pop	r29
    3054:	08 95       	ret

00003056 <UART_sendString>:
/*
 * Description :
 * Send the required string through UART to the other UART device.
 */
void UART_sendString(const uint8 *Str)
{
    3056:	df 93       	push	r29
    3058:	cf 93       	push	r28
    305a:	00 d0       	rcall	.+0      	; 0x305c <UART_sendString+0x6>
    305c:	0f 92       	push	r0
    305e:	cd b7       	in	r28, 0x3d	; 61
    3060:	de b7       	in	r29, 0x3e	; 62
    3062:	9b 83       	std	Y+3, r25	; 0x03
    3064:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    3066:	19 82       	std	Y+1, r1	; 0x01
    3068:	0e c0       	rjmp	.+28     	; 0x3086 <UART_sendString+0x30>

	/* Send the whole string */
	while(Str[i] != '\0')
	{
		UART_sendByte(Str[i]);
    306a:	89 81       	ldd	r24, Y+1	; 0x01
    306c:	28 2f       	mov	r18, r24
    306e:	30 e0       	ldi	r19, 0x00	; 0
    3070:	8a 81       	ldd	r24, Y+2	; 0x02
    3072:	9b 81       	ldd	r25, Y+3	; 0x03
    3074:	fc 01       	movw	r30, r24
    3076:	e2 0f       	add	r30, r18
    3078:	f3 1f       	adc	r31, r19
    307a:	80 81       	ld	r24, Z
    307c:	0e 94 05 18 	call	0x300a	; 0x300a <UART_sendByte>
		i++;
    3080:	89 81       	ldd	r24, Y+1	; 0x01
    3082:	8f 5f       	subi	r24, 0xFF	; 255
    3084:	89 83       	std	Y+1, r24	; 0x01
void UART_sendString(const uint8 *Str)
{
	uint8 i = 0;

	/* Send the whole string */
	while(Str[i] != '\0')
    3086:	89 81       	ldd	r24, Y+1	; 0x01
    3088:	28 2f       	mov	r18, r24
    308a:	30 e0       	ldi	r19, 0x00	; 0
    308c:	8a 81       	ldd	r24, Y+2	; 0x02
    308e:	9b 81       	ldd	r25, Y+3	; 0x03
    3090:	fc 01       	movw	r30, r24
    3092:	e2 0f       	add	r30, r18
    3094:	f3 1f       	adc	r31, r19
    3096:	80 81       	ld	r24, Z
    3098:	88 23       	and	r24, r24
    309a:	39 f7       	brne	.-50     	; 0x306a <UART_sendString+0x14>
	{
		UART_sendByte(*Str);
		Str++;
	}		
	 *******************************************************************/
}
    309c:	0f 90       	pop	r0
    309e:	0f 90       	pop	r0
    30a0:	0f 90       	pop	r0
    30a2:	cf 91       	pop	r28
    30a4:	df 91       	pop	r29
    30a6:	08 95       	ret

000030a8 <UART_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through UART from the other UART device.
 */
void UART_receiveString(uint8 *Str)
{
    30a8:	0f 93       	push	r16
    30aa:	1f 93       	push	r17
    30ac:	df 93       	push	r29
    30ae:	cf 93       	push	r28
    30b0:	00 d0       	rcall	.+0      	; 0x30b2 <UART_receiveString+0xa>
    30b2:	0f 92       	push	r0
    30b4:	cd b7       	in	r28, 0x3d	; 61
    30b6:	de b7       	in	r29, 0x3e	; 62
    30b8:	9b 83       	std	Y+3, r25	; 0x03
    30ba:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    30bc:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_recieveByte();
    30be:	89 81       	ldd	r24, Y+1	; 0x01
    30c0:	28 2f       	mov	r18, r24
    30c2:	30 e0       	ldi	r19, 0x00	; 0
    30c4:	8a 81       	ldd	r24, Y+2	; 0x02
    30c6:	9b 81       	ldd	r25, Y+3	; 0x03
    30c8:	8c 01       	movw	r16, r24
    30ca:	02 0f       	add	r16, r18
    30cc:	13 1f       	adc	r17, r19
    30ce:	0e 94 1c 18 	call	0x3038	; 0x3038 <UART_recieveByte>
    30d2:	f8 01       	movw	r30, r16
    30d4:	80 83       	st	Z, r24
    30d6:	0f c0       	rjmp	.+30     	; 0x30f6 <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
	{
		i++;
    30d8:	89 81       	ldd	r24, Y+1	; 0x01
    30da:	8f 5f       	subi	r24, 0xFF	; 255
    30dc:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_recieveByte();
    30de:	89 81       	ldd	r24, Y+1	; 0x01
    30e0:	28 2f       	mov	r18, r24
    30e2:	30 e0       	ldi	r19, 0x00	; 0
    30e4:	8a 81       	ldd	r24, Y+2	; 0x02
    30e6:	9b 81       	ldd	r25, Y+3	; 0x03
    30e8:	8c 01       	movw	r16, r24
    30ea:	02 0f       	add	r16, r18
    30ec:	13 1f       	adc	r17, r19
    30ee:	0e 94 1c 18 	call	0x3038	; 0x3038 <UART_recieveByte>
    30f2:	f8 01       	movw	r30, r16
    30f4:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_recieveByte();

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
    30f6:	89 81       	ldd	r24, Y+1	; 0x01
    30f8:	28 2f       	mov	r18, r24
    30fa:	30 e0       	ldi	r19, 0x00	; 0
    30fc:	8a 81       	ldd	r24, Y+2	; 0x02
    30fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3100:	fc 01       	movw	r30, r24
    3102:	e2 0f       	add	r30, r18
    3104:	f3 1f       	adc	r31, r19
    3106:	80 81       	ld	r24, Z
    3108:	83 32       	cpi	r24, 0x23	; 35
    310a:	31 f7       	brne	.-52     	; 0x30d8 <UART_receiveString+0x30>
		i++;
		Str[i] = UART_recieveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
    310c:	89 81       	ldd	r24, Y+1	; 0x01
    310e:	28 2f       	mov	r18, r24
    3110:	30 e0       	ldi	r19, 0x00	; 0
    3112:	8a 81       	ldd	r24, Y+2	; 0x02
    3114:	9b 81       	ldd	r25, Y+3	; 0x03
    3116:	fc 01       	movw	r30, r24
    3118:	e2 0f       	add	r30, r18
    311a:	f3 1f       	adc	r31, r19
    311c:	10 82       	st	Z, r1
}
    311e:	0f 90       	pop	r0
    3120:	0f 90       	pop	r0
    3122:	0f 90       	pop	r0
    3124:	cf 91       	pop	r28
    3126:	df 91       	pop	r29
    3128:	1f 91       	pop	r17
    312a:	0f 91       	pop	r16
    312c:	08 95       	ret

0000312e <__udivmodsi4>:
    312e:	a1 e2       	ldi	r26, 0x21	; 33
    3130:	1a 2e       	mov	r1, r26
    3132:	aa 1b       	sub	r26, r26
    3134:	bb 1b       	sub	r27, r27
    3136:	fd 01       	movw	r30, r26
    3138:	0d c0       	rjmp	.+26     	; 0x3154 <__udivmodsi4_ep>

0000313a <__udivmodsi4_loop>:
    313a:	aa 1f       	adc	r26, r26
    313c:	bb 1f       	adc	r27, r27
    313e:	ee 1f       	adc	r30, r30
    3140:	ff 1f       	adc	r31, r31
    3142:	a2 17       	cp	r26, r18
    3144:	b3 07       	cpc	r27, r19
    3146:	e4 07       	cpc	r30, r20
    3148:	f5 07       	cpc	r31, r21
    314a:	20 f0       	brcs	.+8      	; 0x3154 <__udivmodsi4_ep>
    314c:	a2 1b       	sub	r26, r18
    314e:	b3 0b       	sbc	r27, r19
    3150:	e4 0b       	sbc	r30, r20
    3152:	f5 0b       	sbc	r31, r21

00003154 <__udivmodsi4_ep>:
    3154:	66 1f       	adc	r22, r22
    3156:	77 1f       	adc	r23, r23
    3158:	88 1f       	adc	r24, r24
    315a:	99 1f       	adc	r25, r25
    315c:	1a 94       	dec	r1
    315e:	69 f7       	brne	.-38     	; 0x313a <__udivmodsi4_loop>
    3160:	60 95       	com	r22
    3162:	70 95       	com	r23
    3164:	80 95       	com	r24
    3166:	90 95       	com	r25
    3168:	9b 01       	movw	r18, r22
    316a:	ac 01       	movw	r20, r24
    316c:	bd 01       	movw	r22, r26
    316e:	cf 01       	movw	r24, r30
    3170:	08 95       	ret

00003172 <__divmodsi4>:
    3172:	97 fb       	bst	r25, 7
    3174:	09 2e       	mov	r0, r25
    3176:	05 26       	eor	r0, r21
    3178:	0e d0       	rcall	.+28     	; 0x3196 <__divmodsi4_neg1>
    317a:	57 fd       	sbrc	r21, 7
    317c:	04 d0       	rcall	.+8      	; 0x3186 <__divmodsi4_neg2>
    317e:	d7 df       	rcall	.-82     	; 0x312e <__udivmodsi4>
    3180:	0a d0       	rcall	.+20     	; 0x3196 <__divmodsi4_neg1>
    3182:	00 1c       	adc	r0, r0
    3184:	38 f4       	brcc	.+14     	; 0x3194 <__divmodsi4_exit>

00003186 <__divmodsi4_neg2>:
    3186:	50 95       	com	r21
    3188:	40 95       	com	r20
    318a:	30 95       	com	r19
    318c:	21 95       	neg	r18
    318e:	3f 4f       	sbci	r19, 0xFF	; 255
    3190:	4f 4f       	sbci	r20, 0xFF	; 255
    3192:	5f 4f       	sbci	r21, 0xFF	; 255

00003194 <__divmodsi4_exit>:
    3194:	08 95       	ret

00003196 <__divmodsi4_neg1>:
    3196:	f6 f7       	brtc	.-4      	; 0x3194 <__divmodsi4_exit>
    3198:	90 95       	com	r25
    319a:	80 95       	com	r24
    319c:	70 95       	com	r23
    319e:	61 95       	neg	r22
    31a0:	7f 4f       	sbci	r23, 0xFF	; 255
    31a2:	8f 4f       	sbci	r24, 0xFF	; 255
    31a4:	9f 4f       	sbci	r25, 0xFF	; 255
    31a6:	08 95       	ret

000031a8 <__prologue_saves__>:
    31a8:	2f 92       	push	r2
    31aa:	3f 92       	push	r3
    31ac:	4f 92       	push	r4
    31ae:	5f 92       	push	r5
    31b0:	6f 92       	push	r6
    31b2:	7f 92       	push	r7
    31b4:	8f 92       	push	r8
    31b6:	9f 92       	push	r9
    31b8:	af 92       	push	r10
    31ba:	bf 92       	push	r11
    31bc:	cf 92       	push	r12
    31be:	df 92       	push	r13
    31c0:	ef 92       	push	r14
    31c2:	ff 92       	push	r15
    31c4:	0f 93       	push	r16
    31c6:	1f 93       	push	r17
    31c8:	cf 93       	push	r28
    31ca:	df 93       	push	r29
    31cc:	cd b7       	in	r28, 0x3d	; 61
    31ce:	de b7       	in	r29, 0x3e	; 62
    31d0:	ca 1b       	sub	r28, r26
    31d2:	db 0b       	sbc	r29, r27
    31d4:	0f b6       	in	r0, 0x3f	; 63
    31d6:	f8 94       	cli
    31d8:	de bf       	out	0x3e, r29	; 62
    31da:	0f be       	out	0x3f, r0	; 63
    31dc:	cd bf       	out	0x3d, r28	; 61
    31de:	09 94       	ijmp

000031e0 <__epilogue_restores__>:
    31e0:	2a 88       	ldd	r2, Y+18	; 0x12
    31e2:	39 88       	ldd	r3, Y+17	; 0x11
    31e4:	48 88       	ldd	r4, Y+16	; 0x10
    31e6:	5f 84       	ldd	r5, Y+15	; 0x0f
    31e8:	6e 84       	ldd	r6, Y+14	; 0x0e
    31ea:	7d 84       	ldd	r7, Y+13	; 0x0d
    31ec:	8c 84       	ldd	r8, Y+12	; 0x0c
    31ee:	9b 84       	ldd	r9, Y+11	; 0x0b
    31f0:	aa 84       	ldd	r10, Y+10	; 0x0a
    31f2:	b9 84       	ldd	r11, Y+9	; 0x09
    31f4:	c8 84       	ldd	r12, Y+8	; 0x08
    31f6:	df 80       	ldd	r13, Y+7	; 0x07
    31f8:	ee 80       	ldd	r14, Y+6	; 0x06
    31fa:	fd 80       	ldd	r15, Y+5	; 0x05
    31fc:	0c 81       	ldd	r16, Y+4	; 0x04
    31fe:	1b 81       	ldd	r17, Y+3	; 0x03
    3200:	aa 81       	ldd	r26, Y+2	; 0x02
    3202:	b9 81       	ldd	r27, Y+1	; 0x01
    3204:	ce 0f       	add	r28, r30
    3206:	d1 1d       	adc	r29, r1
    3208:	0f b6       	in	r0, 0x3f	; 63
    320a:	f8 94       	cli
    320c:	de bf       	out	0x3e, r29	; 62
    320e:	0f be       	out	0x3f, r0	; 63
    3210:	cd bf       	out	0x3d, r28	; 61
    3212:	ed 01       	movw	r28, r26
    3214:	08 95       	ret

00003216 <itoa>:
    3216:	fb 01       	movw	r30, r22
    3218:	9f 01       	movw	r18, r30
    321a:	e8 94       	clt
    321c:	42 30       	cpi	r20, 0x02	; 2
    321e:	c4 f0       	brlt	.+48     	; 0x3250 <itoa+0x3a>
    3220:	45 32       	cpi	r20, 0x25	; 37
    3222:	b4 f4       	brge	.+44     	; 0x3250 <itoa+0x3a>
    3224:	4a 30       	cpi	r20, 0x0A	; 10
    3226:	29 f4       	brne	.+10     	; 0x3232 <itoa+0x1c>
    3228:	97 fb       	bst	r25, 7
    322a:	1e f4       	brtc	.+6      	; 0x3232 <itoa+0x1c>
    322c:	90 95       	com	r25
    322e:	81 95       	neg	r24
    3230:	9f 4f       	sbci	r25, 0xFF	; 255
    3232:	64 2f       	mov	r22, r20
    3234:	77 27       	eor	r23, r23
    3236:	0e 94 3c 19 	call	0x3278	; 0x3278 <__udivmodhi4>
    323a:	80 5d       	subi	r24, 0xD0	; 208
    323c:	8a 33       	cpi	r24, 0x3A	; 58
    323e:	0c f0       	brlt	.+2      	; 0x3242 <itoa+0x2c>
    3240:	89 5d       	subi	r24, 0xD9	; 217
    3242:	81 93       	st	Z+, r24
    3244:	cb 01       	movw	r24, r22
    3246:	00 97       	sbiw	r24, 0x00	; 0
    3248:	a1 f7       	brne	.-24     	; 0x3232 <itoa+0x1c>
    324a:	16 f4       	brtc	.+4      	; 0x3250 <itoa+0x3a>
    324c:	5d e2       	ldi	r21, 0x2D	; 45
    324e:	51 93       	st	Z+, r21
    3250:	10 82       	st	Z, r1
    3252:	c9 01       	movw	r24, r18
    3254:	0c 94 2c 19 	jmp	0x3258	; 0x3258 <strrev>

00003258 <strrev>:
    3258:	dc 01       	movw	r26, r24
    325a:	fc 01       	movw	r30, r24
    325c:	67 2f       	mov	r22, r23
    325e:	71 91       	ld	r23, Z+
    3260:	77 23       	and	r23, r23
    3262:	e1 f7       	brne	.-8      	; 0x325c <strrev+0x4>
    3264:	32 97       	sbiw	r30, 0x02	; 2
    3266:	04 c0       	rjmp	.+8      	; 0x3270 <strrev+0x18>
    3268:	7c 91       	ld	r23, X
    326a:	6d 93       	st	X+, r22
    326c:	70 83       	st	Z, r23
    326e:	62 91       	ld	r22, -Z
    3270:	ae 17       	cp	r26, r30
    3272:	bf 07       	cpc	r27, r31
    3274:	c8 f3       	brcs	.-14     	; 0x3268 <strrev+0x10>
    3276:	08 95       	ret

00003278 <__udivmodhi4>:
    3278:	aa 1b       	sub	r26, r26
    327a:	bb 1b       	sub	r27, r27
    327c:	51 e1       	ldi	r21, 0x11	; 17
    327e:	07 c0       	rjmp	.+14     	; 0x328e <__udivmodhi4_ep>

00003280 <__udivmodhi4_loop>:
    3280:	aa 1f       	adc	r26, r26
    3282:	bb 1f       	adc	r27, r27
    3284:	a6 17       	cp	r26, r22
    3286:	b7 07       	cpc	r27, r23
    3288:	10 f0       	brcs	.+4      	; 0x328e <__udivmodhi4_ep>
    328a:	a6 1b       	sub	r26, r22
    328c:	b7 0b       	sbc	r27, r23

0000328e <__udivmodhi4_ep>:
    328e:	88 1f       	adc	r24, r24
    3290:	99 1f       	adc	r25, r25
    3292:	5a 95       	dec	r21
    3294:	a9 f7       	brne	.-22     	; 0x3280 <__udivmodhi4_loop>
    3296:	80 95       	com	r24
    3298:	90 95       	com	r25
    329a:	bc 01       	movw	r22, r24
    329c:	cd 01       	movw	r24, r26
    329e:	08 95       	ret

000032a0 <_exit>:
    32a0:	f8 94       	cli

000032a2 <__stop_program>:
    32a2:	ff cf       	rjmp	.-2      	; 0x32a2 <__stop_program>
